<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello！Welcom to Tumy-Time！</title>
  
  
  <link href="http://tumytime.github.io/atom.xml" rel="self"/>
  
  <link href="http://tumytime.github.io/"/>
  <updated>2024-10-10T09:14:48.265Z</updated>
  <id>http://tumytime.github.io/</id>
  
  <author>
    <name>tumytime</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理（一）</title>
    <link href="http://tumytime.github.io/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-10-10T06:52:52.000Z</published>
    <updated>2024-10-10T09:14:48.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h2><p>8位，16位，32位，64位：<br>计算机一次整数运算所能处理的二进制位数</p><h2 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>概括的来讲，冯·诺伊曼结构消除了原始计算机体系中，只能依靠硬件控制程序的状况（当时程序作为控制器的一部分，作为硬件存在），它将程序编码储存在存储器中，实现了可编程的计算机功能</p><ol><li>构成程序的指令和存储的数据均采用二进制表示</li><li>指令和数据都存放在主（内）存储器中，计算机在工作时按地址访问并执行</li><li>指令由操作码和地址码组成，每一段指令都有其地址</li><li>计算机硬件由运算器、控制器、存储器、输入设备、输出设备这五大部分组成</li><li>机器以运算器为中心，输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成</li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://i-blog.csdnimg.cn/blog_migrate/04d05407dabb2399de571d4f00644b47.png" class="lazyload placeholder" data-srcset="https://i-blog.csdnimg.cn/blog_migrate/04d05407dabb2399de571d4f00644b47.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>在冯诺依曼结构中，控制器与其他4个部件都通过控制线与反馈线相连接，控制器通过控制线发送信号控制4个部件进行工作，这些部件通过反馈线将信息反馈给控制器。控制器将用户通过输入设备输入的信息交由运算器进行运算，存储器存储输入设备输入的数据和要控制器要执行的指令，在控制的控制下也可以将存储器存储的信息交由输出设备进行输出。这样一次信息的运算（交互）在5个部件的协同配合下完成了。<br>但是这样以运算器为中心的结构中也存在一定的问题，那就是即使不需要运算器参与的输入&#x2F;输出操作时运算器也会参与进来运算，浪费了运算器性能。<br>现代计算机一般以存储器为中心，这样输入&#x2F;输出设备就可以直接与存储器交换数据，提高整体效率，如图所示。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://i-blog.csdnimg.cn/blog_migrate/b90d8af254e2846cac652574bf57d869.png" class="lazyload placeholder" data-srcset="https://i-blog.csdnimg.cn/blog_migrate/b90d8af254e2846cac652574bf57d869.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机器字长&quot;&gt;&lt;a href=&quot;#机器字长&quot; class=&quot;headerlink&quot; title=&quot;机器字长&quot;&gt;&lt;/a&gt;机器字长&lt;/h2&gt;&lt;p&gt;8位，16位，32位，64位：&lt;br&gt;计算机一次整数运算所能处理的二进制位数&lt;/p&gt;
&lt;h2 id=&quot;冯诺依曼体系结构&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux报错合集</title>
    <link href="http://tumytime.github.io/2024/09/30/Linux%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/"/>
    <id>http://tumytime.github.io/2024/09/30/Linux%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</id>
    <published>2024-09-30T13:18:22.000Z</published>
    <updated>2024-09-30T13:19:49.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无法定位软件包"><a href="#无法定位软件包" class="headerlink" title="无法定位软件包"></a>无法定位软件包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><blockquote><p>如果你的默认仓库没有这个软件包，你可能需要添加额外的仓库。例如，对于Ubuntu，你可以添加universe仓库，它通常包含更多的软件包</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无法定位软件包&quot;&gt;&lt;a href=&quot;#无法定位软件包&quot; class=&quot;headerlink&quot; title=&quot;无法定位软件包&quot;&gt;&lt;/a&gt;无法定位软件包&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://tumytime.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用OpenCV写UI界面</title>
    <link href="http://tumytime.github.io/2024/09/27/%E7%94%A8OpenCV%E5%86%99UI%E7%95%8C%E9%9D%A2/"/>
    <id>http://tumytime.github.io/2024/09/27/%E7%94%A8OpenCV%E5%86%99UI%E7%95%8C%E9%9D%A2/</id>
    <published>2024-09-27T13:29:55.000Z</published>
    <updated>2024-09-30T11:34:54.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前电赛队友的物理按钮不够了，为了方便快捷，就用了这个，好用，就是运行时间长了可能失效(在树莓派5上当时使用的时候是这样)</p></blockquote><div class="tagLink"><a class="link-card" title="cvui" href="https://fernandobevilacqua.com/cvui/"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">cvui</p><p class="url">https://fernandobevilacqua.com/cvui/</p></div></a></div><div class="tagLink"><a class="link-card" title="cvui的github仓库地址" href="https://github.com/Dovyski/cvui/releases/tag/v2.7.0"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">cvui的github仓库地址</p><p class="url">https://github.com/Dovyski/cvui/releases/tag/v2.7.0</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前电赛队友的物理按钮不够了，为了方便快捷，就用了这个，好用，就是运行时间长了可能失效(在树莓派5上当时使用的时候是这样)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; ti</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="opencv" scheme="http://tumytime.github.io/tags/opencv/"/>
    
    <category term="UI" scheme="http://tumytime.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>【Jetson-Nano学习笔记】Jetson_Inference</title>
    <link href="http://tumytime.github.io/2024/09/24/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91py%E7%89%88Jetson-Inference/"/>
    <id>http://tumytime.github.io/2024/09/24/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91py%E7%89%88Jetson-Inference/</id>
    <published>2024-09-24T09:38:47.000Z</published>
    <updated>2024-09-24T10:03:17.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人体姿态检测的网络模型加载脚本"><a href="#人体姿态检测的网络模型加载脚本" class="headerlink" title="人体姿态检测的网络模型加载脚本"></a>人体姿态检测的网络模型加载脚本</h2><details open><summary pointer> posenet.py </summary>              <div class='content'>              <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Permission is hereby granted, free of charge, to any person obtaining a</span></span><br><span class="line"><span class="comment"># copy of this software and associated documentation files (the &quot;Software&quot;),</span></span><br><span class="line"><span class="comment"># to deal in the Software without restriction, including without limitation</span></span><br><span class="line"><span class="comment"># the rights to use, copy, modify, merge, publish, distribute, sublicense,</span></span><br><span class="line"><span class="comment"># and/or sell copies of the Software, and to permit persons to whom the</span></span><br><span class="line"><span class="comment"># Software is furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"># all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span></span><br><span class="line"><span class="comment"># THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span></span><br><span class="line"><span class="comment"># DEALINGS IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jetson_inference <span class="keyword">import</span> poseNet</span><br><span class="line"><span class="keyword">from</span> jetson_utils <span class="keyword">import</span> videoSource, videoOutput, Log</span><br><span class="line"></span><br><span class="line"><span class="comment"># parse the command line</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;Run pose estimation DNN on a video/image stream.&quot;</span>, </span><br><span class="line">                                 formatter_class=argparse.RawTextHelpFormatter, </span><br><span class="line">                                 epilog=poseNet.Usage() + videoSource.Usage() + videoOutput.Usage() + Log.Usage())</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&quot;input&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;&quot;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;URI of the input stream&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;output&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;&quot;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;URI of the output stream&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--network&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;resnet18-body&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;pre-trained model to load (see below for options)&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--overlay&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;links,keypoints&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;pose overlay flags (e.g. --overlay=links,keypoints)\nvalid combinations are:  &#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--threshold&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.15</span>, <span class="built_in">help</span>=<span class="string">&quot;minimum detection threshold to use&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">args = parser.parse_known_args()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">parser.print_help()</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load the pose estimation model</span></span><br><span class="line">net = poseNet(args.network, sys.argv, args.threshold)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create video sources &amp; outputs</span></span><br><span class="line"><span class="built_in">input</span> = videoSource(args.<span class="built_in">input</span>, argv=sys.argv)</span><br><span class="line">output = videoOutput(args.output, argv=sys.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process frames until EOS or the user exits</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># capture the next image</span></span><br><span class="line">    img = <span class="built_in">input</span>.Capture()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># timeout</span></span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform pose estimation (with overlay)</span></span><br><span class="line">    poses = net.Process(img, overlay=args.overlay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print the pose results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;detected &#123;:d&#125; objects in image&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(poses)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pose <span class="keyword">in</span> poses:</span><br><span class="line">        <span class="built_in">print</span>(pose)</span><br><span class="line">        <span class="built_in">print</span>(pose.Keypoints)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Links&#x27;</span>, pose.Links)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># render the image</span></span><br><span class="line">    output.Render(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the title bar</span></span><br><span class="line">    output.SetStatus(<span class="string">&quot;&#123;:s&#125; | Network &#123;:.0f&#125; FPS&quot;</span>.<span class="built_in">format</span>(args.network, net.GetNetworkFPS()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print out performance info</span></span><br><span class="line">    net.PrintProfilerTimes()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># exit on input/output EOS</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">input</span>.IsStreaming() <span class="keyword">or</span> <span class="keyword">not</span> output.IsStreaming():</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>当然，以下是关于 <code>sys</code> 模块以及 <code>sys.exit(0)</code> 和 <code>sys.argv</code> 的详细解释：</p><h4 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a><code>sys</code> 模块</h4><p><code>sys</code> 是 Python 的一个内置模块，它提供了对解释器使用或维护的某些变量的访问，以及与解释器强烈相关的函数。这个模块包含了与 Python 解释器及其环境操作相关的功能。<br>以下是一些 <code>sys</code> 模块提供的常见功能：</p><ul><li>访问命令行参数 (<code>sys.argv</code>)</li><li>控制解释器行为（例如，<code>sys.exit()</code>）</li><li>访问系统特定的参数和函数（例如，<code>sys.platform</code>）</li><li>捕获和处理异常（例如，<code>sys.exc_info()</code>）</li></ul><h4 id="sys-exit-arg"><a href="#sys-exit-arg" class="headerlink" title="sys.exit([arg])"></a><code>sys.exit([arg])</code></h4><p><code>sys.exit()</code> 是一个函数，用于从 Python 程序中退出。当你调用 <code>sys.exit()</code> 时，它会引发一个 <code>SystemExit</code> 异常。这个异常可以通过代码捕获，如果不被捕获，则会终止程序。<br>参数 <code>arg</code> 可以是以下之一：</p><ul><li>如果没有提供参数或参数为 <code>None</code>，则退出代码默认为 <code>0</code>，表示正常退出。</li><li>如果提供了整数，则该整数将用作退出代码返回给调用环境。通常，退出代码 <code>0</code> 表示成功，非零值表示错误或特定类型的错误。<br>在示例代码中，<code>sys.exit(0)</code> 用于在解析命令行参数失败时退出程序，返回代码 <code>0</code> 表示正常退出。</li></ul><h4 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a><code>sys.argv</code></h4><p><code>sys.argv</code> 是一个列表，包含了命令行传递给 Python 脚本的参数。<code>argv</code> 是 “argument vector” 的缩写，它通常包含以下内容：</p><ul><li><code>sys.argv[0]</code>：脚本的名称（作为执行命令的一部分）。</li><li><code>sys.argv[1]</code>：第一个命令行参数。</li><li><code>sys.argv[2]</code>：第二个命令行参数。</li><li>…以此类推。<br>例如，如果你从命令行运行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py arg1 arg2 arg3</span><br></pre></td></tr></table></figure>那么 <code>sys.argv</code> 将会是这样的列表：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;script.py&#x27;</span>, <span class="string">&#x27;arg1&#x27;</span>, <span class="string">&#x27;arg2&#x27;</span>, <span class="string">&#x27;arg3&#x27;</span>]</span><br></pre></td></tr></table></figure>在示例代码中，<code>sys.argv</code> 被传递给 <code>argparse</code> 解析器，以便它可以解析脚本名称后面的所有命令行参数。此外，<code>sys.argv</code> 也被传递给 <code>videoSource</code> 和 <code>videoOutput</code>，这样它们就可以处理传递给它们的任何额外参数。</li></ul><h3 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h3><p><code>argparse</code> 是 Python 标准库中的一个模块，它提供了一个方便的方式来解析命令行参数。这个模块使得编写用户友好的命令行接口变得简单。下面是关于 <code>argparse</code> 的详细解释：</p><h4 id="为什么要使用-argparse？"><a href="#为什么要使用-argparse？" class="headerlink" title="为什么要使用 argparse？"></a>为什么要使用 <code>argparse</code>？</h4><p>在命令行工具和脚本中，经常需要处理用户输入的参数。在没有 <code>argparse</code> 之前，开发者通常会使用 <code>sys.argv</code> 直接处理这些参数，但这种方法在参数类型多样、参数数量较多或者需要帮助信息和错误处理时变得复杂。<code>argparse</code> 模块提供以下功能：</p><ul><li>自动生成帮助信息和使用说明。</li><li>支持不同类型的参数（如整数、浮点数、布尔值等）。</li><li>支持默认值。</li><li>生成错误信息并处理非法输入。</li></ul><h4 id="argparse-基础使用"><a href="#argparse-基础使用" class="headerlink" title="argparse 基础使用"></a><code>argparse</code> 基础使用</h4><p>以下是使用 <code>argparse</code> 的基本步骤：</p><ol><li><strong>导入模块</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure></li><li><strong>创建解析器</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some integers.&#x27;</span>)</span><br></pre></td></tr></table></figure>这里 <code>description</code> 参数是可选的，但建议提供，因为它会在帮助信息中显示。</li><li><strong>添加参数</strong>：<br>使用 <code>add_argument()</code> 方法添加参数。例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;an integer for the accumulator&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sum&#x27;</span>, dest=<span class="string">&#x27;accumulate&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>,</span><br><span class="line">                    const=<span class="built_in">sum</span>, default=<span class="built_in">max</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;sum the integers (default: find the max)&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>&#39;integers&#39;</code> 是参数的名字，它在命令行中使用。</li><li><code>metavar=&#39;N&#39;</code> 定义了在帮助信息中显示的参数名。</li><li><code>type=int</code> 指定了参数应该被转换为整数。</li><li><code>nargs=&#39;+&#39;</code> 表示这个参数可以接收一个或多个值。</li><li><code>help=&#39;...&#39;</code> 提供了关于参数的简要说明。</li></ul></li><li><strong>解析参数</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>这将处理命令行参数并返回一个包含所有参数值的 <code>Namespace</code> 对象。</li><li><strong>使用参数</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure>在这个例子中，<code>args.integers</code> 包含了所有提供的整数，<code>args.accumulate</code> 是一个函数（<code>sum</code> 或 <code>max</code>），它将被应用到这些整数上。</li></ol><h4 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h4><p><code>argparse</code> 还提供了许多高级功能，比如：</p><ul><li><strong>子命令</strong>：可以为程序定义多个子命令，每个子命令有自己的参数。</li><li><strong>互斥组</strong>：使用 <code>argparse</code> 的 <code>add_mutually_exclusive_group()</code> 方法可以创建一组参数，它们之间是互斥的。</li><li><strong>自定义动作</strong>：可以定义自定义动作来处理特定的参数。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的 <code>argparse</code> 使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 创建解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;示例脚本&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;filename&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;文件名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--verbose&#x27;</span>, <span class="string">&#x27;-v&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;详细输出&#x27;</span>)</span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># 使用参数</span></span><br><span class="line"><span class="keyword">if</span> args.verbose:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;处理文件：<span class="subst">&#123;args.filename&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在命令行中，你可以这样调用这个脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py example.txt --verbose</span><br></pre></td></tr></table></figure><p>或者使用简写形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py example.txt -v</span><br></pre></td></tr></table></figure><p><code>argparse</code> 模块功能强大，能够帮助开发者快速构建出健壮、用户友好的命令行工具。</p><h4 id="argparse-解析器配置"><a href="#argparse-解析器配置" class="headerlink" title="argparse 解析器配置"></a><code>argparse</code> 解析器配置</h4><p>以下是对提供的 <code>argparse</code> 解析器配置的详细中文解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 ArgumentParser 对象，用于解析命令行参数。</span></span><br><span class="line"><span class="comment"># ArgumentParser 的参数描述如下：</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">&quot;Run pose estimation DNN on a video/image stream.&quot;</span>,  <span class="comment"># 描述：这个脚本运行在视频/图像流上的姿态估计深度神经网络。</span></span><br><span class="line">    formatter_class=argparse.RawTextHelpFormatter,  <span class="comment"># 格式化类：使用 RawTextHelpFormatter 以保持帮助信息的原始文本格式。</span></span><br><span class="line">    epilog=poseNet.Usage() + videoSource.Usage() + videoOutput.Usage() + Log.Usage()  <span class="comment"># 结尾信息：显示 poseNet、videoSource、videoOutput 和 Log 的使用说明。</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 添加命令行参数，每个 add_argument 方法的参数解释如下：</span></span><br><span class="line"><span class="comment"># 输入流参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;input&quot;</span>,  <span class="comment"># 参数名：input</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;&quot;</span>,  <span class="comment"># 默认值：空字符串</span></span><br><span class="line">    nargs=<span class="string">&#x27;?&#x27;</span>,  <span class="comment"># 参数数量：0或1个，即这个参数是可选的</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;URI of the input stream&quot;</span>  <span class="comment"># 帮助信息：输入流的统一资源标识符（URI）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 输出流参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;output&quot;</span>,  <span class="comment"># 参数名：output</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;&quot;</span>,  <span class="comment"># 默认值：空字符串</span></span><br><span class="line">    nargs=<span class="string">&#x27;?&#x27;</span>,  <span class="comment"># 参数数量：0或1个，即这个参数是可选的</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;URI of the output stream&quot;</span>  <span class="comment"># 帮助信息：输出流的统一资源标识符（URI）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 网络模型参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--network&quot;</span>,  <span class="comment"># 参数名：network，前缀 &#x27;--&#x27; 表示这是一个可选参数</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;resnet18-body&quot;</span>,  <span class="comment"># 默认值：&quot;resnet18-body&quot;</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;pre-trained model to load (see below for options)&quot;</span>  <span class="comment"># 帮助信息：要加载的预训练模型（请参阅下面的选项）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 覆盖层参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--overlay&quot;</span>,  <span class="comment"># 参数名：overlay</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;links,keypoints&quot;</span>,  <span class="comment"># 默认值：&quot;links,keypoints&quot;</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;&quot;&quot;pose overlay flags (e.g. --overlay=links,keypoints)</span></span><br><span class="line"><span class="string">valid combinations are: &#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;&quot;&quot;&quot;</span>  <span class="comment"># 帮助信息：姿态覆盖标志（例如：--overlay=links,keypoints）</span></span><br><span class="line">    <span class="comment"># 合法的组合有：&#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 阈值参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--threshold&quot;</span>,  <span class="comment"># 参数名：threshold</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">float</span>,  <span class="comment"># 参数类型：浮点数</span></span><br><span class="line">    default=<span class="number">0.15</span>,  <span class="comment"># 默认值：0.15</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;minimum detection threshold to use&quot;</span>  <span class="comment"># 帮助信息：要使用的最小检测阈值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个配置为脚本定义了一系列命令行参数，用户可以通过这些参数来控制脚本的运行行为。以下是对每个参数的详细解释：</p><ul><li><code>input</code>：这是一个位置参数，用户必须提供输入流的URI，如果没有提供，则默认为空字符串。这个参数用于指定要处理的视频或图像流的来源。</li><li><code>output</code>：这也是一个位置参数，用户可以提供输出流的URI，如果没有提供，则默认为空字符串。这个参数用于指定处理后的视频或图像流的目的地。</li><li><code>--network</code>：这是一个可选参数，用于指定要加载的预训练模型。用户可以通过这个参数选择不同的网络模型来执行姿态估计。</li><li><code>--overlay</code>：这是一个可选参数，用于指定在输出流上要显示的姿态覆盖层。用户可以选择显示链接、关键点、边界框或者不显示任何覆盖层。</li><li><code>--threshold</code>：这是一个可选参数，用于设置检测姿态的最小阈值。只有当检测置信度高于这个阈值时，姿态才会被识别和显示。<br>用户可以在命令行中按照以下格式提供这些参数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py input_stream_uri output_stream_uri --network model_name --overlay <span class="built_in">type</span> --threshold value</span><br></pre></td></tr></table></figure>其中 <code>input_stream_uri</code> 和 <code>output_stream_uri</code> 是必须提供的，其他参数根据需要选择性地提供。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;人体姿态检测的网络模型加载脚本&quot;&gt;&lt;a href=&quot;#人体姿态检测的网络模型加载脚本&quot; class=&quot;headerlink&quot; title=&quot;人体姿态检测的网络模型加载脚本&quot;&gt;&lt;/a&gt;人体姿态检测的网络模型加载脚本&lt;/h2&gt;&lt;details open&gt;&lt;summar</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/tags/Jetson-Nano/"/>
    
  </entry>
  
  <entry>
    <title>Linux嵌入式QT开发</title>
    <link href="http://tumytime.github.io/2024/09/19/Linux%E5%B5%8C%E5%85%A5%E5%BC%8FQT%E5%BC%80%E5%8F%91/"/>
    <id>http://tumytime.github.io/2024/09/19/Linux%E5%B5%8C%E5%85%A5%E5%BC%8FQT%E5%BC%80%E5%8F%91/</id>
    <published>2024-09-19T12:26:36.000Z</published>
    <updated>2024-10-10T07:08:34.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;小狗的名字是:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="string">&quot;年龄是:&quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dog dog1;</span><br><span class="line"></span><br><span class="line">    dog1.name=<span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">    dog1.age=<span class="number">2</span>;</span><br><span class="line">    dog1.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    Dog *dog2 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == dog2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dog2-&gt;name=<span class="string">&quot;富贵&quot;</span>;</span><br><span class="line">    dog2-&gt;age=<span class="number">1</span>;</span><br><span class="line">    dog2-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> dog2;</span><br><span class="line">    dog2=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="栈上创建-dog1"><a href="#栈上创建-dog1" class="headerlink" title="栈上创建 (dog1)"></a>栈上创建 (<code>dog1</code>)</h4><p><strong>解释：</strong></p><ol><li><strong>声明和定义：</strong> <code>Dog dog1;</code> 在栈上声明并定义了一个<code>Dog</code>类型的对象<code>dog1</code>。栈上的对象在定义它的作用域结束时自动销毁。</li><li><strong>成员赋值：</strong> 通过点操作符<code>.</code>，您可以访问和修改<code>dog1</code>对象的公共成员变量<code>name</code>和<code>age</code>。</li><li><strong>调用成员函数：</strong> <code>dog1.run();</code> 调用了<code>dog1</code>对象的<code>run</code>成员函数，输出小狗的名字和年龄。</li><li><strong>生命周期：</strong> 当<code>main</code>函数执行完毕，<code>dog1</code>对象的生命周期结束，它的析构函数（如果有的话）将被调用，释放它所占用的资源。</li></ol><h4 id="堆上创建-dog2"><a href="#堆上创建-dog2" class="headerlink" title="堆上创建 (dog2)"></a>堆上创建 (<code>dog2</code>)</h4><p><strong>解释：</strong></p><ol><li><strong>动态分配：</strong> <code>Dog *dog2 = new Dog();</code> 使用<code>new</code>关键字在堆上动态分配了一个<code>Dog</code>类型的对象，并返回了这个对象的指针。指针<code>dog2</code>存储了对象在内存中的地址。</li><li><strong>成员赋值：</strong> 由于<code>dog2</code>是一个指针，您需要使用箭头操作符<code>-&gt;</code>来访问对象的成员变量。</li><li><strong>调用成员函数：</strong> 同样使用箭头操作符<code>-&gt;</code>来调用<code>dog2</code>指向的对象的成员函数。</li><li><strong>手动管理生命周期：</strong> 在堆上分配的对象不会自动销毁，需要程序员手动管理。使用<code>delete dog2;</code>来释放<code>dog2</code>指向的内存，防止内存泄漏。之后，将<code>dog2</code>设置为<code>NULL</code>是一个好习惯，这样可以避免悬空指针的问题，即避免使用已经释放的内存。<br> <strong>总结</strong></li></ol><ul><li><strong>栈上创建</strong>的对象生命周期由编译器管理，简单且安全，但栈空间有限，不适合创建大量或大对象。</li><li><strong>堆上创建</strong>的对象生命周期由程序员管理，提供了更大的灵活性，但需要手动释放内存，容易出错（如忘记释放或重复释放内存）。<br>两种方式的选择取决于具体的应用场景和性能要求。在大多数情况下，简单的对象可以使用栈分配，而复杂或大量对象则适合使用堆分配。</li></ul><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><blockquote><p>属于特殊的成员函数</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote><p>构造函数在对象实例化时被系统自动调用，仅调用一次。定义类时，如果没有定义构造函数和析构函数，编译器就会生成一个构造函数和析构函数，只是这个构造函数和析构函数什么事情也不做。</p></blockquote><blockquote><p>构造函数的特点如下:</p><ol><li>构造函数必须与类名同名</li><li>可以重载</li><li>没有返回类型，即使是void也不行</li></ol></blockquote><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><blockquote><p>与构造函数相反，在对象结束其生命周期时系统自动执行析构函数。实际上定义类时，编译器会生成一个析构函数</p></blockquote><blockquote><p>析构函数的特点如下:</p><ol><li>析构函数的格式为~类名()</li><li>调用时释放内存(资源)</li><li>~类名()不能加参数</li><li>没有返回值，即使是void也不行</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Dog</span>();</span><br><span class="line">~<span class="built_in">Dog</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数与析构函数示例&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::<span class="built_in">Dog</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::~<span class="built_in">Dog</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果:</strong><br>构造函数执行！<br>构造函数与析构函数示例<br>析构函数执行！</p><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>在 C++ 中，对象的生命周期指的是对象从创建到销毁的整个过程。生命周期结束意味着对象不再存在，其占用的内存将被回收，并且与该对象相关的资源（如打开的文件句柄、网络连接等）也将被释放。以下是详细说明：</p><h4 id="对象生命周期的几个阶段："><a href="#对象生命周期的几个阶段：" class="headerlink" title="对象生命周期的几个阶段："></a>对象生命周期的几个阶段：</h4><ol><li><strong>创建（Construction）</strong>：<ul><li>当对象被创建时，其生命周期开始。这可以通过多种方式完成，例如在栈上声明、在堆上使用 <code>new</code> 分配或者在全局&#x2F;静态存储区中声明。</li></ul></li><li><strong>存在（Existence）</strong>：<ul><li>在这个阶段，对象是有效的，可以访问其成员变量和调用成员函数。</li></ul></li><li><strong>销毁（Destruction）</strong>：<ul><li>对象的生命周期结束，通常由以下情况触发：<ul><li>栈上的局部对象：当包含它们的代码块（如函数体）结束时。</li><li>堆上的对象：当使用 <code>delete</code> 操作符显式释放它们时。</li><li>全局&#x2F;静态对象：当程序结束时。</li></ul></li></ul></li></ol><h4 id="生命周期结束的具体含义："><a href="#生命周期结束的具体含义：" class="headerlink" title="生命周期结束的具体含义："></a>生命周期结束的具体含义：</h4><ul><li><strong>栈对象</strong>：<ul><li>对于在栈上创建的对象，当它们离开作用域（例如，函数返回）时，它们的析构函数（如果有的话）会被自动调用，随后对象占用的内存将被回收。</li></ul></li><li><strong>堆对象</strong>：<ul><li>对于在堆上创建的对象，必须使用 <code>delete</code> 操作符来显式结束其生命周期。当 <code>delete</code> 被调用时，对象的析构函数会被执行，然后对象占用的内存被回收。</li></ul></li><li><strong>全局&#x2F;静态对象</strong>：<ul><li>全局或静态对象的析构函数会在程序结束时自动调用。</li></ul></li></ul><h4 id="生命周期结束后的行为："><a href="#生命周期结束后的行为：" class="headerlink" title="生命周期结束后的行为："></a>生命周期结束后的行为：</h4><ul><li><strong>成员变量</strong>：<ul><li>对象的成员变量所占用的内存也随之释放。</li></ul></li><li><strong>资源管理</strong>：<ul><li>如果对象负责管理资源（如动态分配的内存、文件句柄等），则其析构函数通常会负责释放这些资源。</li></ul></li><li><strong>引用或指针</strong>：<ul><li>如果有其他变量（如引用或指针）指向该对象，那么这些变量将变成悬空引用或悬空指针，继续使用它们将导致未定义行为。<br>理解对象的生命周期对于编写高效且无内存泄漏的 C++ 程序至关重要。正确管理对象的生命周期可以帮助避免许多常见的编程错误，如内存泄漏、悬挂指针和资源泄露。</li></ul></li></ul><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>一个类的不同对象在调用自己的成员函数时，其实他们调用的是同一段函数代码，那么成员函数如何知道要访问哪个对象的数据成员呢？</p><p>没错，就是通过this指针。每个对象都有一个this指针，this指针记录对象的内存地址。在C++中，this指针是指向类自身数据的指针，简单的来说就是指向当前类的当前实例对象。</p><p>关于类的this指针有以下特点:</p><ol><li>this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为T *const this。也就是一个类里面的成员函数int func(int p),func的原型在编译器看来应该是int func(T *const this,int p)</li><li>this在成员函数的开始前构造，在成员函数的结束后清除</li><li>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好，我是&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> string&amp; newName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = newName; <span class="comment">// 使用this指针更新当前实例的name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个Person实例</span></span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">person2</span><span class="params">(<span class="string">&quot;李四&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用greet方法，通过this指针输出各自的名字</span></span><br><span class="line">    person1.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是张三。</span></span><br><span class="line">    person2.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是李四。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改person1的名字，并再次调用greet方法</span></span><br><span class="line">    person1.<span class="built_in">rename</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    person1.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是王五。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改person2的名字，并再次调用greet方法</span></span><br><span class="line">    person2.<span class="built_in">rename</span>(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    person2.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是赵六。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，<code>Person(const string&amp; name) : name(name) &#123;&#125;</code> 是一个类 <code>Person</code> 的构造函数的定义，使用了初始化列表来初始化成员变量。<br>让我们分解这个构造函数：</p><ul><li><code>Person(const string&amp; name)</code>：这是构造函数的声明，它接受一个 <code>const string&amp;</code> 类型的参数 <code>name</code>。使用 <code>const string&amp;</code> 是一种引用传递的方式，这样可以避免不必要的字符串拷贝，并且保证传递的字符串在函数内部不会被修改。</li><li><code>: name(name)</code>：这是构造函数的初始化列表部分。在这里，<code>name(name)</code> 表示将构造函数的参数 <code>name</code> 的值传递给类的成员变量 <code>name</code>。在初始化列表中，<code>name</code> 出现了两次，第一个 <code>name</code> 是成员变量的名字，第二个 <code>name</code> 是构造函数参数的名字。这种写法有时会导致一些混淆，但它是在告诉编译器，将传入的 <code>name</code> 参数的值赋给成员变量 <code>name</code>。</li><li><code>&#123;&#125;</code>：这是构造函数的函数体。在这个例子中，函数体是空的，因为所有的初始化工作已经在初始化列表中完成了。<br>综上所述，这个构造函数的作用是创建一个 <code>Person</code> 对象，并将其 <code>name</code> 成员变量初始化为传入的参数值。使用初始化列表是一种效率较高的初始化成员变量的方式，特别是当成员变量是引用或常量时，它必须在构造函数体执行之前被初始化。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。在QT里大量的使用了这种特性，当QT里的类不满足自己的要求是，我们可以重写这个类，就是通过继承需要重写的类，来实现自己的类的功能。</p><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>与类的访问修饰限定符一样，继承的方式也有几种。其中，访问修饰符<code>access-specifier</code>是public、protect或private其中的一个，base-class是之前定义过的某个类的名称。如果未使用访问修饰符<code>access-specifier</code>，则默认为private。</p><h3 id="公有继承public"><a href="#公有继承public" class="headerlink" title="公有继承public"></a>公有继承public</h3><p>当一个类派生继承公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问</p><h3 id="保护继承protected"><a href="#保护继承protected" class="headerlink" title="保护继承protected"></a>保护继承protected</h3><p>当一个类派生继承保护基类时，基类的公有和保护成员将成为派生类的保护成员</p><h3 id="私有继承private"><a href="#私有继承private" class="headerlink" title="私有继承private"></a>私有继承private</h3><p>当一个类派生继承私有基类时，基类的公有和保护成员将成为派生类的私有成员</p><p>在面向对象的编程语言中，如 C++，类成员可以被指定为公有（public）、保护（protected）或私有（private），这些关键字用于实现封装，即控制类成员的访问权限。以下是这三种成员的详细解释：<br><strong>公有成员（Public Members）</strong><br>公有成员是在类定义中使用 <code>public</code> 关键字声明的成员。公有成员可以被类的对象直接访问，也可以被类的外部函数访问。</p><ul><li><strong>特点</strong>：<ul><li>可以被类的任何对象访问。</li><li>可以在类的外部通过对象直接访问。</li><li>通常包含类的接口，即那些用于与类交互的函数和属性。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>setName</code> 和 <code>getName</code> 是公有成员函数，它们可以被任何 <code>Person</code> 类的对象调用。<br><strong>保护成员（Protected Members）</strong><br>保护成员是在类定义中使用 <code>protected</code> 关键字声明的成员。保护成员的行为类似于私有成员，但它们可以被派生类访问。</li><li><strong>特点</strong>：<ul><li>不能被类的对象直接访问。</li><li>可以被类的成员函数访问。</li><li>可以被派生类（子类）的成员函数访问。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProtectedData</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        protectedData = data; <span class="comment">// 在派生类中可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>protectedData</code> 是保护成员，它不能被 <code>Base</code> 类的对象直接访问，但可以在 <code>Derived</code> 类的成员函数 <code>setProtectedData</code> 中访问。<br><strong>私有成员（Private Members）</strong><br>私有成员是在类定义中使用 <code>private</code> 关键字声明的成员。私有成员只能被类的成员函数访问，不能被类的对象或类的外部函数直接访问。</li><li><strong>特点</strong>：<ul><li>不能被类的对象直接访问。</li><li>可以被类的成员函数访问。</li><li>不能被派生类访问，除非通过基类的公有或保护成员函数。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> newAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newAge &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            age = newAge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>age</code> 是私有成员，它不能被 <code>Person</code> 类的对象直接访问，但可以通过公有成员函数 <code>setAge</code> 和 <code>getAge</code> 来设置和获取。<br>通过使用公有、保护和私有成员，C++ 类可以隐藏其内部实现细节，只暴露必要的接口，这是面向对象编程中的一个重要原则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">animal</span> &#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">string color;</span><br><span class="line"></span><br><span class="line">&#125;animal;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.age = <span class="number">2</span>;</span><br><span class="line">dog.animal.color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">dog.animal.weight = <span class="number">120</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;名字:&quot;</span> &lt;&lt; dog.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; dog.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;颜色:&quot;</span> &lt;&lt; dog.animal.color &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;体重:&quot;</span> &lt;&lt; dog.animal.weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<code>函数重载</code>和<code>运算符重载</code></p><p>重载声明是指一个与之前已经在该作用域声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义(实现)不相同</p><p>当调用时，编译器通过使用的参数类型和定义中的参数类型进行比较。决定选用最合适的定义，这个过程称为<code>重载决策</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数必须不同。我们不能仅通过返回类型的不同来重载函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的体重是:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;kG&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getWeight</span><span class="params">(<span class="type">double</span> weight)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的体重是:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;kG&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.<span class="built_in">getWeight</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="built_in">getWeight</span>(<span class="number">10.5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免用户传入的参数类型不在我们写的重载函数里，还可以多写几个类型的</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的C++多态。要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式:operatorp(argument-list),operator后面的<code>p</code>为要重载的运算符符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt;<span class="built_in">operator</span>&lt;运算符符号&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">Dog <span class="keyword">operator</span>+(<span class="type">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.weight = <span class="keyword">this</span>-&gt;weight + d;</span><br><span class="line"><span class="keyword">return</span> dog;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog1;</span><br><span class="line">Dog dog2;</span><br><span class="line">Dog dog3;</span><br><span class="line"></span><br><span class="line">dog1.weight = <span class="number">10</span>;</span><br><span class="line">dog2.weight = <span class="number">20</span>;</span><br><span class="line">dog3 = dog1 + <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三只狗的体重:&quot;</span> &lt;&lt; dog3.weight &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；<br>形成多态必须具备三个条件:</p><ol><li>必须存在继承关系</li><li>继承关系必须有同名虚函数(其中虚函数是在基类中使用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数)</li><li>存在基类类型的指针或引用，通过该指针或引用调用虚函数</li></ol><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。虚函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span></span></span><br></pre></td></tr></table></figure><p>虚函数必须实现。如果不实现，编译器将报错</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>若在基类中定义虚函数，以便在派生类中重新定义改函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。纯虚函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向该抽象类的具体类的指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Dog的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal;</span><br><span class="line">Dog dog;</span><br><span class="line">Cat cat;</span><br><span class="line"></span><br><span class="line">animal = &amp;dog;</span><br><span class="line">animal-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">animal = &amp;cat;</span><br><span class="line">animal-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受外界的干扰和误用，从而保证了安全。数据封装引申出了另一个重要的OOP概念，即数据隐藏。<br>数据封装是一种把数据和操作数据的函数绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，C++通过创建类来支持封装和数据隐藏(public、protected、private)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">total = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFood</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">total = total + number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line"></span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line"></span><br><span class="line">dog.<span class="built_in">addFood</span>(<span class="number">3</span>);</span><br><span class="line">dog.<span class="built_in">addFood</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dog.name &lt;&lt; <span class="string">&quot;总共获得了&quot;</span> &lt;&lt; dog.<span class="built_in">getFood</span>() &lt;&lt; <span class="string">&quot;份食物&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="QT" scheme="http://tumytime.github.io/categories/QT/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="QT" scheme="http://tumytime.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>智能台灯</title>
    <link href="http://tumytime.github.io/2024/09/18/%E6%99%BA%E8%83%BD%E5%8F%B0%E7%81%AF/"/>
    <id>http://tumytime.github.io/2024/09/18/%E6%99%BA%E8%83%BD%E5%8F%B0%E7%81%AF/</id>
    <published>2024-09-18T13:29:31.000Z</published>
    <updated>2024-10-03T16:33:20.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jetson Nano引脚图<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6m3v0bkaa5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6m3v0bkaa5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></p></blockquote><blockquote><p>本来想在jetson nano上跑一个live2d，但是live2d官方编译好的链接库对于linux只有x86_64的版本，我又没找到怎么重新编译，然后就想到也许live2d在windows的电脑上跑然后和jetson nano主控进行一个交互也许更有意思（例如点击什么的会有灯光特效）就有点像对于一个桌宠有了灯光外设</p></blockquote><blockquote><p>现在的方案是，主控全部使用Jetson Nano，虽然因为机箱的拓展板把所有Jetson Nano的IO口都占了，所以有关检测光照强度的任务就不使用光照传感器了，直接使用opencv检测光照强度，虽然不精准，但是在大的范围，比如说在实验室测试的开关灯，还是可以大致检测出来的。</p></blockquote><blockquote><p>然后就是用QT写界面，现在已经有了一个大致的带滑动转换界面的一个Demo，可以魔改</p></blockquote><blockquote><p>然后人与桌面距离检测的方案就是，AI部分使用Jetson Inferenced的人体关键点检测（主要用到的就是人脸关键点和肩膀位置的关键点），精准距离检测方案就是假设人的眼距是大致相同的（取一个标准值），然后根据鼻子到脖子中间拉的一条线的斜率得出人体相对摄像头的旋转角度，计算出这个旋转角度下人的平面眼距的绝对值，然后和图片里的眼距长度对比，从而判断出人距离摄像头的距离，</p></blockquote><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Jetson Nano引脚图&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img lazyload placeholder&quot; src=&quot;https://tumytime.github.i</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/tags/Jetson-Nano/"/>
    
  </entry>
  
  <entry>
    <title>【李飞飞的AI课】Introduction to Convolut</title>
    <link href="http://tumytime.github.io/2024/09/16/%E3%80%90%E6%9D%8E%E9%A3%9E%E9%A3%9E%E7%9A%84AI%E8%AF%BE%E3%80%91Introduction-to-Convolut/"/>
    <id>http://tumytime.github.io/2024/09/16/%E3%80%90%E6%9D%8E%E9%A3%9E%E9%A3%9E%E7%9A%84AI%E8%AF%BE%E3%80%91Introduction-to-Convolut/</id>
    <published>2024-09-16T12:24:34.000Z</published>
    <updated>2024-09-18T13:10:43.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k-Nearest-Neighbors分类算法"><a href="#k-Nearest-Neighbors分类算法" class="headerlink" title="k-Nearest Neighbors分类算法"></a>k-Nearest Neighbors分类算法</h2><blockquote><p>单纯比较相似性</p></blockquote><p>k-最近邻（k-Nearest Neighbors，k-NN）算法是一种简单的机器学习算法，用于分类和回归分析。在分类问题中，k-NN 算法根据训练数据集中的 k 个最接近的样本（称为“邻居”）来预测新样本的类别。<br>以下是 k-NN 算法的基本步骤：</p><ol><li><strong>选择 k 值</strong>：首先，你需要选择一个正整数 k，这决定了算法中要考虑的最近邻的数量。k 的值通常通过交叉验证等方法来确定，但也可以根据具体问题设定。</li><li><strong>计算距离</strong>：对于新样本，计算它与训练数据集中每个样本的距离。常用的距离度量有欧几里得距离、曼哈顿距离、余弦距离等。</li><li><strong>选择邻居</strong>：根据距离，选择 k 个最近的样本。这些样本称为“k 个最近邻”。</li><li><strong>预测类别</strong>：根据最近邻的类别，对新样本进行预测。通常使用多数表决原则，即新样本的类别是 k 个最近邻中出现次数最多的类别。如果 k 个邻居中有多个类别出现次数相同，那么新样本的类别是不确定的。</li><li><strong>回归分析</strong>：在回归问题中，k-NN 算法预测新样本的值是 k 个最近邻的值的平均值或加权平均值。<br>k-NN 算法的一些关键特性：</li></ol><ul><li><strong>简单直观</strong>：k-NN 算法非常直观，易于理解和实现。</li><li><strong>不需要训练</strong>：k-NN 算法不需要训练模型，因为它不需要学习参数，而是直接使用训练数据进行预测。</li><li><strong>高维数据</strong>：k-NN 算法可以处理高维数据，因为它只是计算样本之间的距离，而不是对数据进行降维或特征选择。</li><li><strong>计算复杂度</strong>：k-NN 算法的计算复杂度较高，因为它需要计算新样本与所有训练样本的距离，并选择最近的 k 个邻居。<br>k-NN 算法在处理小规模数据集或当新样本的类别可以从其邻近样本的类别中直观地推断出来时效果较好。然而，在处理大规模数据集或当新样本的类别难以从其邻近样本的类别中推断出来时，k-NN 算法可能不够有效。此外，k-NN 算法对噪声和异常值比较敏感，因此在实际应用中可能需要对数据进行预处理。</li></ul><details open><summary pointer> 欧式距离与曼哈顿距离的区别 </summary>              <div class='content'>              <ul><li><p><strong>欧氏距离就是我们最常用的两点之间的直线距离。</strong></p><p> 以二维空间为例，两点(x1,y1),(x2,y2)之间的欧式距离为：</p><p> $ \rho  &#x3D; \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} $</p></li><li><p><strong>曼哈顿距离则表示两个点在标准坐标系上的绝对轴距之和。</strong></p><p>  还是以二维空间为例，两点(x1,y1),(x2,y2)之间的曼哈顿距离为：</p><p>  $ c &#x3D; |x_1-x_2|+|y_1-y_2| $</p></li></ul><p>用一张图来区分一下两者:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4xuhzreg8k.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4xuhzreg8k.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>为什么要提出曼哈顿距离呢？</strong><br>——为了简化计算。</p><p>曼哈顿距离中的距离计算公式比欧氏距离的计算公式看起来简洁很多，只需要把两个点坐标的 x 坐标相减取绝对值，y 坐标相减取绝对值，再加和。<br>从公式定义上看，曼哈顿距离一定是一个非负数，距离最小的情况就是两个点重合，距离为 0，这一点和欧氏距离一样。<br>曼哈顿距离和欧氏距离的意义相近，也是为了描述两个点之间的距离，不同的是曼哈顿距离只需要做加减法，这使得计算机在大量的计算过程中代价更低，而且会消除在开平方过程中取近似值而带来的误差。不仅如此，曼哈顿距离在人脱离计算机做计算的时候也会很方便。</p>              </div>            </details><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NearestNeighbor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;X is N x D where each row is an example.</span></span><br><span class="line"><span class="string">        Y is l-dimension of size N&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;X is N x D where each row is an example we wish to predict label for&quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        Ypred = np.zeros(num_test, dtype=self.ytr.dtype)</span><br><span class="line">        distances = np.zeros((X.shape[<span class="number">0</span>], self.Xtr.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># loop over all test rows</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> np.xrange(num_test):</span><br><span class="line">            <span class="comment"># find the nearest training image to the i&#x27;th test image</span></span><br><span class="line">            <span class="comment"># using the L1 distance (sum of absolute value differences)</span></span><br><span class="line">            distances[i] = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i, :]), axis=<span class="number">1</span>)</span><br><span class="line">            min_index = np.argmin(distances[i])  <span class="comment"># get the index with the smallest distance</span></span><br><span class="line">            Ypred[i] = self.ytr[min_index]  <span class="comment"># predict the label of the nearest example</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure><blockquote><p>为什么distance是二维的：<br>对于测试样本集中的每个测试样本 X[i, :]，我们计算它与训练样本集中的每个训练样本 self.Xtr[j, :] 之间的 L1 距离，并存储在 distances[i] 中。由于有多个测试样本，所以需要一个矩阵来存储这些距离。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8l01nbuxa8.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8l01nbuxa8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;k-Nearest-Neighbors分类算法&quot;&gt;&lt;a href=&quot;#k-Nearest-Neighbors分类算法&quot; class=&quot;headerlink&quot; title=&quot;k-Nearest Neighbors分类算法&quot;&gt;&lt;/a&gt;k-Nearest Neighbo</summary>
      
    
    
    
    <category term="AI" scheme="http://tumytime.github.io/categories/AI/"/>
    
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>windows查看当前目录下文件夹大小的命令</title>
    <link href="http://tumytime.github.io/2024/09/16/windows%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://tumytime.github.io/2024/09/16/windows%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-16T03:34:56.000Z</published>
    <updated>2024-09-16T03:55:55.239Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>D盘突然爆红，我还以为是我环境下多了，最后发现是steam删游戏是假删。。。。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-Directory</span> | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">    <span class="variable">$sizeInBytes</span> = (<span class="built_in">Get-ChildItem</span><span class="variable">$_</span>.FullName <span class="literal">-Recurse</span> | <span class="built_in">Measure-Object</span> <span class="literal">-Property</span> Length <span class="literal">-Sum</span>).Sum</span><br><span class="line">    <span class="variable">$sizeInGB</span> =<span class="variable">$sizeInBytes</span> / <span class="number">1</span>GB</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$sizeInGB</span> <span class="operator">-gt</span> <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable">$_</span>.FullName + <span class="string">&quot; &quot;</span> +<span class="variable">$sizeInGB</span>.ToString(<span class="string">&quot;F2&quot;</span>) + <span class="string">&quot; GB&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;D盘突然爆红，我还以为是我环境下多了，最后发现是steam删游戏是假删。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="windows" scheme="http://tumytime.github.io/categories/windows/"/>
    
    
    <category term="windows" scheme="http://tumytime.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师（二）校验码</title>
    <link href="http://tumytime.github.io/2024/09/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <id>http://tumytime.github.io/2024/09/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%A1%E9%AA%8C%E7%A0%81/</id>
    <published>2024-09-16T02:31:56.000Z</published>
    <updated>2024-09-16T03:55:51.676Z</updated>
    
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>9-12月中旬（六级结束）任务整理</title>
    <link href="http://tumytime.github.io/2024/09/16/%E4%BB%BB%E5%8A%A1%E6%95%B4%E7%90%86/"/>
    <id>http://tumytime.github.io/2024/09/16/%E4%BB%BB%E5%8A%A1%E6%95%B4%E7%90%86/</id>
    <published>2024-09-15T16:13:39.000Z</published>
    <updated>2024-09-19T12:13:52.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软考-2024-11-9"><a href="#软考-2024-11-9" class="headerlink" title="软考[2024.11.9]"></a>软考[2024.11.9]</h2><blockquote><p>打算一些重要部分如计网、计组等直接学成套的课，不重要的就听软考的课</p></blockquote><blockquote><p>考试内容大概如下:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></blockquote><ol><li>计算机组成原理 <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=995248168&bvid=BV1ps4y1d73V&cid=1106436941&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><blockquote><p>33h</p></blockquote></li></ol><h2 id="六级-2024-12-14"><a href="#六级-2024-12-14" class="headerlink" title="六级[2024.12.14]"></a>六级[2024.12.14]</h2><blockquote><p>买了14套真题刷一刷算了</p></blockquote><h2 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h2><blockquote><p>上课好好听，尽量都在课堂上解决<br>下课好好写作业</p></blockquote><blockquote><p>真的不想在期末前连续通宵了。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软考-2024-11-9&quot;&gt;&lt;a href=&quot;#软考-2024-11-9&quot; class=&quot;headerlink&quot; title=&quot;软考[2024.11.9]&quot;&gt;&lt;/a&gt;软考[2024.11.9]&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;打算一些重要部分如计网、计组等</summary>
      
    
    
    
    <category term="任务整理" scheme="http://tumytime.github.io/categories/%E4%BB%BB%E5%8A%A1%E6%95%B4%E7%90%86/"/>
    
    
    <category term="任务整理" scheme="http://tumytime.github.io/tags/%E4%BB%BB%E5%8A%A1%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【Jetson Nano学习笔记】oled屏显示ip地址等信息</title>
    <link href="http://tumytime.github.io/2024/09/15/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91oled%E5%B1%8F%E6%98%BE%E7%A4%BAip%E5%9C%B0%E5%9D%80%E7%AD%89%E4%BF%A1%E6%81%AF/"/>
    <id>http://tumytime.github.io/2024/09/15/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91oled%E5%B1%8F%E6%98%BE%E7%A4%BAip%E5%9C%B0%E5%9D%80%E7%AD%89%E4%BF%A1%E6%81%AF/</id>
    <published>2024-09-15T11:46:22.000Z</published>
    <updated>2024-09-16T06:59:24.113Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是一个详细得感人的教程:</strong></p><div class="tagLink"><a class="link-card" title="Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）" href="https://cloud.tencent.com/developer/article/2029907"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）</p><p class="url">https://cloud.tencent.com/developer/article/2029907</p></div></a></div><div class="tagLink"><a class="link-card" title="jetson nano开启VNC" href="https://blog.csdn.net/weixin_43181350/article/details/106491056"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">jetson nano开启VNC</p><p class="url">https://blog.csdn.net/weixin_43181350/article/details/106491056</p></div></a></div><h2 id="oled屏的示例文件"><a href="#oled屏的示例文件" class="headerlink" title="oled屏的示例文件"></a>oled屏的示例文件</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> Adafruit_SSD1306 <span class="keyword">as</span> SSD</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># V1.0.6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yahboom_OLED</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, i2c_bus=<span class="string">&quot;auto&quot;</span>, clear=<span class="literal">False</span>, debug=<span class="literal">False</span></span>):</span><br><span class="line">        self.__debug = debug</span><br><span class="line">        self.__clear = clear</span><br><span class="line">        self.__clear_count = <span class="number">0</span></span><br><span class="line">        self.__top = -<span class="number">2</span></span><br><span class="line">        self.__x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.__BUS_LIST = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">        self.__bus_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i2c_bus != <span class="string">&quot;auto&quot;</span>:</span><br><span class="line">            self.__i2c_bus = <span class="built_in">int</span>(i2c_bus)</span><br><span class="line">            self.__bus_index = <span class="number">0xFF</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__i2c_bus = self.__BUS_LIST[self.__bus_index]</span><br><span class="line">        </span><br><span class="line">        self.__total_last = <span class="number">0</span></span><br><span class="line">        self.__idle_last = <span class="number">0</span></span><br><span class="line">        self.__str_CPU = <span class="string">&quot;CPU:0%&quot;</span></span><br><span class="line"></span><br><span class="line">        self.__WIDTH = <span class="number">128</span></span><br><span class="line">        self.__HEIGHT = <span class="number">32</span></span><br><span class="line">        self.__image = Image.new(<span class="string">&#x27;1&#x27;</span>, (self.__WIDTH, self.__HEIGHT))</span><br><span class="line">        self.__draw = ImageDraw.Draw(self.__image)</span><br><span class="line">        self.__font = ImageFont.load_default()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__debug:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;---OLED-DEL---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化OLED，成功返回:True，失败返回:False</span></span><br><span class="line">    <span class="comment"># Initialize OLED, return True on success, False on failure</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.__oled = SSD.SSD1306_128_32(</span><br><span class="line">                rst=<span class="literal">None</span>, i2c_bus=self.__i2c_bus, gpio=<span class="number">1</span>)</span><br><span class="line">            self.__oled.begin()</span><br><span class="line">            self.__oled.clear()</span><br><span class="line">            self.__oled.display()</span><br><span class="line">            <span class="keyword">if</span> self.__debug:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;---OLED begin ok!---&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__debug:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;---OLED No Found!---:&quot;</span>, self.__BUS_LIST[self.__bus_index])</span><br><span class="line">            <span class="keyword">if</span> self.__bus_index == <span class="number">0xFF</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            max_bus = <span class="built_in">len</span>(self.__BUS_LIST)</span><br><span class="line">            self.__bus_index = (self.__bus_index + <span class="number">1</span>) % max_bus</span><br><span class="line">            self.__i2c_bus = self.__BUS_LIST[self.__bus_index]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除显示。refresh=True立即刷新，refresh=False不刷新。</span></span><br><span class="line">    <span class="comment"># Clear the display.  Refresh =True Refresh immediately, refresh=False refresh not</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self, refresh=<span class="literal">False</span></span>):</span><br><span class="line">        self.__draw.rectangle(</span><br><span class="line">            (<span class="number">0</span>, <span class="number">0</span>, self.__WIDTH, self.__HEIGHT), outline=<span class="number">0</span>, fill=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> refresh:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.refresh()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增加字符。start_x start_y表示开始的点。text是要增加的字符。</span></span><br><span class="line">    <span class="comment"># refresh=True立即刷新，refresh=False不刷新。</span></span><br><span class="line">    <span class="comment"># Add characters.  Start_x Start_y indicates the starting point.  Text is the character to be added</span></span><br><span class="line">    <span class="comment"># Refresh =True Refresh immediately, refresh=False refresh not</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_text</span>(<span class="params">self, start_x, start_y, text, refresh=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="keyword">if</span> start_x &gt; self.__WIDTH <span class="keyword">or</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt; self.__HEIGHT:</span><br><span class="line">            <span class="keyword">if</span> self.__debug:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;oled text: x, y input error!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = <span class="built_in">int</span>(start_x + self.__x)</span><br><span class="line">        y = <span class="built_in">int</span>(start_y + self.__top)</span><br><span class="line">        self.__draw.text((x, y), <span class="built_in">str</span>(text), font=self.__font, fill=<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">if</span> refresh:</span><br><span class="line">            self.refresh()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入一行字符text。refresh=True立即刷新，refresh=False不刷新。</span></span><br><span class="line">    <span class="comment"># line=[1, 4]</span></span><br><span class="line">    <span class="comment"># Write a line of character text.  Refresh =True Refresh immediately, refresh=False refresh not.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_line</span>(<span class="params">self, text, line=<span class="number">1</span>, refresh=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="keyword">if</span> line &lt; <span class="number">1</span> <span class="keyword">or</span> line &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__debug:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;oled line input error!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        y = <span class="built_in">int</span>(<span class="number">8</span> * (line - <span class="number">1</span>))</span><br><span class="line">        self.add_text(<span class="number">0</span>, y, text, refresh)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 刷新OLED，显示内容</span></span><br><span class="line">    <span class="comment"># Refresh the OLED to display the content</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">refresh</span>(<span class="params">self</span>):</span><br><span class="line">        self.__oled.image(self.__image)</span><br><span class="line">        self.__oled.display()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取CPU占用率</span></span><br><span class="line">    <span class="comment"># Read the CPU usage rate</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCPULoadRate</span>(<span class="params">self, index</span>):</span><br><span class="line">        count = <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            f1 = os.popen(<span class="string">&quot;cat /proc/stat&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            stat1 = f1.readline()</span><br><span class="line">            data_1 = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                data_1.append(<span class="built_in">int</span>(stat1.split(<span class="string">&#x27; &#x27;</span>)[i+<span class="number">2</span>]))</span><br><span class="line">            self.__total_last = data_1[<span class="number">0</span>]+data_1[<span class="number">1</span>]+data_1[<span class="number">2</span>]+data_1[<span class="number">3</span>] + \</span><br><span class="line">                data_1[<span class="number">4</span>]+data_1[<span class="number">5</span>]+data_1[<span class="number">6</span>]+data_1[<span class="number">7</span>]+data_1[<span class="number">8</span>]+data_1[<span class="number">9</span>]</span><br><span class="line">            self.__idle_last = data_1[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">4</span>:</span><br><span class="line">            f2 = os.popen(<span class="string">&quot;cat /proc/stat&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            stat2 = f2.readline()</span><br><span class="line">            data_2 = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                data_2.append(<span class="built_in">int</span>(stat2.split(<span class="string">&#x27; &#x27;</span>)[i+<span class="number">2</span>]))</span><br><span class="line">            total_now = data_2[<span class="number">0</span>]+data_2[<span class="number">1</span>]+data_2[<span class="number">2</span>]+data_2[<span class="number">3</span>] + \</span><br><span class="line">                data_2[<span class="number">4</span>]+data_2[<span class="number">5</span>]+data_2[<span class="number">6</span>]+data_2[<span class="number">7</span>]+data_2[<span class="number">8</span>]+data_2[<span class="number">9</span>]</span><br><span class="line">            idle_now = data_2[<span class="number">3</span>]</span><br><span class="line">            total = <span class="built_in">int</span>(total_now - self.__total_last)</span><br><span class="line">            idle = <span class="built_in">int</span>(idle_now - self.__idle_last)</span><br><span class="line">            usage = <span class="built_in">int</span>(total - idle)</span><br><span class="line">            usageRate = <span class="built_in">int</span>(<span class="built_in">float</span>(usage / total) * <span class="number">100</span>)</span><br><span class="line">            self.__str_CPU = <span class="string">&quot;CPU:&quot;</span> + <span class="built_in">str</span>(usageRate) + <span class="string">&quot;%&quot;</span></span><br><span class="line">            self.__total_last = <span class="number">0</span></span><br><span class="line">            self.__idle_last = <span class="number">0</span></span><br><span class="line">            <span class="comment"># if self.__debug:</span></span><br><span class="line">            <span class="comment">#     print(self.__str_CPU)</span></span><br><span class="line">        <span class="keyword">return</span> self.__str_CPU</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取系统时间</span></span><br><span class="line">    <span class="comment"># Read system time</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSystemTime</span>(<span class="params">self</span>):</span><br><span class="line">        cmd = <span class="string">&quot;date +%H:%M:%S&quot;</span></span><br><span class="line">        date_time = subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        str_Time = <span class="built_in">str</span>(date_time).lstrip(<span class="string">&#x27;b\&#x27;&#x27;</span>)</span><br><span class="line">        str_Time = str_Time.rstrip(<span class="string">&#x27;\\n\&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(date_time)</span></span><br><span class="line">        <span class="keyword">return</span> str_Time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取内存占用率 和 总内存</span></span><br><span class="line">    <span class="comment"># Read the memory usage and total memory</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getUsagedRAM</span>(<span class="params">self</span>):</span><br><span class="line">        cmd = <span class="string">&quot;free | awk &#x27;NR==2&#123;printf \&quot;RAM:%2d%% -&gt; %.1fGB \&quot;, 100*($2-$7)/$2, ($2/1048576.0)&#125;&#x27;&quot;</span></span><br><span class="line">        FreeRam = subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        str_FreeRam = <span class="built_in">str</span>(FreeRam).lstrip(<span class="string">&#x27;b\&#x27;&#x27;</span>)</span><br><span class="line">        str_FreeRam = str_FreeRam.rstrip(<span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str_FreeRam</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取空闲的内存 / 总内存</span></span><br><span class="line">    <span class="comment"># Read free memory/total memory</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFreeRAM</span>(<span class="params">self</span>):</span><br><span class="line">        cmd = <span class="string">&quot;free -h | awk &#x27;NR==2&#123;printf \&quot;RAM: %.1f/%.1fGB \&quot;, $7,$2&#125;&#x27;&quot;</span></span><br><span class="line">        FreeRam = subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        str_FreeRam = <span class="built_in">str</span>(FreeRam).lstrip(<span class="string">&#x27;b\&#x27;&#x27;</span>)</span><br><span class="line">        str_FreeRam = str_FreeRam.rstrip(<span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str_FreeRam</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取TF卡空间占用率 / TF卡总空间</span></span><br><span class="line">    <span class="comment"># Read the TF card space usage/TOTAL TF card space</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getUsagedDisk</span>(<span class="params">self</span>):</span><br><span class="line">        cmd = <span class="string">&quot;df -h | awk &#x27;$NF==\&quot;/\&quot;&#123;printf \&quot;SDC:%s -&gt; %.1fGB\&quot;, $5, $2&#125;&#x27;&quot;</span></span><br><span class="line">        Disk = subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        str_Disk = <span class="built_in">str</span>(Disk).lstrip(<span class="string">&#x27;b\&#x27;&#x27;</span>)</span><br><span class="line">        str_Disk = str_Disk.rstrip(<span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str_Disk</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取空闲的TF卡空间 / TF卡总空间</span></span><br><span class="line">    <span class="comment"># Read the free TF card space/total TF card space</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFreeDisk</span>(<span class="params">self</span>):</span><br><span class="line">        cmd = <span class="string">&quot;df -h | awk &#x27;$NF==\&quot;/\&quot;&#123;printf \&quot;Disk:%.1f/%.1fGB\&quot;, $4,$2&#125;&#x27;&quot;</span></span><br><span class="line">        Disk = subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        str_Disk = <span class="built_in">str</span>(Disk).lstrip(<span class="string">&#x27;b\&#x27;&#x27;</span>)</span><br><span class="line">        str_Disk = str_Disk.rstrip(<span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str_Disk</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本机IP</span></span><br><span class="line">    <span class="comment"># Read the local IP address</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLocalIP</span>(<span class="params">self</span>):</span><br><span class="line">        ip = os.popen(</span><br><span class="line">            <span class="string">&quot;/sbin/ifconfig eth0 | grep &#x27;inet&#x27; | awk &#x27;&#123;print $2&#125;&#x27;&quot;</span>).read()</span><br><span class="line">        ip = ip[<span class="number">0</span>: ip.find(<span class="string">&#x27;\n&#x27;</span>)]</span><br><span class="line">        <span class="comment"># ip = &#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(ip == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="built_in">len</span>(ip) &gt; <span class="number">15</span>):</span><br><span class="line">            ip = os.popen(</span><br><span class="line">                <span class="string">&quot;/sbin/ifconfig wlan0 | grep &#x27;inet&#x27; | awk &#x27;&#123;print $2&#125;&#x27;&quot;</span>).read()</span><br><span class="line">            ip = ip[<span class="number">0</span>: ip.find(<span class="string">&#x27;\n&#x27;</span>)]</span><br><span class="line">            <span class="keyword">if</span>(ip == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">                ip = <span class="string">&#x27;x.x.x.x&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ip) &gt; <span class="number">15</span>:</span><br><span class="line">            ip = <span class="string">&#x27;x.x.x.x&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">    <span class="comment"># oled主要运行函数，在while循环里调用，可实现热插拔功能。</span></span><br><span class="line">    <span class="comment"># Oled mainly runs functions that are called in a while loop and can be hot-pluggable</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main_program</span>(<span class="params">self</span>):</span><br><span class="line">        state = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cpu_index = <span class="number">0</span></span><br><span class="line">            state = self.begin()</span><br><span class="line">            <span class="keyword">while</span> state:</span><br><span class="line">                self.clear()</span><br><span class="line">                <span class="keyword">if</span> self.__clear:</span><br><span class="line">                    self.refresh()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                str_CPU = self.getCPULoadRate(cpu_index)</span><br><span class="line">                str_Time = self.getSystemTime()</span><br><span class="line">                <span class="keyword">if</span> cpu_index == <span class="number">0</span>:</span><br><span class="line">                    str_FreeRAM = self.getUsagedRAM()</span><br><span class="line">                    str_Disk = self.getUsagedDisk()</span><br><span class="line">                    str_IP = <span class="string">&quot;IPA:&quot;</span> + self.getLocalIP()</span><br><span class="line">                self.add_text(<span class="number">0</span>, <span class="number">0</span>, str_CPU)</span><br><span class="line">                self.add_text(<span class="number">50</span>, <span class="number">0</span>, str_Time)</span><br><span class="line">                self.add_line(str_FreeRAM, <span class="number">2</span>)</span><br><span class="line">                self.add_line(str_Disk, <span class="number">3</span>)</span><br><span class="line">                self.add_line(str_IP, <span class="number">4</span>)</span><br><span class="line">                <span class="comment"># Display image.</span></span><br><span class="line">                self.refresh()</span><br><span class="line">                cpu_index = cpu_index + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cpu_index &gt;= <span class="number">5</span>:</span><br><span class="line">                    cpu_index = <span class="number">0</span></span><br><span class="line">                time.sleep(<span class="number">.1</span>)</span><br><span class="line">            <span class="keyword">if</span> self.__clear:</span><br><span class="line">                self.__clear_count = self.__clear_count + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.__clear_count &gt; <span class="built_in">len</span>(self.__BUS_LIST):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__debug:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;!!!---OLED refresh error---!!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        oled_clear = <span class="literal">False</span></span><br><span class="line">        oled_debug = <span class="literal">False</span></span><br><span class="line">        state = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(arg) == <span class="string">&quot;clear&quot;</span>:</span><br><span class="line">                oled_clear = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(arg) == <span class="string">&quot;debug&quot;</span>:</span><br><span class="line">                oled_debug = <span class="literal">True</span></span><br><span class="line">        oled = Yahboom_OLED(clear=oled_clear, debug=oled_debug)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            state = oled.main_program()</span><br><span class="line">            <span class="keyword">if</span> state:</span><br><span class="line">                <span class="keyword">del</span> oled</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;---OLED CLEARED!---&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        oled.clear(<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">del</span> oled</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---Program closed!---&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;这是一个详细得感人的教程:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）&quot; href=&quot;htt</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/tags/Jetson-Nano/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师（一）数据的表示</title>
    <link href="http://tumytime.github.io/2024/09/08/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://tumytime.github.io/2024/09/08/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2024-09-08T08:45:54.000Z</published>
    <updated>2024-09-08T10:57:35.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>在计算机科学和信息技术中，二进制、十进制和十六进制都是常用的数制系统，它们各自在计算机中扮演着重要的角色。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><strong>应用：</strong></p><ol><li><strong>数据存储与处理</strong>：计算机的基本工作单位是位（bit），每个位只能是0或1，这就是二进制。所有的数据，包括文本、图片、视频等，在计算机内部都是以二进制的形式存储的。</li><li><strong>逻辑运算</strong>：计算机的CPU进行逻辑运算，如与（AND）、或（OR）、非（NOT）等，都是基于二进制的。</li><li><strong>指令编码</strong>：计算机指令集也是以二进制编码的形式存在，CPU根据这些编码来执行相应的操作。<br><strong>特点：</strong></li></ol><ul><li>简单性：二进制只有两个状态，易于物理实现（例如，通过电路的开关状态）。</li><li>易于逻辑运算：二进制与逻辑代数紧密相关，便于实现逻辑电路。</li></ul><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p><strong>应用：</strong></p><ol><li><strong>用户界面</strong>：虽然计算机内部使用二进制，但用户与计算机交互时通常使用十进制，因为它更符合人类的日常习惯。</li><li><strong>数据表示</strong>：在表示大量数据时，例如文件大小、内存容量等，通常使用十进制，因为它更容易被用户理解。</li><li><strong>程序设计</strong>：在高级编程语言中，十进制常用于表示整型常量、循环计数等。<br><strong>特点：</strong></li></ol><ul><li>符合人类习惯：十进制基于10的幂次，与人类使用的计数系统相同。</li><li>易于阅读和书写：十进制数的每一位的权重是明确且固定的。</li></ul><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p><strong>应用：</strong></p><ol><li><strong>内存地址表示</strong>：在编程中，内存地址常常用十六进制表示，因为它可以更紧凑地表示较大的数值。</li><li><strong>颜色编码</strong>：在网页设计和图形编程中，颜色值经常使用十六进制表示，例如#FFFFFF代表白色。</li><li><strong>数据校验</strong>：在数据通信和存储中，校验和（如CRC）有时使用十六进制表示，便于阅读和校验。<br><strong>特点：</strong></li></ol><ul><li>紧凑性：十六进制使用数字0-9和字母A-F，可以比二进制更紧凑地表示相同的值。</li><li>与二进制的紧密关系：十六进制的一个数字恰好对应二进制的四个位（一个半字节），这使得它成为表示二进制数据的有效方式。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>二进制</strong>是计算机硬件处理数据的基础。</li><li><strong>十进制</strong>是用户与计算机交互时的主要数制。</li><li><strong>十六进制</strong>则作为二进制和十进制之间的桥梁，在需要紧凑表示大量数据时非常有用。<br>这三种数制在计算机中的应用是相辅相成的，各自适用于不同的场景和目的。</li></ul><table><thead><tr><th>进制</th><th>数码</th><th>基数</th><th>位权</th></tr></thead><tbody><tr><td>十进制(D)</td><td>0，1，2，3，4，5，6，7，8，9</td><td>10</td><td>$10^k$</td></tr><tr><td>二进制(B)</td><td>0，1</td><td>2</td><td>$2^k$</td></tr><tr><td>十六进制(H)</td><td>0~9，A,B,C,D,E,F</td><td>16</td><td>$16^k$</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h2&gt;&lt;p&gt;在计算机科学和信息技术中，二进制、十进制和十六进制都是常用的数制系统，它们各自在计算机中扮演着重要的角色。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL环境配置</title>
    <link href="http://tumytime.github.io/2024/09/07/OpenGL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://tumytime.github.io/2024/09/07/OpenGL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-09-07T15:13:29.000Z</published>
    <updated>2024-09-07T15:25:24.858Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="OpenGL开发必过的坎------开发环境的准备(Windows10)" href="https://blog.csdn.net/zxj2589/article/details/130467844?ops_request_misc=&request_id=&biz_id=102&utm_term=opengl%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-130467844.142^v100^pc_search_result_base2&spm=1018.2226.3001.4187"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">OpenGL开发必过的坎------开发环境的准备(Windows10)</p><p class="url">https://blog.csdn.net/zxj2589/article/details/130467844?ops_request_misc=&request_id=&biz_id=102&utm_term=opengl%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-130467844.142^v100^pc_search_result_base2&spm=1018.2226.3001.4187</p></div></a></div><blockquote><p>glut只能在x86下运行，如果要用的话记得开x86，并把别的库也改成32位的</p></blockquote><blockquote><p>想用x64的话可以用freeglut库，支持x64，和glut功能基本一样</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;OpenGL开发必过的坎------开发环境的准备(Windows10)&quot; href=&quot;https://blog.csdn.net/zxj2589/article/details/1</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://tumytime.github.io/categories/OpenGL/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="OpenGL" scheme="http://tumytime.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>科目四</title>
    <link href="http://tumytime.github.io/2024/08/22/%E7%A7%91%E7%9B%AE%E5%9B%9B/"/>
    <id>http://tumytime.github.io/2024/08/22/%E7%A7%91%E7%9B%AE%E5%9B%9B/</id>
    <published>2024-08-22T12:29:00.000Z</published>
    <updated>2024-08-22T16:26:42.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没事哒没事哒我没事哒</p></blockquote><h2 id="仪表指示灯题"><a href="#仪表指示灯题" class="headerlink" title="仪表指示灯题"></a>仪表指示灯题</h2><ol><li><p>水温表时用来指示<strong>发动机</strong>的温度</p></li><li><p>三个向上箭头，后面是矩形-&gt;<strong>后</strong>挡风除雾；后面是扇形-&gt;<strong>前</strong>挡风除雾</p></li></ol><h2 id="危险化学品题"><a href="#危险化学品题" class="headerlink" title="危险化学品题"></a>危险化学品题</h2><ol><li><p>火药、炸药、起爆药属于<strong>爆炸品</strong></p></li><li><p>火柴、硫磺、赤磷属于<strong>易燃固体</strong></p></li><li><p><strong>液体&#x2F;腐蚀品</strong>起火不可都用水</p></li><li><p>有毒气体应站<strong>上风处</strong></p></li><li><p>运载危险化学品应经<strong>公安机关</strong>批准</p></li></ol><h2 id="特殊天气题"><a href="#特殊天气题" class="headerlink" title="特殊天气题"></a>特殊天气题</h2><ol><li><p>能见度低:</p><ul><li>&lt;200m:开启雾灯、近光灯、示廓灯、前后位灯，车速&lt;60km&#x2F;h，车距&gt;100m</li><li>&lt;100m:开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速&lt;40km&#x2F;h，车距&gt;50m</li><li>&lt;50m: 开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速&lt;20km&#x2F;h，并从最近的出口尽快驶离高速公路</li></ul></li><li><p><strong>刚下雨</strong>的路面最容易发生侧滑</p></li><li><p>在冰雪路面上减速或停车，应充分利用发动机的牵制作用</p></li><li><p>冰雪路面不可急转向</p></li><li><p>冰雪路面，但是没下雪&#x2F;雨，不用开雾灯</p></li><li><p>机动车雾天行驶，开雾灯和危险报警闪光灯</p></li><li><p>遇到横风车辆产生偏移时，收油降速，不可紧急制动</p></li><li><p>大风天禁止超车</p></li><li><p>大雨天使用近光灯减速慢行</p></li></ol><h2 id="速度题"><a href="#速度题" class="headerlink" title="速度题"></a>速度题</h2><ol><li><p>高速&gt;60,&lt;120</p></li><li><p>高速两车道：最左侧&gt;100,<br> 高速三车道：&gt;60,&gt;90&gt;110</p></li><li><p>特殊路段&lt;30</p></li></ol><h2 id="标志题"><a href="#标志题" class="headerlink" title="标志题"></a>标志题</h2><p>1. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;没事哒没事哒我没事哒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;仪表指示灯题&quot;&gt;&lt;a href=&quot;#仪表指示灯题&quot; class=&quot;headerlink&quot; title=&quot;仪表指示灯题&quot;&gt;&lt;/a&gt;仪表指示灯题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="驾考" scheme="http://tumytime.github.io/categories/%E9%A9%BE%E8%80%83/"/>
    
    
    <category term="驾考" scheme="http://tumytime.github.io/tags/%E9%A9%BE%E8%80%83/"/>
    
    <category term="科目四" scheme="http://tumytime.github.io/tags/%E7%A7%91%E7%9B%AE%E5%9B%9B/"/>
    
  </entry>
  
  <entry>
    <title>我是一个分界线</title>
    <link href="http://tumytime.github.io/2024/08/13/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%86%E7%95%8C%E7%BA%BF/"/>
    <id>http://tumytime.github.io/2024/08/13/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%86%E7%95%8C%E7%BA%BF/</id>
    <published>2024-08-13T12:24:31.000Z</published>
    <updated>2024-09-07T15:15:20.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这几天一直在学c++，但是学着学着容易没劲，发现我不适合那种跟着课按部就班学东西，还是打算那种给一天干完一个任务的模式</p></blockquote><blockquote><p>或许打算试试软考</p></blockquote><blockquote><p>考试内容大概如下:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这几天一直在学c++，但是学着学着容易没劲，发现我不适合那种跟着课按部就班学东西，还是打算那种给一天干完一个任务的模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;或许打算试试软考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;bl</summary>
      
    
    
    
    <category term="碎碎念" scheme="http://tumytime.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="http://tumytime.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】内存分区模型</title>
    <link href="http://tumytime.github.io/2024/08/12/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
    <id>http://tumytime.github.io/2024/08/12/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-08-11T18:32:47.000Z</published>
    <updated>2024-09-06T10:59:15.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++程序在执行时，将内存大方向划分位4个区域</p><ul><li><strong>代码区:</strong> 存放函数体的二进制代码,由操作系统进行管理的</li><li><strong>全局区:</strong> 存放全局变量和静态变量以及常量</li><li><strong>栈区:</strong> 由编译器自动分配释放,存放函数的参数值,局部变量等</li><li><strong>堆区:</strong> 由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br><strong>意义:</strong> 不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</li></ul></blockquote><h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域:</p><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><blockquote><p>存放CPU执行的机器指令</p></blockquote><ul><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li></ul><h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><blockquote><p>全局变量、静态变量字符串常量和其他常量存放在此</p></blockquote><blockquote><p>该区域的数据在程序结束后由操作系统释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>x64(64位)：</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1zi6igjuin.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1zi6igjuin.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>x86(32位):</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.231sg6ei3g.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.231sg6ei3g.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p><strong>Q:</strong> 为什么当vs管理器为x64(64位)时，a的地址比b小32，但是管理器改为x86(32位)时，a比b地址大12</p></blockquote><ul><li>x64架构（64位）<ol><li><strong>栈对齐</strong>：x64架构通常要求栈对齐到16字节或32字节边界，以优化性能并满足某些指令集的要求。这可能导致在局部变量之间插入额外的填充（padding）。</li><li><strong>调用约定</strong>：在x64架构下，函数调用时可能需要在栈上保留更多的空间用于寄存器保存区域（callee-saved registers）和其他目的。这可能导致局部变量之间的地址差异大于它们的大小。</li><li><strong>优化</strong>：编译器可能会在64位模式下执行更积极的优化，这可能会影响变量的布局。</li><li><strong>局部变量大小</strong>：即使局部变量是<code>int</code>类型，它们在栈上的布局也可能会受到其他因素的影响，如调用约定、栈对齐等。</li></ol></li></ul><p>在x64架构下，32字节的差异可能是由于编译器在<code>a</code>和<code>b</code>之间插入了对齐填充，或者由于其他局部变量或保留空间的布局。</p><ul><li>x86架构（32位）<ol><li><strong>栈对齐</strong>：x86架构通常要求栈对齐到4字节边界，这意味着局部变量之间的地址差异通常是它们大小的整数倍。</li><li><strong>调用约定</strong>：在x86架构下，函数调用时在栈上保留的空间通常比x64架构少，因此局部变量之间的地址差异可能更小。</li><li><strong>优化</strong>：编译器在32位模式下的优化可能与64位模式不同，这可能会影响变量的布局。<br>  在x86架构下，12字节的差异可能是因为：<ul><li>在<code>a</code>和<code>b</code>之间可能有其他局部变量或对齐填充。</li><li>编译器可能为了保持栈对齐而插入填充。</li><li>由于某些优化，编译器可能改变了局部变量的顺序或布局。</li></ul></li></ol></li></ul><h2 id="程序运行前-1"><a href="#程序运行前-1" class="headerlink" title="程序运行前"></a>程序运行前</h2><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C++程序在执行时，将内存大方向划分位4个区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码区:&lt;/strong&gt; 存放函数体的二进制代码,由操作系统进行管理的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局区:&lt;/strong&gt; 存放全局变量和静态变量</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】结构体</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2024-08-10T14:49:53.000Z</published>
    <updated>2024-08-11T18:32:07.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>发现个好东西，试一下子</p></blockquote><p><a href="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~"><img src="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~" class="lazyload placeholder" data-srcset="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p></blockquote><h2 id="创建结构体变量"><a href="#创建结构体变量" class="headerlink" title="创建结构体变量"></a>创建结构体变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;<span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;<span class="comment">//分数</span></span><br><span class="line"></span><br><span class="line">&#125;stu3;<span class="comment">//创建方式3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1;<span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu1.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方式2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu2.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu3.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建结构体变量时，关键词struct可以省略</p></blockquote><blockquote><p>结构体变量利用操作符”.”访问成员</p></blockquote><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><strong>作用:</strong> 将自定义的结构体放入到数组中方便维护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student arr[<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p><strong>作用:</strong> 通过指针访问结构体中的成员</p><blockquote><p>利用操作符’-&gt;’可以通过结构体指针访问结构体属性</p></blockquote><p>在C语言中，结构体变量和结构体指针访问成员的方式不同，这是由于它们在内存中的存储和访问机制不同。<br>结构体变量使用<code>.</code>操作符访问成员，因为结构体变量本身就是一个具体的实例，它包含了所有成员的数据。当你使用<code>.</code>操作符时，你直接在结构体实例上访问其成员。<br>例如，如果你有一个名为<code>student</code>的结构体，并且有一个<code>student</code>类型的变量<code>stu</code>，你可以这样访问它的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stu.name);  <span class="comment">// 使用 &#x27;.&#x27; 操作符访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.score);</span><br></pre></td></tr></table></figure><p>而结构体指针使用<code>-&gt;</code>操作符访问成员，因为指针本身并不直接包含结构体的数据，而是存储了结构体数据的内存地址。当你使用<code>-&gt;</code>操作符时，你实际上是在告诉编译器：“请先到这个地址去找到结构体实例，然后再访问它的成员。”<br>例如，如果你有一个指向<code>student</code>结构体的指针<code>ptr</code>，你可以这样访问它的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;  <span class="comment">// ptr 指向 stu 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr-&gt;name);   <span class="comment">// 使用 &#x27;-&gt;&#x27; 操作符访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;score);</span><br></pre></td></tr></table></figure><p>这里，<code>ptr-&gt;name</code>是<code>(*ptr).name</code>的简写形式，它首先通过解引用指针<code>*ptr</code>来获取结构体实例，然后通过<code>.</code>操作符访问其<code>name</code>成员。<br>总结来说，<code>.</code>用于直接访问结构体变量的成员，而<code>-&gt;</code>用于通过结构体指针间接访问其指向的结构体实例的成员。</p><h2 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h2><p><strong>示例:</strong><br>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">student stu;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt; 运算符以便输出 student 结构体</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> student&amp; s) &#123;</span><br><span class="line">os &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数: &quot;</span> &lt;&lt; s.score;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">student stu1 = &#123; <span class="string">&quot;时域&quot;</span>,<span class="number">19</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">teacher tea1 = &#123; <span class="string">&quot;余新晨&quot;</span>,<span class="number">20</span>,stu1 &#125;;</span><br><span class="line"></span><br><span class="line">teacher* p = &amp;tea1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot;学生:&quot;</span> &lt;&lt; p-&gt;stu &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>在C++中，运算符重载是一种功能，它允许你为类或结构体定义现有运算符的新行为。通过重载运算符，你可以使它们与用户定义的类型一起工作，就像它们与内置类型一起工作一样。下面是对<code>operator&lt;&lt;</code>重载函数的详细解释：</p><h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> student&amp; s)</span><br></pre></td></tr></table></figure><p>这里，<code>operator&lt;&lt;</code>是正在被重载的运算符，它用于输出（插入）数据到输出流中（比如标准输出<code>cout</code>）。函数接受两个参数：</p><ol><li><code>ostream&amp; os</code>：这是一个引用到输出流的引用，通常是一个<code>std::ostream</code>类型的对象，比如<code>std::cout</code>。使用引用是因为我们不想复制整个流对象，只是想在原对象上操作。</li><li><code>const student&amp; s</code>：这是一个对<code>student</code>结构体的常量引用。我们使用常量引用是因为我们不想修改传入的结构体，并且引用可以避免不必要的复制。</li></ol><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数: &quot;</span> &lt;&lt; s.score;</span><br></pre></td></tr></table></figure><p>在函数体内部，我们使用了<code>&lt;&lt;</code>运算符来将结构体<code>student</code>的成员依次输出到传入的输出流<code>os</code>中。以下是步骤：</p><ol><li><code>os &lt;&lt; &quot;姓名: &quot;</code>：将字符串”姓名: “输出到输出流<code>os</code>。</li><li><code>&lt;&lt; s.name</code>：输出<code>student</code>结构体的<code>name</code>成员。</li><li><code>&lt;&lt; &quot; 年龄: &quot;</code>：输出字符串” 年龄: “。</li><li><code>&lt;&lt; s.age</code>：输出<code>student</code>结构体的<code>age</code>成员。</li><li><code>&lt;&lt; &quot; 分数: &quot;</code>：输出字符串” 分数: “。</li><li><code>&lt;&lt; s.score</code>：输出<code>student</code>结构体的<code>score</code>成员。</li></ol><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> os;</span><br></pre></td></tr></table></figure><p>函数返回一个<code>ostream</code>对象的引用。这是为了允许链式调用，也就是说，你可以连续使用多个<code>&lt;&lt;</code>运算符，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;教师姓名: &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 学生信息: &quot;</span> &lt;&lt; p-&gt;stu &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在这里，每次调用<code>&lt;&lt;</code>运算符后返回的<code>ostream</code>引用都用于下一次调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重载<code>operator&lt;&lt;</code>允许你以自然的方式将<code>student</code>结构体对象输出到标准输出或其他输出流中，而无需单独输出每个成员。这样可以使代码更加简洁，可读性更强。通过返回<code>ostream</code>引用，你还可以继续将其他内容输出到同一个流中。</p><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h2><h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><ol><li>值传递</li><li>地址传递</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu)</span> </span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名:&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student* stu)</span> </span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名:&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">////值传递</span></span><br><span class="line"><span class="comment">//printStudent(stu);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h2 id="结构体中const使用场景"><a href="#结构体中const使用场景" class="headerlink" title="结构体中const使用场景"></a>结构体中const使用场景</h2><p><strong>作用:</strong> 用const来防止误操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;发现个好东西，试一下子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://api.xecades.xyz/api?img=1&amp;bg=26,140,165,0&amp;bilibili=%E6%97%B6%E5%9F%9FTumy&amp;</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】指针</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8C%87%E9%92%88/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8C%87%E9%92%88/</id>
    <published>2024-08-10T13:41:41.000Z</published>
    <updated>2024-08-10T15:18:05.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>野指针我老熟人了。。。。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>作用:</strong> 通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h2 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.指针的定义</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">    p=&amp;a;</span><br><span class="line">    cout&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.指针的使用</span></span><br><span class="line">    <span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针变量和普通变量的区别"><a href="#指针变量和普通变量的区别" class="headerlink" title="指针变量和普通变量的区别"></a>指针变量和普通变量的区别</h2><ul><li>普通变量存放的是数据，指针变量存放的是地址</li><li>指针变量可以通过”*”操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><blockquote><p>用&amp;获取变量的地址</p></blockquote><h2 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h2><blockquote><p><strong>Q:</strong> 指针也是种数据类型，那么这种数据类型占用多少空间呢？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，指针类型的大小取决于所运行的系统架构。通常情况下：</p><ul><li>在32位系统中，指针通常占用4个字节。</li><li>在64位系统中，指针通常占用8个字节。</li></ul></blockquote><h2 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问空指针报错 </span></span><br><span class="line"><span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><blockquote><p><strong>野指针:</strong> 指针变量指向非法的内存空间</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问野指针报错 </span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编写C++程序时，应确保指针指向有效的内存地址。直接将指针指向一个硬编码的地址，而没有确保该地址是有效和安全的，是一种危险的做法。正确的做法是使用动态内存分配（如new关键字）来获取内存，或者确保指针指向已分配的内存区域。</p></blockquote><blockquote><p>空指针和野指针都不是我们申请的空间，因此不要访问</p></blockquote><h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>在C++中，当使用<code>const</code>修饰指针时，它有两种不同的含义，这取决于<code>const</code>的位置：</p><ol><li><strong><code>const</code>位于星号（*）之前</strong>：这表示指针指向的内容是常量，即不能通过这个指针修改所指向的数据。但指针本身可以改变，指向不同的地址。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x;  <span class="comment">// p是指向int常量的指针</span></span><br><span class="line">p = &amp;y;             <span class="comment">// 正确：可以改变p指向的地址</span></span><br><span class="line">*p = <span class="number">30</span>;            <span class="comment">// 错误：不能通过p修改所指向的数据</span></span><br></pre></td></tr></table></figure></li><li><strong><code>const</code>位于星号（*）之后</strong>：这表示指针本身是常量，即不能更改指针的值（它所指向的地址）。但可以通过指针修改它所指向的数据。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;x;  <span class="comment">// p是常量指针</span></span><br><span class="line">*p = <span class="number">30</span>;            <span class="comment">// 正确：可以通过p修改所指向的数据</span></span><br><span class="line">p = &amp;y;             <span class="comment">// 错误：不能更改p的值（它所指向的地址）</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><blockquote><p>利用指针访问数组中元素</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素:&quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素:&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h2><blockquote><p>利用指针作函数参数，可以修改实参的值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h2><blockquote><p><strong>封装一个函数:</strong> 利用冒泡排序，实现对整型数组的升序排序<br>例如数组:int arr[10]&#x3D;{4,3,6,9,1,2,10,8,7,5};</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>当数组名传入到函数作为参数时，被退化为指向首元素的指针</strong><br>在C++中，当你将数组作为参数传递给函数时，它实际上被转换为一个指向数组首元素的指针。这意味着在函数内部，你没有数组的大小信息。因此，在函数内部无法直接计算数组的长度。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;野指针我老熟人了。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;作用:&lt;/st</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】函数</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%87%BD%E6%95%B0/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-10T13:28:11.000Z</published>
    <updated>2024-08-10T13:36:53.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础注意事项"><a href="#基础注意事项" class="headerlink" title="基础注意事项"></a>基础注意事项</h2><p><strong>函数的声明可以多次，但是函数的定义只能有一次</strong></p><h2 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h2><ol><li>创建头文件</li><li>创建函数.cpp文件</li><li>在头文件里写函数的声明</li><li>在.cpp文件里写函数的定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础注意事项&quot;&gt;&lt;a href=&quot;#基础注意事项&quot; class=&quot;headerlink&quot; title=&quot;基础注意事项&quot;&gt;&lt;/a&gt;基础注意事项&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;函数的声明可以多次，但是函数的定义只能有一次&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】数组</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/</id>
    <published>2024-08-10T10:52:50.000Z</published>
    <updated>2024-08-10T13:27:48.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组是一块连续的内存区域，用于存储固定数量的元素</p><ul><li>元素必须是相同的数据类型</li><li>数组的大小在声明时必须是已知的，并且在程序运行期间不可更改。</li></ul><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><ul><li>int a[10];</li><li>int a[2]&#x3D;{1,2};</li><li>int a[]&#x3D;{1,2};</li></ul><p><strong>数组名不能与变量名重名</strong></p><h3 id="数组名用途"><a href="#数组名用途" class="headerlink" title="数组名用途"></a>数组名用途</h3><ol><li><p>统计整个数组在内存中的长度</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//数组名用途</span></span><br><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>获取数组在内存中的首地址</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>数组名是常量，不可以赋值</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="作用：最常用的排序算法，对数组内元素进行排序"><a href="#作用：最常用的排序算法，对数组内元素进行排序" class="headerlink" title="作用：最常用的排序算法，对数组内元素进行排序"></a><strong>作用：</strong>最常用的排序算法，对数组内元素进行排序</h3><ol><li>比较相邻的元素，如果第一个比第二个大，就交换他们两个</li><li>对每一对相邻元素做相同的工作，执行完毕后，找到第一个最大值</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><h3 id="示例：将数组-4，2，8，0，5，7，1，3，9-进行升序排序"><a href="#示例：将数组-4，2，8，0，5，7，1，3，9-进行升序排序" class="headerlink" title="示例：将数组{4，2，8，0，5，7，1，3，9}进行升序排序"></a><strong>示例</strong>：将数组{4，2，8，0，5，7，1，3，9}进行升序排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span><span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])[</span><br><span class="line">                <span class="type">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>建议打个断点一步步观察一下<br><strong>i的每一步都能保证前i个元素里的最大值被放置在i+1的位置上</strong></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p><strong>数据类型 数组名[行数][列数]</strong></p><ol><li>int a[2][3];</li><li>int a[2][3]&#x3D;<br> {<br> {1,2,3},<br> {4,5,6}<br> };</li><li>int a[2][3]&#x3D;{1,2,3,4,5,6};</li><li>int a[][3]&#x3D;{1,2,3,4,5,6};</li></ol><p><strong>在定义二维数组时，如果初始化了数据，可以省略行数</strong></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>二维数组一行大小:</strong><br>sizeod(a[0])</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;数组是一块连续的内存区域，用于存储固定数量的元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素必须是相同的数据类型&lt;/li&gt;
&lt;li&gt;数组的大小在声明时必</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
</feed>
