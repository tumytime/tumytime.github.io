<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello！Welcom to Tumy-Time！</title>
  
  
  <link href="http://tumytime.github.io/atom.xml" rel="self"/>
  
  <link href="http://tumytime.github.io/"/>
  <updated>2024-10-24T12:24:37.000Z</updated>
  <id>http://tumytime.github.io/</id>
  
  <author>
    <name>tumytime</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机概述</title>
    <link href="http://tumytime.github.io/2024/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>http://tumytime.github.io/2024/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</id>
    <published>2024-10-23T12:53:10.000Z</published>
    <updated>2024-10-24T12:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><h3 id="计算机系统硬件基本组成"><a href="#计算机系统硬件基本组成" class="headerlink" title="计算机系统硬件基本组成"></a>计算机系统硬件基本组成</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><h5 id="中央处理器（CPU）—-硬件系统的核心"><a href="#中央处理器（CPU）—-硬件系统的核心" class="headerlink" title="中央处理器（CPU）—&gt;硬件系统的核心"></a>中央处理器（CPU）—&gt;硬件系统的核心</h5><ol><li>运算器</li><li>控制器</li></ol><h5 id="存储器（记忆设备）"><a href="#存储器（记忆设备）" class="headerlink" title="存储器（记忆设备）"></a>存储器（记忆设备）</h5><ol><li><code>内</code>部<code>存</code>储器（速度高，容量小）：<br> 临时存放程序、数据及中间结果<br> 直接与CPU进行数据交换 </li><li><code>外</code>部<code>存</code>储器（速度慢，容量大）：<br> 长期保存程序和数据</li></ol><h5 id="外设（外部设备）"><a href="#外设（外部设备）" class="headerlink" title="外设（外部设备）"></a>外设（外部设备）</h5><ol><li>输入设备：<br> 输入原始数据及各种命令</li><li>输出设备：<br> 输出计算机运行结果</li></ol><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><h3 id="CPU的功能与组成"><a href="#CPU的功能与组成" class="headerlink" title="CPU的功能与组成"></a>CPU的功能与组成</h3><p>中央处理单元（CPU）：<br>    计算机系统的核心部件，他负责获取程序指令，对指令进行译码并加以执行</p><h4 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h4><ol><li>程序控制：<br> 通过执行指令来控制程序的执行顺序</li><li>操作控制：<br> 一条指令功能的实现需要若干个操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作</li><li>时间控制：<br> CPU对各种操作进行时间上的控制，即在指令执行过程中操作信号的出现时间，持续时间即出现的时间顺序都需要进行严格的控制</li><li>数据处理：<br> CPU通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据价格处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务</li><li>CPU还需对系统内部和外部的中断（异常）做出响应，进行相应的处理</li></ol><h4 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h4><ol><li><p><strong>运算器</strong>（是数据加工处理部件，用于完成计算机的各种算术和逻辑运算）：<br> 运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件</p><ul><li>功能：<ul><li>执行所有算术运算，如加、减、乘、除等基本运算及附加运算</li><li>执行所有的逻辑运算并进行逻辑测试，如与、或、非、零值测试或两个值的比较等</li></ul></li><li>组成：<ul><li>算术逻辑单元（ALU）：<br>  负责处理数据，实现对数据的算术运算和逻辑运算</li><li>累加寄存器（AC）：<br>  简称累加器，是一个通用寄存器。暂存算术运算或逻辑运算的中间运算结果</li><li>数据缓冲寄存器（DR）：<br>  暂存指令或数据字或操作数</li><li>状态条件寄存器（PSW）：<br>  保存指令执行后的状态</li></ul></li></ul><blockquote><ol><li><strong>累加寄存器（AC）暂存状态</strong><ul><li><strong>算术运算</strong><ul><li>加法：如3 + 5，先将3放入AC，再加5结果8存回AC，后续运算同理。减法类似。</li><li>逻辑运算：如两数逻辑与，先将一个数放入AC，与第二个数运算结果存回AC。</li></ul></li></ul></li><li><strong>数据缓冲寄存器（DR）暂存状态</strong><ul><li><strong>暂存指令</strong>：从内存读取指令先放DR，再传至指令寄存器。</li><li><strong>暂存数据字或操作数</strong>：从内存读数据用于运算先入DR，再传至相应寄存器。数据字完整暂存至处理。</li></ul></li></ol></blockquote><blockquote><p>状态条件寄存器（PSW）保存指令执行后的状态包括：</p><ol><li><strong>运算结果相关标志</strong><ul><li>进位标志（CF）：算术运算产生进位或借位时置1。</li><li>溢出标志（OF）：运算结果超出数据类型表示范围置1。</li><li>零标志（ZF）：运算结果为0置1。</li></ul></li><li><strong>指令执行状态信息</strong><ul><li>指令执行结果合法性标志：记录指令执行是否合法。</li><li>中断相关标志：记录中断相关信息。</li></ul></li><li><strong>其他状态信息</strong><ul><li>方向标志（DF）：决定字符串操作方向。</li><li>奇偶标志（PF）：反映运算结果中1个数的奇偶性。</li></ul></li></ol></blockquote></li><li><p><strong>控制器</strong></p><ul><li>功能<ul><li>用于控制整个CPU的工作，决定了计算机运行过程的自动化。它不仅要保证程序的正确执行，而且能够处理异常事件</li></ul></li><li>组成<ul><li>指令控制逻辑：<br>  要完成取指令、分析指令和执行指令的操作，其过程分为取指令，指令译码按指令操作码执行，形成下一条指令地址等步骤<ul><li>指令寄存器（IR）：<br>  存放的是从内存中取的指令，就像个中间站一样，不过是存放指令的中间站</li><li>程序计数器（PC）：<br>  存放的是指令的地址，还有技术的功能</li><li>地址寄存器（AR）：<br>  存放的是CPU访问内存单元的地址</li><li>指令译码器（ID）：<br>  是把操作码解析成对应的指令操作</li></ul></li><li>时序控制逻辑：<br>  要为每条指令按时间顺序提供应有的控制信号</li><li>总线控制逻辑：<br>  是为多</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统基础知识&quot;&gt;&lt;a href=&quot;#计算机系统基础知识&quot; class=&quot;headerlink&quot; title=&quot;计算机系统基础知识&quot;&gt;&lt;/a&gt;计算机系统基础知识&lt;/h2&gt;&lt;h3 id=&quot;计算机系统硬件基本组成&quot;&gt;&lt;a href=&quot;#计算机系统硬件基本组成&quot; c</summary>
      
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（五）进程与线程</title>
    <link href="http://tumytime.github.io/2024/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://tumytime.github.io/2024/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-10-19T11:15:24.000Z</published>
    <updated>2024-10-21T11:53:27.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>发现了很好的文章</p></blockquote><div class="tagLink"><a class="link-card" title="一文帮小白搞懂操作系统之内存" href="https://zhuanlan.zhihu.com/p/377858122"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">一文帮小白搞懂操作系统之内存</p><p class="url">https://zhuanlan.zhihu.com/p/377858122</p></div></a></div><div class="tagLink"><a class="link-card" title="进程、线程与协程傻傻分不清？一文带你吃透！" href="https://zhuanlan.zhihu.com/p/381473958"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">进程、线程与协程傻傻分不清？一文带你吃透！</p><p class="url">https://zhuanlan.zhihu.com/p/381473958</p></div></a></div><div class="tagLink"><a class="link-card" title="什么是线程安全？一文带你深入理解" href="https://zhuanlan.zhihu.com/p/385276580"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">什么是线程安全？一文带你深入理解</p><p class="url">https://zhuanlan.zhihu.com/p/385276580</p></div></a></div><div class="tagLink"><a class="link-card" title="从根上理解用户态与内核态" href="https://zhuanlan.zhihu.com/p/388057431"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">从根上理解用户态与内核态</p><p class="url">https://zhuanlan.zhihu.com/p/388057431</p></div></a></div><div class="tagLink"><a class="link-card" title="从根上理解用户态与内核态" href="https://zhuanlan.zhihu.com/p/388057431"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/20240205/9f2685b1e4401ff98ae648edd1cb8866.39vtcqu2gu60.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">从根上理解用户态与内核态</p><p class="url">https://zhuanlan.zhihu.com/p/388057431</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;发现了很好的文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;一文帮小白搞懂操作系统之内存&quot; href=&quot;https://zhuanlan.zhihu.com</summary>
      
    
    
    
    <category term="操作系统" scheme="http://tumytime.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="http://tumytime.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（四）虚拟机</title>
    <link href="http://tumytime.github.io/2024/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://tumytime.github.io/2024/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2024-10-19T08:21:15.000Z</published>
    <updated>2024-10-19T11:14:39.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU-划分时间片"><a href="#CPU-划分时间片" class="headerlink" title="CPU 划分时间片"></a>CPU 划分时间片</h2><p>CPU 划分时间片是一种操作系统进行多任务处理的方式。</p><p>在多任务操作系统中，多个程序或进程可能同时处于就绪状态，等待 CPU 的执行。由于单个 CPU 在一个时刻只能执行一个任务，为了让多个任务看起来像是在同时运行，操作系统采用时间片轮转调度算法。</p><p><strong>一、时间片的概念</strong></p><p>时间片是指 CPU 分配给每个进程或任务的一段固定的执行时间。例如，时间片可以设置为 10 毫秒、50 毫秒等。在每个时间片内，当前正在执行的任务独占 CPU 的资源进行计算和处理。</p><p><strong>二、时间片轮转调度过程</strong></p><ol><li><p>任务分配时间片</p><ul><li>操作系统将所有就绪状态的任务放入一个任务队列中。当 CPU 空闲时，操作系统从任务队列中选择一个任务，并分配给它一个时间片。</li><li>例如，假设有三个任务 A、B 和 C，操作系统首先选择任务 A，并分配给它一个时间片。</li></ul></li><li><p>任务执行</p><ul><li>任务在获得时间片后开始执行。在时间片内，任务可以进行各种计算、访问内存、进行输入&#x2F;输出操作等。</li><li>如果任务在时间片内完成了所有的工作，它可以退出执行，释放 CPU 资源。如果任务在时间片结束时还没有完成，它会被暂停执行，并被放回任务队列的末尾，等待下一次被调度。</li></ul></li><li><p>任务切换</p><ul><li>当一个任务的时间片用完时，操作系统会中断当前任务的执行，并保存其执行状态（如寄存器的值、程序计数器的值等）。然后，操作系统从任务队列中选择下一个任务，并分配给它一个时间片。</li><li>例如，当任务 A 的时间片用完时，操作系统会保存任务 A 的执行状态，并选择任务 B 进行执行。任务 B 开始执行其时间片，如此循环往复。</li></ul></li></ol><p><strong>三、时间片划分的意义</strong></p><ol><li><p>实现多任务并发执行</p><ul><li>通过时间片划分，操作系统可以让多个任务在 CPU 上交替执行，从而实现多任务的并发执行。虽然在任何一个时刻只有一个任务在实际执行，但由于时间片非常短，用户感觉上多个任务是在同时运行的。</li><li>例如，在一个图形用户界面系统中，用户可以同时运行多个应用程序，如浏览器、文本编辑器、音乐播放器等。这些应用程序通过时间片划分在 CPU 上交替执行，用户可以在不同的应用程序之间切换，而感觉不到明显的延迟。</li></ul></li><li><p>提高系统资源利用率</p><ul><li>时间片划分可以充分利用 CPU 的资源，避免某个任务长时间独占 CPU 而导致其他任务无法执行。通过合理地设置时间片大小，可以平衡各个任务的执行时间，提高系统的整体性能和资源利用率。</li><li>例如，如果一个任务需要大量的计算时间，而没有时间片划分，它可能会一直占用 CPU，导致其他任务无法得到执行。而通过时间片划分，即使这个任务需要很长时间才能完成，其他任务也可以在它的时间片用完后得到执行机会，从而提高了系统的资源利用率。</li></ul></li><li><p>保证任务的公平性</p><ul><li>时间片划分可以保证各个任务在 CPU 上得到公平的执行机会。每个任务都有相同的机会获得时间片，并且在时间片用完后会被放回任务队列的末尾，等待下一次被调度。这样可以避免某个任务因为优先级高或其他原因而一直占用 CPU，导致其他任务无法执行。</li><li>例如，在一个多用户系统中，每个用户的任务都应该得到公平的执行机会。通过时间片划分，操作系统可以确保每个用户的任务都能在合理的时间内得到执行，提高系统的公平性和用户体验。</li></ul></li></ol><p>总之，CPU 划分时间片是一种重要的多任务处理方式，它可以实现多任务的并发执行、提高系统资源利用率和保证任务的公平性。操作系统通过合理地设置时间片大小和调度算法，可以优化系统的性能和用户体验。</p><h2 id="第一类虚拟机管理程序不需要检查每一条特权指令的执行"><a href="#第一类虚拟机管理程序不需要检查每一条特权指令的执行" class="headerlink" title="第一类虚拟机管理程序不需要检查每一条特权指令的执行"></a>第一类虚拟机管理程序不需要检查每一条特权指令的执行</h2><p>虚拟机管理程序（Hypervisor）分为两类，其中第一类虚拟机管理程序也被称为裸机虚拟机管理程序（Bare-metal Hypervisor）。</p><p>“第一类虚拟机管理程序不需要检查每一条特权指令的执行”意思如下：</p><p><strong>一、特权指令的概念</strong></p><p>在计算机系统中，特权指令是指那些只能在最高特权级别（例如内核模式）下执行的指令。这些指令通常涉及对关键系统资源的访问和控制，如修改内存保护机制、设置中断向量、访问 I&#x2F;O 设备等。如果普通用户程序执行特权指令，可能会导致系统崩溃或安全漏洞。</p><p><strong>二、传统虚拟机管理方式的问题</strong></p><p>在传统的使用第二类虚拟机管理程序（Hosted Hypervisor，运行在操作系统之上）的情况下，当虚拟机中的操作系统试图执行特权指令时，虚拟机管理程序必须拦截这些指令，并模拟其执行效果。这是因为虚拟机中的操作系统运行在非最高特权级别，不能直接执行特权指令。虚拟机管理程序需要检查每一条可能是特权指令的执行，以确保系统的安全和稳定。</p><p><strong>三、第一类虚拟机管理程序的优势</strong></p><p>而第一类虚拟机管理程序直接运行在硬件之上，它本身就处于最高特权级别。当虚拟机中的操作系统执行指令时，对于非特权指令可以直接在硬件上执行，对于特权指令，由于虚拟机管理程序已经处于最高特权级别，它可以直接将这些指令传递给硬件执行，而不需要像第二类虚拟机管理程序那样逐条检查。</p><p>这样可以减少虚拟机管理程序的开销，提高虚拟机的性能和响应速度。同时，也使得虚拟机的运行更加接近真实的物理机环境，因为特权指令可以直接在硬件上执行，而不需要经过额外的模拟和检查过程。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1hs7hqwsrp.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1hs7hqwsrp.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8ad94a4egn.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8ad94a4egn.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CPU-划分时间片&quot;&gt;&lt;a href=&quot;#CPU-划分时间片&quot; class=&quot;headerlink&quot; title=&quot;CPU 划分时间片&quot;&gt;&lt;/a&gt;CPU 划分时间片&lt;/h2&gt;&lt;p&gt;CPU 划分时间片是一种操作系统进行多任务处理的方式。&lt;/p&gt;
&lt;p&gt;在多任务操作系</summary>
      
    
    
    
    <category term="操作系统" scheme="http://tumytime.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="http://tumytime.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://tumytime.github.io/2024/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://tumytime.github.io/2024/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-10-17T17:36:36.000Z</published>
    <updated>2024-10-17T19:24:16.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><blockquote><p>并发性、共享性、虚拟性和不确定性</p></blockquote><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>实质上是对处理机的执行“时间”进行管理，采用多道程序等技术将CPU的时间合理地分配给每个任务，主要包括进程控制、进程同步、进程通信和进程调度</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>主要包括文件存储空间管理、目录管理、文件的读&#x2F;写管理和存取控制</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>存储管理是对主存储器“空间”进行管理，主要包括存储分配与回收、存储保护、地址映射（变换）和主存扩充</p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>实质是对硬件设备的管理，包括对输入&#x2F;输出设备的分配、启动、完成和回收。</p><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><p>包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等</p><h2 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h2><p>通常，操作系统可分为批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统、微型计算机操作系统和嵌入式操作系统等类型</p><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>一种早期的操作系统，该系统可以提交多个作业，“单道”的含义是指一次只有一个作业装入内存执行。作业由用户程序、数据和作业说明书（作业控制语言）三个部分组成。当一个作业运行结束后，随即自动调入同批的下一个作业，从而节省了作业之间的人工干预时间，提高了资源的利用率。</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>允许多个作业装入内存执行，在任意一个时刻，作业都处于开始点和终止点之间。每当运行中的一个作业由于输入&#x2F;输出操作需要调用外部设备时，就把CPU交给另一个等待运行的作业，从而将主机与外部设备的工作由串行改变为并行，进一步避免了因主机等待外设完成任务而浪费宝贵的CPU时间。<br>多道批处理系统主要有三个特点：多道、宏观上并行运行、微观上串行运行</p><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>在分时操作系统中，一个计算机系统与多个终端设备连接。分时操作系统是将CPU的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。例如，一个带20个终端的分时系统，若每个用户每次分配一个50ms的时间片，则每隔1s即可为所有的用户服务一遍。因此，尽管各个终端上的作业是断续地运行的，但由于操作系统每次对用户程序都能做出及时的响应，因此用户感觉整个系统均归其一人占用</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时是指计算机对于外来信息能够以足够快的速度进行处理，并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高，但要求可靠性有保障。为了提高系统的响应时间，对随机发生的外部事件应及时做出响应并对其进行处理。<br>实时系统分为实时控制系统和实时信息处理系统。实时控制系统主要用于生产过程的自动化控制，例如数据自动采集、武器控制、火炮自动控制等。实时信息处理系统主要用于实时信息处理，例如飞机订票系统、情报检索系统等。实时系统与分时系统除了应用的环境不同，主要有以下三点区别。</p><h2 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h2><p>也称处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。进程管理重点需要研究诸进程之间的并发特性，以及进程之间互相合作与资源竞争产生的问题。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统的特征&quot;&gt;&lt;a href=&quot;#操作系统的特征&quot; class=&quot;headerlink&quot; title=&quot;操作系统的特征&quot;&gt;&lt;/a&gt;操作系统的特征&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;并发性、共享性、虚拟性和不确定性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="http://tumytime.github.io/2024/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>http://tumytime.github.io/2024/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</id>
    <published>2024-10-17T09:52:46.000Z</published>
    <updated>2024-10-17T17:36:23.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><h3 id="计算机系统硬件基本组成"><a href="#计算机系统硬件基本组成" class="headerlink" title="计算机系统硬件基本组成"></a>计算机系统硬件基本组成</h3><blockquote><p>由运算器、控制器、存储器、输入设备和输出设备5大部件组成</p></blockquote><blockquote><p>CPU（中央处理单元）包括运算器、控制器等，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。</p></blockquote><blockquote><p>存储器分为内部存储器和外部存储器。前者速度高、容量小，一般用于临时存放程序、数据及中间结果。而后者容量大、速度慢，可以长期保存程序和数据。</p></blockquote><blockquote><p>输入设备和输出设备合称为外部设备（简称外设），输入设备用于输入原始数据及各种命令，而输出设备则用于输出计算机运行的结果。</p></blockquote><h3 id="（CPU）中央处理单元"><a href="#（CPU）中央处理单元" class="headerlink" title="（CPU）中央处理单元"></a>（CPU）中央处理单元</h3><blockquote><p>CPU是计算机系统的核心部件，它负责获取程序指令、对指令进行译码并加以执行。</p></blockquote><h4 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h4><ol><li>程序控制<br> CPU通过执行指令来控制程序的执行顺序</li><li>操作控制<br> 一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</li><li>时间控制<br> CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制</li><li>数据处理<br> CPU通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务</li><li>对系统内外部的中断（异常）做出响应，进行相应的处理</li></ol><h4 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4jo3g4kqjt.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4jo3g4kqjt.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><blockquote><p>由算术逻辑单元（ALU）、累加寄存器、数据缓冲寄存器和状态条件寄存器等组成，是数据加工处理部件，用于完成计算机的各种算术和逻辑运算</p></blockquote><blockquote><p>相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件</p></blockquote><blockquote><p>主要功能：</p><ul><li>执行所有的算术运算，例如加、减、乘、除等基本运算及附加运算</li><li>执行所有的逻辑运算并进行逻辑测试，例如与、或、非、零值测试或两个值的比较等。</li></ul></blockquote><blockquote><p>各部件功能：</p><ol><li>算术逻辑单元（ALU）：<br>  是运算器的重要组成部件，负责处理数据，实现对数据的算术运算和逻辑运算</li><li>累加寄存器（AC）：<br>  AC通常简称为累加器，它是一个通用寄存器，其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。<br>  例如：<br>  在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。<br>运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器</li><li>数据缓冲寄存器（DR）：<br>  在对内存储器进行读&#x2F;写操作时，用DR暂时存放由内存储器读&#x2F;写的一条指令或一个数据字，将不同时间段内读&#x2F;写的数据隔离开来。<br>  DR的主要作用为：</li></ol><ul><li>作为CPU和内存、外部设备之间数据传送的中转站</li><li>作为CPU和内存、外围设备之间在操作速度上的缓冲</li><li>在单累加器结构的运算器中，数据缓存寄存器还可兼做为操作数寄存器</li></ul><ol start="4"><li>状态条件寄存器（PSW）：<br>  PSW保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，主要分为状态标志和控制标志，例如运算结果进位标志（C）、运算结果溢出标志（V）、运算结果为0标志（Z）、运算结果为负标志（N）、中断标志（I）、方向标志（D）和单步标志等<br>  这些标志通常分别由1位触发器保存，保存了当前指令执行完成之后的状态。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决</li></ol></blockquote><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><blockquote><p>运算器只能完成运算，而控制器用于控制整个CPU的工作，它决定了计算机运行过程的自动化。它不仅要保证程序的正确运行，而且要能处理异常事件。控制器一般包括指令控制逻辑、时序控制逻辑、总线控制逻辑和中断控制逻辑等几个部分。</p></blockquote><blockquote><p>指令控制逻辑要完成取指令、分析指令和执行指令的操作，其过程分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等步骤</p></blockquote><blockquote><p>各部件功能：</p><ol><li>指令寄存器（IR）：<br>  当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能</li><li>程序计数器（PC）：<br>  PC具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分两种情况，一是顺序执行，二是转移执行。在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到</li><li>地址寄存器（AR）：<br>  AR保存当前CPU所访问的内存单元的地址。由于内存和CPU存在着操作速度上的差异，所以需要使用AR保持地址信息，直到内存的读&#x2F;写操作完成位置</li><li>指令译码器（ID）：<br>  指令包含操作码和地址码两部分，为了能执行任何给定的指令，必须对操作码进行分析，以便识别所完成的操作。指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。<br>时序逻辑控制要为每条指令按时间顺序提供应有的控制信号。总线逻辑是为多个功能部件服务的信息通路的控制电路。中断控制逻辑用于控制各种中断请求，并根据优先级的高低对中断请求进行排队，逐个交给CPU处理</li></ol></blockquote><h5 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h5><p>寄存器组可分为专业寄存器和通用寄存器。运算器和控制器中的寄存器是专用寄存器，其作用是固定的。通用寄存器用途广泛并可由程序员规定其用途，其数目因处理器不同有所差异</p><h4 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h4><p>核心又称内核，是CPU最重要的组成部分。CPU中心那块隆起的芯片就是核心，是由单晶硅以一定的生产工艺制造出来的，CPU所有的计算、接收&#x2F;存储命令、处理数据都由核心执行。各种CPU核心都具有固定的逻辑结构，一级缓存、二级缓存、执行单元、指令级单元和总线接口等逻辑单元都会有合理的布局。<br>多核即在一个单芯片上面集成两个甚至更多个处理器内核，其中，每个内核都有自己的逻辑单元、控制单元、中断处理器、运算单元，一级Cache、二级Cache共享或独有，其部件的完整性和单核处理器内核相比完全一致。<br>CPU的主要产商AMD和Intel的双核技术在物理结构上有所不同。AMD将两个内核做在一个Die（晶元）上，通过直连架构连接起来，集成度更高。Intel则是将放在不同核心上的两个内核封装在一起，因此将Intel的方案称为“双芯”，将AMD的方案称为“双核”。从用户端的角度来看，AMD的方案能够使双核CPU的管脚、功耗等指标跟单核CPU保持一致，从单核升级到双核，不需要更换电源、芯片组、散热系统和主板，只需要刷新BIOS软件即可。<br>多核CPU系统最大的有点（也是开发的最主要目的）是可满足用户同时进行多任务处理的要求。<br>单核多线程CPU是交替地转换执行多个任务，只不过交替转换地时间很短，用户一般感觉不出来。如果同时执行的任务太多，就会感觉到“慢”或者“卡”。而多核在理论上则是在任何时间内每个核执行各自的任务，不存在交替问题。因此，单核多线程和多核（一般每核也是多线程的）虽然都可以执行多任务，但多核的速度更快。<br>虽然采用了Intel超线程技术的单核可以视为是双核，4核可以视为是8核。然而，视为是8核比不上实际是8核的CPU性能。<br>要发挥CPU的多核性能，就需要操作系统能够及时、合理地给各个核分配任务和资源（如缓存、总线、内存等），也需要应用软件在运行时可以把并行地线程同时交付给多个核心分别处理。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><h3 id="计算机体系结构的发展"><a href="#计算机体系结构的发展" class="headerlink" title="计算机体系结构的发展"></a>计算机体系结构的发展</h3><h4 id="计算机体系结构分类"><a href="#计算机体系结构分类" class="headerlink" title="计算机体系结构分类"></a>计算机体系结构分类</h4><ol><li>从宏观上按处理机的数量进行分类，分为单处理系统、并行处理系统与多处理系统和分布式处理系统。<ul><li>单处理系统：利用一个处理单元（CPU）与其他外部设备结合起来，实现存储、计算、通信、输入与输出等功能的系统</li><li>并行处理与多处理系统：为了充分发挥问题求解过程中处理的并行性，将两个以上的处理机互连起来，彼此进行通信协调，以便共同求解一个大问题的计算机系统</li><li>分布式处理系统：指物理上远距离而松耦合的多计算机系统。其中，物理上的远距离意味着通信时间与处理时间相比已不可忽略，在通信线路上的数据传输速率要比在处理机内部总线上传输慢得多，这也是松耦合的含义。松耦合意味着各个计算机之间的联系相对较弱。它们不像紧密耦合的多处理机系统那样高度集成和协同工作。在分布式处理系统中，每个计算机都可以独立地处理任务，也可以与其他计算机协作完成任务。它们之间的通信主要是通过网络进行的，而不是像紧密耦合系统那样通过共享内存或高速总线进行。</li></ul></li><li>从微观上按并行程度分类，有Flynn分类法、冯泽云分类法和Kuck分类法。<ul><li>Flynn分类法：按指令流和数据流的多少分类。</li></ul></li></ol><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>一个处理器支持的指令和指令的字节级编码称为其指令集体系结构，不同的处理器支持不同的指令集体系结构，因此，一个程序被编译在一种机器上运行，往往不能在另一种机器上运行</p><p>以下是对这段内容的详细解释：</p><p><strong>一、指令集体系结构的定义</strong></p><p>指令集体系结构（Instruction Set Architecture，ISA）是计算机处理器的一个关键特性。它涵盖了一个处理器所支持的全部指令以及这些指令的字节级编码方式。</p><p>指令是处理器能够执行的基本操作命令，比如加法、减法、数据移动、逻辑运算等。而字节级编码则是将这些指令以特定的二进制格式进行表示，以便处理器能够识别和执行。例如，某个特定的加法指令可能被编码为一组特定的二进制数字序列。</p><p><strong>二、不同处理器的指令集差异</strong></p><p>不同的处理器通常支持不同的指令集体系结构。这是因为处理器的设计目标、应用场景和技术实现各不相同。</p><ol><li><p><strong>设计目标差异</strong>：</p><ul><li>有的处理器可能侧重于高性能计算，因此会设计出复杂而强大的指令集，以支持高效的科学计算、图形处理等任务。例如，某些高端服务器处理器可能具有大量的向量指令和浮点运算指令，以加速大规模数据处理和复杂的数值计算。</li><li>而有的处理器则可能注重低功耗和嵌入式应用，其指令集可能相对简单，以降低芯片面积和功耗。比如在物联网设备中使用的微控制器，其指令集通常较为精简，以满足有限的资源和低功耗要求。</li></ul></li><li><p><strong>应用场景差异</strong>：</p><ul><li>不同的应用领域对指令集的需求也不同。例如，在移动设备中，处理器需要支持高效的多媒体处理和图形显示指令，以满足用户对高清视频播放、游戏等应用的需求。而在数据中心的服务器中，处理器则需要支持大规模并行处理和高速网络通信指令，以处理大量的并发请求和数据传输任务。</li></ul></li><li><p><strong>技术实现差异</strong>：</p><ul><li>处理器的制造工艺、架构设计等技术因素也会影响指令集的选择。例如，一些处理器可能采用复杂的超标量、乱序执行等技术，以提高指令执行的并行度和效率，这就需要相应的指令集支持。而另一些处理器可能采用简单的顺序执行架构，其指令集也会相对简单。</li></ul></li></ol><p><strong>三、程序在不同机器上运行的限制</strong></p><p>由于不同的处理器具有不同的指令集体系结构，一个程序在一种机器上编译后，往往不能直接在另一种机器上运行。</p><ol><li><p><strong>编译过程的依赖</strong>：</p><ul><li>当一个程序被编译时，编译器会将高级语言代码转换为特定处理器的机器代码，这个过程是基于目标处理器的指令集进行的。例如，一个用 C 语言编写的程序在一台使用 x86 指令集的计算机上编译，编译器会生成适合 x86 处理器执行的机器代码。</li><li>如果将这个编译后的程序拿到一台使用 ARM 指令集的机器上运行，由于 ARM 处理器无法理解 x86 机器代码，程序将无法正常运行。</li></ul></li><li><p><strong>解决方法</strong>：</p><ul><li>为了解决这个问题，可以使用跨平台的编程语言和技术。例如，Java 语言通过 Java 虚拟机（JVM）实现了跨平台运行。Java 程序首先被编译为字节码，这种字节码可以在任何安装了 JVM 的机器上运行，JVM 会根据不同的处理器架构将字节码转换为相应的机器代码。</li><li>另一种方法是使用交叉编译工具。可以在一种机器上为另一种不同指令集的机器编译程序，这样就可以在目标机器上运行编译后的程序。</li></ul></li></ol><p>综上所述，指令集体系结构是处理器的重要特性，不同的处理器支持不同的指令集体系结构，这导致了程序在不同机器上运行的限制。为了实现跨平台运行，可以使用跨平台的编程语言和技术，或者使用交叉编译工具。</p><h5 id="指令集体系结构的分类"><a href="#指令集体系结构的分类" class="headerlink" title="指令集体系结构的分类"></a>指令集体系结构的分类</h5><ol><li><p>按体系结构分类</p><p> <strong>一、操作数在 CPU 中的存储方式</strong></p><ol><li><p>寄存器存储</p><ul><li>操作数从主存中取出后保存在 CPU 的寄存器中。寄存器是 CPU 内部的高速存储单元，访问速度非常快。这种方式可以减少对主存的访问次数，提高指令执行的速度。例如，在一些 RISC 架构中，大多数操作数都存储在寄存器中，指令通常只对寄存器中的操作数进行操作。</li><li>优点：访问速度快，减少了对主存的依赖，有利于提高指令执行效率。</li><li>缺点：寄存器数量有限，可能需要频繁地在寄存器和主存之间进行数据传输。</li></ul></li><li><p>主存存储</p><ul><li>操作数从主存中取出后仍然保存在主存中。这种方式需要频繁地访问主存，速度相对较慢。但是，主存的容量通常比寄存器大得多，可以存储更多的数据。在一些 CISC 架构中，指令可以直接对主存中的操作数进行操作。</li><li>优点：可以存储大量的数据，不受寄存器数量的限制。</li><li>缺点：访问速度慢，增加了指令执行的时间。</li></ul></li></ol><p> <strong>二、显式操作数的数量</strong></p><ol><li><p>零操作数指令</p><ul><li>指令中没有显式命名的操作数。这种指令通常是一些控制指令，如跳转指令、中断指令等。它们的操作数通常是隐含的，由 CPU 的状态或程序计数器等决定。</li><li>例如：JMP（跳转指令），它的操作数是目标地址，但这个地址通常是隐含在指令中的，由程序计数器和指令中的偏移量计算得到。</li></ul></li><li><p>单操作数指令</p><ul><li>指令中有一个显式命名的操作数。这个操作数可以是寄存器、主存地址或立即数等。例如，INC（自增指令），它只有一个操作数，表示要自增的寄存器或内存地址。</li><li>优点：指令简单，执行速度相对较快。</li><li>缺点：功能相对单一，对于一些复杂的操作可能需要多条指令来完成。</li></ul></li><li><p>双操作数指令</p><ul><li>指令中有两个显式命名的操作数。这种指令通常用于算术运算、逻辑运算等操作。例如，ADD（加法指令），它有两个操作数，分别表示要相加的两个数。</li><li>优点：可以直接完成一些常见的运算操作，提高了编程的效率。</li><li>缺点：指令长度相对较长，可能会占用更多的存储空间。</li></ul></li><li><p>三操作数指令及以上</p><ul><li>指令中有三个或更多显式命名的操作数。这种指令通常用于一些复杂的运算或数据处理操作。例如，在某些高级编程语言中，可能会有三操作数的赋值语句，如 a &#x3D; b + c。在指令集中，也可能会有类似的指令来实现这种功能。</li><li>优点：可以完成非常复杂的操作，提高了编程的灵活性。</li><li>缺点：指令非常复杂，硬件实现难度大，执行速度可能会受到影响。</li></ul></li></ol><p> <strong>三、操作数的位置</strong></p><ol><li><p>操作数只能在寄存器中</p><ul><li>指令的操作数只能是寄存器中的数据。这种方式可以提高指令执行的速度，因为寄存器的访问速度非常快。但是，它也限制了指令的灵活性，因为操作数不能直接来自主存。例如，在一些 RISC 架构中，大多数指令的操作数都只能是寄存器中的数据。</li><li>优点：访问速度快，有利于提高指令执行效率。</li><li>缺点：编程时需要频繁地在寄存器和主存之间进行数据传输，增加了编程的复杂性。</li></ul></li><li><p>操作数可以在主存中</p><ul><li>指令的操作数可以是主存中的数据。这种方式增加了指令的灵活性，因为操作数可以直接来自主存，不需要先将数据加载到寄存器中。但是，它也降低了指令执行的速度，因为主存的访问速度相对较慢。例如，在一些 CISC 架构中，指令可以直接对主存中的数据进行操作。</li><li>优点：编程更加灵活，可以直接对主存中的数据进行操作。</li><li>缺点：访问速度慢，增加了指令执行的时间。</li></ul></li><li><p>操作数可以在寄存器和主存中混合使用</p><ul><li>指令的操作数可以是寄存器中的数据，也可以是主存中的数据。这种方式结合了上述两种方式的优点，既可以提高指令执行的速度，又可以增加指令的灵活性。例如，在一些现代的处理器架构中，指令可以根据需要选择操作数的来源，既可以是寄存器，也可以是主存。</li><li>优点：兼顾了访问速度和编程灵活性。</li><li>缺点：硬件实现相对复杂，需要更多的控制逻辑来处理不同来源的操作数。</li></ul></li></ol><p> <strong>四、指令的操作</strong></p><ol><li><p>算术运算指令</p><ul><li>包括加法、减法、乘法、除法等指令。这些指令用于对数值型数据进行运算，是指令集中最基本的操作之一。例如，ADD（加法指令）、SUB（减法指令）、MUL（乘法指令）、DIV（除法指令）等。</li><li>优点：可以完成基本的数学运算，是各种计算任务的基础。</li><li>缺点：对于一些复杂的数学运算，可能需要多条指令来完成。</li></ul></li><li><p>逻辑运算指令</p><ul><li>包括与、或、非、异或等指令。这些指令用于对逻辑型数据进行运算，常用于条件判断、位操作等任务。例如，AND（与指令）、OR（或指令）、NOT（非指令）、XOR（异或指令）等。</li><li>优点：可以完成逻辑运算，适用于各种逻辑控制任务。</li><li>缺点：对于一些复杂的逻辑运算，可能需要多条指令来完成。</li></ul></li><li><p>数据传输指令</p><ul><li>包括加载（Load）指令和存储（Store）指令。加载指令用于将数据从主存加载到寄存器中，存储指令用于将寄存器中的数据存储到主存中。这些指令是实现数据在 CPU 和主存之间传输的关键。例如，LOAD（加载指令）、STORE（存储指令）等。</li><li>优点：可以实现数据在 CPU 和主存之间的高效传输。</li><li>缺点：需要占用一定的指令周期，影响指令执行的效率。</li></ul></li><li><p>控制转移指令</p><ul><li>包括跳转（Jump）指令、调用（Call）指令和返回（Return）指令等。这些指令用于改变程序的执行流程，实现程序的分支、循环和函数调用等功能。例如，JMP（跳转指令）、CALL（调用指令）、RET（返回指令）等。</li><li>优点：可以实现程序的灵活控制，提高编程的效率。</li><li>缺点：如果使用不当，可能会导致程序的逻辑混乱，难以调试。</li></ul></li></ol><p> <strong>五、操作数的类型与大小</strong></p><ol><li><p>整数类型</p><ul><li>操作数可以是整数类型的数据，包括有符号整数和无符号整数。整数类型的操作数在计算机中广泛应用于各种数值计算和逻辑控制任务。例如，在加法指令中，操作数可以是整数类型的数据，用于对两个整数进行相加。</li><li>优点：整数类型的数据在计算机中表示简单，运算速度快。</li><li>缺点：对于一些需要高精度计算的任务，整数类型的数据可能不够精确。</li></ul></li><li><p>浮点数类型</p><ul><li>操作数可以是浮点数类型的数据，用于表示实数。浮点数类型的操作数在科学计算、图形处理等领域中广泛应用。例如，在乘法指令中，操作数可以是浮点数类型的数据，用于对两个实数进行相乘。</li><li>优点：可以表示实数，具有较高的精度。</li><li>缺点：浮点数的运算速度相对较慢，硬件实现也比较复杂。</li></ul></li><li><p>字符类型</p><ul><li>操作数可以是字符类型的数据，用于表示文本信息。字符类型的操作数在文本处理、数据库管理等领域中广泛应用。例如，在比较指令中，操作数可以是字符类型的数据，用于比较两个字符串的大小。</li><li>优点：可以表示文本信息，方便进行文本处理。</li><li>缺点：字符类型的数据通常需要占用一定的存储空间，而且字符的比较和处理相对复杂。</li></ul></li><li><p>其他类型</p><ul><li>除了上述几种常见的类型外，操作数还可以是其他类型的数据，如布尔类型、指针类型等。这些类型的数据在特定的应用场景中具有重要的作用。例如，在条件判断指令中，操作数可以是布尔类型的数据，用于判断条件是否成立。</li><li>优点：可以满足不同应用场景的需求。</li><li>缺点：不同类型的数据需要不同的处理方式，增加了硬件设计和编程的复杂性。</li></ul></li></ol></li><li><p>按暂存机制分类：<br> 根据在CPU内部存储操作数的区别，可以把指令集体系分为3类：<br> 堆栈、累加器和寄存器组</p></li></ol><p>通用寄存器的关键性优点是编译程序能有效地使用寄存器，无论是计算表达式地值，还是从全局地角度使用寄存器来保存变量的值。在求解表达式时，寄存器比堆栈或者累加器能提供更加灵活的次序。更重要的是，寄存器能用来保存变量。当变量分配给寄存器时，访存流量就会减少，程序运行就会加速，而且代码密度也会得到改善。用户可以用指令集的两个主要特征来区分GPR体系结构。第一个是ALU指令有两个或三个操作数。在三操作数格式中，指令包括两个源操作数和一个目的操作数；在二操作数格式中，有一个操作数既是源操作数又是目的操作数。第二个是ALU指令中有几个操作数是存储器地址，对于典型的ALU指令，这个数可能在1~3之间。</p><h5 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h5><h4 id="阵列处理机、并行处理机和多处理机"><a href="#阵列处理机、并行处理机和多处理机" class="headerlink" title="阵列处理机、并行处理机和多处理机"></a>阵列处理机、并行处理机和多处理机</h4><blockquote><p>并行性包括同时性和并发性。其中，同时性是指两个或两个以上的事件在同一时刻发生，并行性是指两个或两个以上的事件在同一时间间隔内连续发生。<br>从计算机信息处理的步骤和阶段的角度看，并行处理可分为如下几类：</p><ol><li>存储器操作并行</li><li>处理器操作步骤并行（流水线处理机）</li><li>处理器操作并行（阵列处理机）</li><li>指令、任务、作业并行（多处理机、分布处理系统、计算机网络）</li></ol></blockquote><h5 id="阵列处理机"><a href="#阵列处理机" class="headerlink" title="阵列处理机"></a>阵列处理机</h5><p>阵列处理机将重复设置的多个处理单元（PU）按一定方式连成阵列，在单个控制部件（CU）控制下,对分配给自己的数据进行处理，并行地完成一条指令所规定地操作。这是一种单指令流多数据流计算机，通过资源重复实现并行性</p><h5 id="并行处理机"><a href="#并行处理机" class="headerlink" title="并行处理机"></a>并行处理机</h5><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>计算机系统中可能包括各种存储器，如CPU内部的通用寄存器组、CPU内的Cache（高速缓存）、CPU外部的Cache、主板上的主存储器、主板外的联机（在线）磁盘存储器以及脱机（离线）的磁带存储器和光盘存储器等。不同特点的存储器通过适当的硬件、软件有机地组合在一起形成计算机地存储体系结构。<br>其中，Cache和主存之间地交互功能全部由硬件实现，而主存与辅存之间地交互功能可由硬件和软件结合起来实现、</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9nzs5qvjbs.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9nzs5qvjbs.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><h5 id="按存储器所处的位置分类"><a href="#按存储器所处的位置分类" class="headerlink" title="按存储器所处的位置分类"></a>按存储器所处的位置分类</h5><ol><li>内存：<br> 也成为主存，设在主机内或主机板上，用来存放机器当前运行所需要的程序和数据，以便向CPU提供信息。对于外存，其特点是容量小、速度快</li><li>外存：<br> 也称为辅存，如磁盘、磁带和光盘等，用来存放当前不参加运行的大量信息，而在需要时调入内存</li></ol><h5 id="按存储器的构成材料分类"><a href="#按存储器的构成材料分类" class="headerlink" title="按存储器的构成材料分类"></a>按存储器的构成材料分类</h5><ol><li>磁存储器：<br> 磁存储器是用磁性介质做成的，如磁芯、磁泡、磁膜、磁鼓、磁带及磁盘等</li><li>半导体存储器：<br> 根据所用元件又可分为双极型和MOS型；根据数据是否需要刷新又可分为静态和动态两类</li><li>光存储器：<br> 利用光学方法读&#x2F;写数据的存储器，如光盘</li></ol><h5 id="按存储器的工作方式分类"><a href="#按存储器的工作方式分类" class="headerlink" title="按存储器的工作方式分类"></a>按存储器的工作方式分类</h5><ol><li>读&#x2F;写存储器（RAM）：<br> 它指既能读取数据也能存入数据的存储器</li><li>只读存储器：<br> 工作过程中仅能读取的存储器，根据数据的写入方式，这种存储器又可细分为ROM、PROM、EPROM和EEPROM等类型<ul><li>固定只读存储器（ROM）：<br>  这种存储器是在厂家生产时就写好数据的，其内容只能读出，不能改变。一般用于存放系统程序BIOS和用于微程序控制</li><li>可编程的只读存储器（PROM）：<br>  其中的内容可以由用户一次性地写入，写入后不能再修改</li><li>可擦除可编程的只读存储器（EPROM）：<br>  其中的内容既可以读出，也可以由用户写入，写入后还可以修改。改写的方法是写入之前先用紫外线照射15~20分钟以擦去所有信息，然后再用特殊的电子设备写入信息</li><li>电擦除可编程的只读存储器（EEPROM）：<br>  与EPROM相似，EEPROM中的内容既可以读出，也可以进行改写。只不过这种存储器是用电擦除的方法进行数据的改写</li><li>闪速存储器（Flash Memory）：<br>  简称闪存，闪存的特性介于EPROM和EEPROM之间，类似于EEPROM，也可使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除，速度远快于EPROM</li></ul></li></ol><h5 id="按访问方式分类"><a href="#按访问方式分类" class="headerlink" title="按访问方式分类"></a>按访问方式分类</h5><pre><code>按访问方式可分为按地址访问的存储器和按内容访问的存储器</code></pre><h5 id="按寻址方式分类"><a href="#按寻址方式分类" class="headerlink" title="按寻址方式分类"></a>按寻址方式分类</h5><p>按寻址方式可分为随机存储器、顺序存储器和按内容访问的存储器。</p><ol><li>随机存储器（RAM）：<br> 这种存储器可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间都是相同</li><li>顺序存储器（SAM）：<br> 访问数据所需要的时间与数据所在的存储位置相关，磁带是典型的顺序存储器</li><li>直接存储器（DAM）：<br> 介于随机存取和顺序存取之间的一种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而在一个磁道内则是顺序寻址</li></ol><h4 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h4><p>相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，按顺序写入信息，读出时并行地将关键字与存储器中的每一单元进行比较，找出存储器中所有与关键字相同地数据字，特别适合于信息地检索和更新。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.26lgzavaa5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.26lgzavaa5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>其中，输入检索寄存器用来存放要检索的内容（关键字），屏蔽寄存器用来屏蔽那些不参与检索的字段，比较器将检索的关键字与存储体的每一单元进行比较。为了提高速度，比较器的数量应很大。对于位比较器，应每位对应一个，应有$ 2^m×N $个，对于字比较器应有$ 2^m $个。匹配寄存器用来记录比较的结果，它应有$ 2^m $个二进制位，用来记录$ 2^m $个比较器的结果，1为相等（匹配），0为不相等（不匹配）<br>以下是对这句话的详细解释：</p><p><strong>一、位比较器</strong></p><ol><li><p>定义与作用</p><ul><li>位比较器是用于比较两个数字在每一位上的大小关系的逻辑电路。它通常接收两个输入数字，每个数字由若干位组成，并逐位进行比较，以确定两个数字的大小关系或是否相等。</li></ul></li><li><p>数量计算</p><ul><li><p>假设有两个数字，每个数字有 $m$ 位。对于每一位，都需要一个位比较器来比较该位上的两个数字。</p></li><li><p>由于每个数字的每一位都需要一个比较器，所以对于两个数字，总共需要 $2m$ 个位比较器。</p></li><li><p>如果有 $N$ 对这样的数字需要进行比较，那么总共需要的位比较器数量就是 $2m×N$。</p></li><li><p>例如，假设有两个 4 位数字需要比较，那么总共需要 $2×4 &#x3D; 8$ 个位比较器。如果有 3 对这样的 4 位数字需要比较，那么总共需要 $2×4×3 &#x3D; 24$ 个位比较器。</p></li></ul></li></ol><p><strong>二、字比较器</strong></p><ol><li><p>定义与作用</p><ul><li>字比较器是用于比较两个完整的数字（字）的大小关系或是否相等的逻辑电路。它通常接收两个输入数字，并综合考虑所有位的信息来确定两个数字的整体大小关系。</li></ul></li><li><p>数量计算</p><ul><li><p>对于有 $m$ 位的数字，只需要一个字比较器就可以比较两个这样的数字。</p></li><li><p>因为字比较器是对整个数字进行比较，而不是逐位比较，所以无论有多少对数字需要比较，对于特定位数的数字，只需要 $2^m$ 个不同状态的字比较器来覆盖所有可能的输入组合。</p></li><li><p>例如，对于 4 位数字，有 $2^4 &#x3D; 16$ 种不同的输入组合，所以只需要 16 个不同状态的字比较器就可以比较所有可能的 4 位数字对。</p></li></ul></li></ol><p>综上所述，位比较器和字比较器在数量上的差异主要是由于它们的比较方式不同。位比较器逐位比较，所以数量与数字的位数和比较的对数有关；而字比较器对整个数字进行比较，数量只与数字的位数有关。<br>相联存储器可用在高速缓冲存储器中，在虚拟存储器中用来作为段表、页表或快表存储器，用在数据库和知识库中</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>高速缓存用来存放当前最活跃的程序和数据，其特点是：位于CPU和主存之间；容量一般在几千字节到几兆字节之间；速度一般比主存快5~10倍，由快速半导体存储器构成；其内容是主存局部域的副本，对程序员来说是透明的。</p><h5 id="高速缓存的组成"><a href="#高速缓存的组成" class="headerlink" title="高速缓存的组成"></a>高速缓存的组成</h5><p>高速缓存（Cache）、主存（Main Memory）与CPU的关系：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9kg68335cl.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9kg68335cl.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。<br>现代CPU中Cache分为了多个层级：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6t7400oj7j.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6t7400oj7j.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h5 id="高速缓存中地址映像方法"><a href="#高速缓存中地址映像方法" class="headerlink" title="高速缓存中地址映像方法"></a>高速缓存中地址映像方法</h5><p>在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读&#x2F;写信息。这就需要将主存地址转换成Cache存储器的地址，这种地址的转换称为地址映像。<br>Cache的地址映像有如下三种方法：</p><ol><li><p>直接映像：<br> 直接映像是指主存的块与Cache块的对应关系是固定的。</p> <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2veqjcu69e.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2veqjcu69e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p> 在这种映像方式下，由于主存中的块只能存放在Cache存储器的相同块号中，因此，只要主存地址中的主存区号与Cache中记录的主存区号相同，则表明访问Cache命中。一旦命中，由主存地址中的区内块号立即可得到要访问的Cache存储器中的块，而块内地址就是主存地址中给出的地位地址。<br> 直接映像方式的优点是地址变换很简单，缺点是灵活性差。例如，不同区号中块号相同的块无法同时调入Cache存储器，即使Cache存储器中有空着的块也不能利用</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统基础知识&quot;&gt;&lt;a href=&quot;#计算机系统基础知识&quot; class=&quot;headerlink&quot; title=&quot;计算机系统基础知识&quot;&gt;&lt;/a&gt;计算机系统基础知识&lt;/h2&gt;&lt;h3 id=&quot;计算机系统硬件基本组成&quot;&gt;&lt;a href=&quot;#计算机系统硬件基本组成&quot; c</summary>
      
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师（三）CPU的组成（运算器与控制器）</title>
    <link href="http://tumytime.github.io/2024/10/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%B8%89%EF%BC%89CPU%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%88%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/10/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%88%E4%B8%89%EF%BC%89CPU%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%88%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89/</id>
    <published>2024-10-15T13:27:14.000Z</published>
    <updated>2024-10-17T19:24:16.005Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3k800al9qf.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3k800al9qf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.54xqzsauvs.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.54xqzsauvs.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.969qfisvuu.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.969qfisvuu.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p><strong>一、算术逻辑单元（Arithmetic Logic Unit，ALU）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li><strong>算术运算</strong>：执行基本的算术操作，如加法、减法、乘法、除法等。例如，在进行数值计算时，ALU 可以快速地对两个操作数进行加、减运算，以得到结果。对于乘法和除法，可能需要多个时钟周期来完成复杂的计算过程。</li><li><strong>逻辑运算</strong>：进行逻辑操作，包括与（AND）、或（OR）、非（NOT）、异或（XOR）等。这些逻辑运算在条件判断、位操作和数据处理中非常有用。例如，在进行位掩码操作时，可以使用逻辑与运算来提取特定的位。</li><li><strong>移位操作</strong>：实现数据的左移、右移操作。左移操作可以用于快速乘法，右移操作可以用于快速除法（对于二进制数）。此外，移位操作还可以用于调整数据的位模式。例如，将一个二进制数左移一位相当于将其乘以 2。</li></ul></li><li><p><strong>工作原理</strong>：</p><ul><li>ALU 通常由多个逻辑门和组合电路组成，能够根据输入的操作数和控制信号，在一个时钟周期内完成特定的运算操作。它接收来自累加寄存器、数据缓存寄存器或其他数据源的操作数，并将运算结果输出到累加寄存器或其他目的地。</li></ul></li></ol><p><strong>二、累加寄存器（Accumulator Register）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li><strong>暂存运算结果</strong>：在运算过程中，累加寄存器用于暂时存储 ALU 的运算结果。例如，在进行一系列的加法运算时，每次加法的结果可以先存储在累加寄存器中，以便后续的运算使用。</li><li><strong>中间数据存储</strong>：它也可以作为中间数据的存储位置。在复杂的计算中，可能需要多次使用某个中间结果，将其存储在累加寄存器中可以避免重复计算，提高运算效率。</li><li><strong>数据传输中介</strong>：在数据传输过程中，累加寄存器可以作为数据的中转点。例如，从内存读取的数据可以先存储到累加寄存器中，然后再由 ALU 进行进一步的处理。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>累加寄存器通常是一个快速的存储单元，能够在一个时钟周期内被读取和写入。它的容量相对较小，但访问速度非常快，以满足 CPU 对数据的快速处理需求。</li></ul></li></ol><p><strong>三、数据缓存寄存器（Data Buffer Register）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li><strong>数据暂存</strong>：用于暂时存储从内存或其他外部设备读取的数据，或者将要写入内存或外部设备的数据。例如，当 CPU 需要从内存中读取一个数据块进行处理时，数据可以先被存储在数据缓存寄存器中，然后再传输到其他寄存器或 ALU 进行运算。</li><li><strong>数据缓冲</strong>：起到数据缓冲的作用，减少 CPU 与内存或外部设备之间的数据传输延迟。由于内存的访问速度相对较慢，数据缓存寄存器可以在 CPU 需要数据时快速提供数据，提高系统的整体性能。</li><li><strong>数据传输协调</strong>：在数据传输过程中，数据缓存寄存器可以协调不同速度的设备之间的数据传输。例如，当 CPU 与一个较慢的外部设备进行数据交换时，数据缓存寄存器可以存储一部分数据，等待设备准备好接收或发送数据。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>数据缓存寄存器的容量通常较小，但具有较高的访问速度。它可以根据需要快速地读取或写入数据，以满足 CPU 对数据的即时需求。</li></ul></li></ol><p><strong>四、状态条件寄存器（Status Condition Register）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li><strong>记录运算状态</strong>：存储 ALU 运算结果的状态信息，如零标志（Z）、进位标志（C）、溢出标志（V）、符号标志（S）等。这些标志可以用于判断运算结果的性质，以及在程序中进行条件分支和循环控制。例如，当进行加法运算时，如果结果为零，零标志位将被设置；如果发生进位，进位标志位将被设置。</li><li><strong>反映 CPU 状态</strong>：还可以反映 CPU 的其他状态信息，如中断允许标志、处理器模式标志等。这些标志可以控制 CPU 的操作模式和对外部事件的响应。例如，中断允许标志可以决定 CPU 是否响应外部中断请求。</li></ul></li><li><p><strong>作用</strong>：</p><ul><li>在程序执行过程中，状态条件寄存器的标志位可以被程序读取和测试，以根据运算结果进行不同的操作。例如，在一个条件分支语句中，可以根据零标志位来决定程序的执行路径。状态条件寄存器的信息也可以用于与外部设备进行通信和状态反馈。</li></ul></li></ol><p>CPU（中央处理器）是计算机的核心部件，其结构主要包括以下几个部分：</p><p><strong>一、控制单元（Control Unit，CU）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li>控制单元是 CPU 的指挥中心，负责协调和控制计算机各个部件的工作。它从内存中读取指令，对指令进行译码，并产生相应的控制信号，控制数据的流动和运算单元的操作。</li><li>例如，当执行一条加法指令时，控制单元会发出信号，从内存中读取两个操作数，将它们发送到运算单元进行加法运算，然后将结果存储回内存或寄存器中。</li></ul></li><li><p><strong>组成部分</strong>：</p><ul><li><strong>指令寄存器（Instruction Register，IR）</strong>：用于存储当前正在执行的指令。控制单元从内存中读取指令后，将其放入指令寄存器中，以便进行译码和执行。</li><li><strong>程序计数器（Program Counter，PC）</strong>：指示下一条要执行的指令在内存中的地址。每次执行完一条指令，程序计数器会自动增加，指向下一条指令的地址。</li><li><strong>指令译码器（Instruction Decoder）</strong>：对指令寄存器中的指令进行译码，确定指令的操作类型和操作数的来源。指令译码器将指令转换为一系列控制信号，发送给其他部件执行。</li></ul></li></ol><p><strong>二、运算单元（Arithmetic Logic Unit，ALU）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li>运算单元是 CPU 中执行算术和逻辑运算的部分。它可以进行加、减、乘、除等算术运算，以及与、或、非等逻辑运算。</li><li>例如，在进行两个数的加法运算时，运算单元会接收两个操作数，对它们进行加法操作，并将结果输出。</li></ul></li><li><p><strong>组成部分</strong>：</p><ul><li><strong>算术逻辑部件</strong>：负责执行具体的算术和逻辑运算。它由多个逻辑门和寄存器组成，可以根据控制单元的信号进行不同的运算操作。</li><li><strong>累加器（Accumulator）</strong>：用于暂存运算结果和中间数据。在进行一系列运算时，累加器可以存储中间结果，以便后续的运算使用。</li></ul></li></ol><p><strong>三、寄存器组（Register File）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li>寄存器组是 CPU 内部的高速存储单元，用于暂存数据和指令。寄存器的访问速度非常快，可以大大提高 CPU 的运行效率。</li><li>例如，在执行一条指令时，操作数可以从寄存器中读取，而不是从内存中读取，这样可以大大减少指令的执行时间。</li></ul></li><li><p><strong>组成部分</strong>：</p><ul><li><strong>通用寄存器</strong>：用于存储各种数据和地址。通用寄存器可以被程序员直接访问，用于存储操作数、中间结果和地址等。</li><li><strong>特殊寄存器</strong>：包括程序计数器、指令寄存器、状态寄存器等。这些寄存器用于存储特定的信息，如当前执行的指令地址、指令状态和 CPU 的运行状态等。</li></ul></li></ol><p><strong>四、缓存（Cache）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li>缓存是位于 CPU 和内存之间的高速存储器，用于存储最近使用过的数据和指令。由于缓存的访问速度比内存快得多，因此可以大大提高 CPU 的运行效率。</li><li>例如，当 CPU 需要访问一个数据时，首先会在缓存中查找，如果找到则直接从缓存中读取，否则从内存中读取，并将其存储到缓存中，以便下次访问时可以更快地获取。</li></ul></li><li><p><strong>组成部分</strong>：</p><ul><li><strong>一级缓存（L1 Cache）</strong>：通常是 CPU 内部的高速缓存，分为数据缓存（D-Cache）和指令缓存（I-Cache）。数据缓存用于存储最近使用过的数据，指令缓存用于存储最近使用过的指令。</li><li><strong>二级缓存（L2 Cache）</strong>：通常位于 CPU 和主内存之间，容量比一级缓存大，但访问速度稍慢。二级缓存可以存储更多的数据和指令，进一步提高 CPU 的运行效率。</li><li><strong>三级缓存（L3 Cache）</strong>：在一些高端 CPU 中，还会有三级缓存。三级缓存的容量更大，可以存储更多的数据和指令，为 CPU 提供更高的性能。</li></ul></li></ol><p><strong>五、总线接口单元（Bus Interface Unit，BIU）</strong></p><ol><li><p><strong>功能</strong>：</p><ul><li>总线接口单元负责 CPU 与外部设备和内存之间的数据传输。它通过系统总线与内存和其他设备进行通信，将数据和指令从内存中读取到 CPU 中，或将 CPU 中的数据写入内存或其他设备。</li><li>例如，当 CPU 需要从内存中读取数据时，总线接口单元会向内存发送读取请求，并将读取到的数据传输到 CPU 内部的寄存器或缓存中。</li></ul></li><li><p><strong>组成部分</strong>：</p><ul><li><strong>地址总线</strong>：用于传输内存地址和设备地址。地址总线的宽度决定了 CPU 可以访问的内存空间大小。</li><li><strong>数据总线</strong>：用于传输数据。数据总线的宽度决定了 CPU 一次可以传输的数据位数。</li><li><strong>控制总线</strong>：用于传输控制信号，如读写信号、中断信号等。控制总线的信号决定了数据传输的方向和方式。</li></ul></li></ol><p>综上所述，CPU 的结构是一个复杂的体系，各个部分相互协作，共同完成计算机的各种任务。控制单元负责指挥和协调，运算单元执行具体的运算操作，寄存器组提供高速存储，缓存提高数据访问速度，总线接口单元实现与外部设备和内存的通信。这些部分的协同工作使得 CPU 能够高效地执行各种指令，处理大量的数据，是计算机系统的核心。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img lazyload placeholder&quot; src=&quot;https://tumytime.github.io/picx-images-hosting/image.3k</summary>
      
    
    
    
    <category term="软考" scheme="http://tumytime.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考" scheme="http://tumytime.github.io/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（三）操作系统的体系结构</title>
    <link href="http://tumytime.github.io/2024/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://tumytime.github.io/2024/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2024-10-14T13:18:25.000Z</published>
    <updated>2024-10-19T08:20:30.088Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.70abxfmcbt.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.70abxfmcbt.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.77djsvi7sy.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.77djsvi7sy.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1e8ljlpvt5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1e8ljlpvt5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3goe7nqifj.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3goe7nqifj.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>以下是对大内核和微内核的详细解释：</p><h2 id="大内核（Monolithic-Kernel）"><a href="#大内核（Monolithic-Kernel）" class="headerlink" title="大内核（Monolithic Kernel）"></a>大内核（Monolithic Kernel）</h2><ol><li><p>定义与结构</p><ul><li>大内核是一种将操作系统的主要功能模块都集成在一个内核空间的设计架构。这些功能模块包括进程管理、内存管理、文件系统、设备驱动等。</li><li>例如，在传统的 Linux 内核中，就采用了大内核的设计。它将众多的核心功能紧密集成在一起，以实现高效的系统运行。</li></ul></li><li><p>特点</p><ul><li><strong>高性能</strong>：由于所有功能模块都在同一个地址空间中运行，函数调用和数据传递的开销相对较小，因此可以实现较高的性能。例如，在处理大量的文件读写操作时，大内核可以直接调用文件系统模块，快速完成操作。</li><li><strong>复杂性高</strong>：大内核的设计使得内核代码庞大而复杂。各个功能模块之间的紧密耦合也增加了开发和维护的难度。一旦某个模块出现问题，可能会影响整个系统的稳定性。</li><li><strong>可扩展性受限</strong>：虽然大内核可以通过加载模块的方式进行一定程度的扩展，但这种扩展方式相对较为有限。新功能的添加可能会对现有的内核结构产生较大的影响，需要进行大量的测试和调试。</li></ul></li><li><p>应用场景</p><ul><li>服务器领域：对于需要处理大量数据和高并发请求的服务器，大内核的高性能优势可以得到充分发挥。例如，在企业级服务器中，大内核可以快速响应网络请求，高效地管理内存和存储资源。</li><li>桌面操作系统：常见的桌面操作系统如 Windows 和 macOS 也采用了类似大内核的架构。这些操作系统需要为用户提供丰富的功能和良好的用户体验，大内核可以集成各种硬件驱动和软件模块，满足这些需求。</li></ul></li></ol><h2 id="微内核（Microkernel）"><a href="#微内核（Microkernel）" class="headerlink" title="微内核（Microkernel）"></a>微内核（Microkernel）</h2><ol><li><p>定义与结构</p><ul><li>微内核是一种将操作系统的核心功能尽可能地精简，只保留最基本的功能模块在内核空间，而将其他功能模块移到用户空间的设计架构。通常，微内核只包括进程间通信（IPC）、基本的内存管理和调度等功能。</li><li>例如，QNX 操作系统就是一个典型的微内核架构。它将文件系统、设备驱动等功能模块作为独立的进程运行在用户空间，通过 IPC 与内核进行通信。</li></ul></li><li><p>特点</p><ul><li><strong>高可靠性</strong>：由于微内核只保留了最核心的功能，内核代码量相对较小，结构简单，因此更容易保证系统的稳定性和可靠性。如果某个功能模块出现问题，只会影响该模块本身，不会导致整个系统崩溃。</li><li><strong>可扩展性强</strong>：微内核的架构使得新功能可以以独立的进程形式添加到系统中，不会对内核产生直接影响。这种模块化的设计使得系统具有很强的可扩展性，可以方便地适应不同的应用场景和需求变化。</li><li><strong>安全性高</strong>：各个功能模块运行在用户空间，相互之间通过严格的 IPC 机制进行通信，减少了系统的攻击面，提高了系统的安全性。例如，即使某个用户空间的模块被攻击，攻击者也很难影响到内核和其他模块。</li><li><strong>性能开销</strong>：由于功能模块之间的通信需要通过 IPC 机制进行，这会带来一定的性能开销。相比大内核，微内核的性能可能会稍低一些。但是，随着硬件性能的不断提升和优化技术的发展，这种性能差距正在逐渐减小。</li></ul></li><li><p>应用场景</p><ul><li>实时操作系统：在工业控制、航空航天、医疗设备等对实时性要求极高的领域，微内核的高可靠性和确定性是非常重要的。例如，在飞机的飞行控制系统中，微内核可以确保系统在任何情况下都能及时响应，保证飞行安全。</li><li>安全关键系统：对于涉及国家安全、金融交易、核设施控制等安全关键领域，微内核的高安全性可以提供更好的保障。例如，在金融交易系统中，微内核可以防止黑客攻击和数据泄露，保护用户的财产安全。</li><li>分布式系统：在大规模的分布式计算环境中，微内核的可扩展性和灵活性使得系统可以方便地进行扩展和管理。例如，在云计算平台中，微内核可以实现虚拟机的快速创建和迁移，提高资源利用率和服务质量。</li></ul></li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7ax5qmicpc.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7ax5qmicpc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2a52z2unrq.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2a52z2unrq.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="操作系统引导（boot）"><a href="#操作系统引导（boot）" class="headerlink" title="操作系统引导（boot）"></a>操作系统引导（boot）</h2><h3 id="安装操作系统后的磁盘（硬盘）"><a href="#安装操作系统后的磁盘（硬盘）" class="headerlink" title="安装操作系统后的磁盘（硬盘）"></a>安装操作系统后的磁盘（硬盘）</h3><p>在一个新磁盘里安装操作系统，安装后磁盘里面可能是下图这样，除了能看见的C、D、E、F磁盘分区外，在磁盘开头位置会留出一片区域用于存储MBR</p><p>分区表是一个数据结构，说明每个分区分别占多大空间以及每个分区的地址范围</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4xuj9o54gu.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4xuj9o54gu.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>C盘安装了操作系统，并且会使用C盘来启动操作系统，在这种情况下就可以把C盘称为这个磁盘的活动分区</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4xuj9o54gu.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4xuj9o54gu.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>再把C盘内部进一步细分。根目录就是你双击打开C盘之后看见的那些内容，可能会包含一些文件夹和文件</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3rb812qz0t.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3rb812qz0t.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="操作系统引导（开机过程）"><a href="#操作系统引导（开机过程）" class="headerlink" title="操作系统引导（开机过程）"></a>操作系统引导（开机过程）</h2><p>操作系统要启动，数据要被放到主存里面</p><p>计算机的主存由ROM和RAM两部分组成，平时说手机内存和电脑内存是多少通常说的是RAM，里面的数据一断电就被清空。ROM芯片被集成在电脑主板上，里面存储BIOS基本输入输出系统，BIOS由一系列程序组成，其中最重要的是ROM引导程序，ROM芯片里的数据不会因为断电而丢失。</p><p>开机时CPU通电就会从主存当中固定的位置找到并执行ROM引导程序</p><p>执行ROM引导程序的作用是它会指示CPU把磁盘的MBR读入主存，CPU执行磁盘引导程序，磁盘引导程序根据分区表判断C盘的位置</p><p>接下来读入PBR，CPU执行PBR里面的程序，它会负责找到启动管理器程序，这个程序通常存放在根目录下面完成操作系统初始化的一系列工作</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6t742bbzai.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6t742bbzai.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>硬件自检————检查有没有查磁盘，有没有插内存条等等</p><p>例：Windows操作系统的初始化程序</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4n7pgjs52o.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4n7pgjs52o.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1. CPU 加电（引导过程）</strong>：</p><ul><li>当计算机接通电源后，CPU 开始获得电力并进入初始状态。此时，CPU 的寄存器被重置，程序计数器被设置为一个特定的地址，通常是由硬件设计决定的。这个地址通常指向存储在只读存储器（ROM）中的引导程序的起始位置。</li></ul><p><strong>2. 执行 JMP 指令跳转到 BIOS</strong>：</p><ul><li>CPU 开始执行存储在 ROM 中的第一条指令，通常是一个跳转指令（JMP），将程序计数器指向基本输入&#x2F;输出系统（BIOS）的入口地址。BIOS 是存储在计算机主板上的固件，它负责在计算机启动时进行硬件初始化和自检，并提供基本的输入&#x2F;输出功能。</li><li>这个跳转指令的目的是将控制权转移到 BIOS，以便 BIOS 可以开始执行其引导程序。</li></ul><p><strong>3. 登记 BIOS 中断例程入口地址</strong>：</p><ul><li>BIOS 在启动过程中会登记各种中断例程的入口地址。中断是计算机系统中的一种机制，允许外部设备或软件请求 CPU 的注意并执行特定的任务。BIOS 会将中断例程的入口地址存储在中断向量表中，以便在需要时可以快速响应中断请求。</li><li>例如，当键盘上的某个键被按下时，键盘控制器会向 CPU 发送一个中断请求。CPU 会暂停当前正在执行的程序，根据中断向量表中的入口地址找到相应的中断例程，并执行该例程来处理键盘输入。</li></ul><p><strong>4. 硬件自检</strong>：</p><ul><li>BIOS 开始进行硬件自检（Power-On Self Test，POST）。这个过程会检查计算机的各种硬件组件，如 CPU、内存、硬盘、显卡、键盘等，以确保它们都正常工作。</li><li>POST 会检查硬件的完整性、可用性和兼容性。例如，BIOS 会检查内存的容量和完整性，确保没有损坏的内存模块。它还会检查硬盘的存在和可用性，以及显卡是否能够正常显示图像。</li><li>如果在自检过程中发现硬件故障，BIOS 会发出蜂鸣声或在屏幕上显示错误信息，提示用户进行修复。</li></ul><p><strong>5. 主引导记录 MBR 读入，执行磁盘引导程序</strong>：</p><ul><li>一旦硬件自检完成，BIOS 会尝试从计算机的启动设备（通常是硬盘）中读取主引导记录（Master Boot Record，MBR）。MBR 是存储在硬盘的第一个扇区（512 字节）中的特殊数据结构，它包含了硬盘分区表和一个引导程序。</li><li>BIOS 将 MBR 加载到内存中，并将程序计数器指向 MBR 中的引导程序的入口地址。引导程序是一个小程序，它的任务是加载操作系统的内核并将控制权转移给它。</li><li>引导程序会扫描硬盘分区表，找到一个可引导的分区（通常是安装了操作系统的分区），并尝试从该分区中读取分区引导记录（Partition Boot Record，PBR）。</li></ul><p><strong>6. 扫描硬盘分区表</strong>：</p><ul><li>引导程序在 MBR 中执行时，会扫描硬盘分区表以确定可引导的分区。硬盘分区表是存储在 MBR 中的一个数据结构，它记录了硬盘上的各个分区的信息，如分区的起始位置、大小、文件系统类型等。</li><li>引导程序会遍历分区表中的每个条目，检查其标志位以确定该分区是否可引导。如果找到一个可引导的分区，引导程序会读取该分区的 PBR。</li></ul><p><strong>7. 加载分区引导记录 PBR，执行分区引导程序</strong>：</p><ul><li>一旦找到可引导的分区，引导程序会从该分区中读取分区引导记录（PBR）。PBR 是存储在每个分区的第一个扇区中的特殊数据结构，它包含了该分区的引导程序和文件系统信息。</li><li>BIOS 将 PBR 加载到内存中，并将程序计数器指向 PBR 中的引导程序的入口地址。分区引导程序的任务是加载操作系统的内核文件，并将控制权转移给它。</li><li>分区引导程序通常会根据文件系统的类型，从分区中查找并加载操作系统的内核文件。例如，在 Windows 系统中，分区引导程序可能会加载 NTLDR（Windows NT Loader）或 BOOTMGR（Windows Boot Manager），然后由它们进一步加载 Windows 内核文件（ntoskrnl.exe）。</li></ul><p><strong>8. 加载启动管理器，执行操作系统初始化程序</strong>：</p><ul><li>在一些操作系统中，如 Windows，分区引导程序会加载启动管理器（如 BOOTMGR）。启动管理器的任务是提供一个用户界面，允许用户选择要启动的操作系统（如果计算机上安装了多个操作系统），并加载相应的操作系统内核文件。</li><li>启动管理器会执行操作系统的初始化程序，这些程序会进一步加载操作系统的内核和其他关键组件，并进行系统配置和初始化。例如，在 Windows 系统中，启动管理器会加载 Windows 内核文件（ntoskrnl.exe）和 HAL（Hardware Abstraction Layer），然后由内核进行系统初始化，包括加载设备驱动程序、启动系统服务等。</li></ul><p><strong>9. 加载操作系统</strong>：</p><ul><li>一旦操作系统的内核文件被加载到内存中，内核开始执行并进行系统初始化。内核会加载各种设备驱动程序，建立内存管理、进程调度、文件系统等核心系统服务，并最终启动用户登录界面或命令行提示符，等待用户输入。</li><li>此时，操作系统已经完全启动，用户可以开始使用计算机进行各种任务，如运行应用程序、访问文件、浏览网页等。</li></ul><p>总的来说，计算机的引导过程是一个复杂而有序的步骤序列，它涉及到硬件自检、BIOS 初始化、引导程序加载、操作系统内核加载等多个阶段。每个阶段都有其特定的任务和功能，它们共同协作，确保计算机系统能够从电源开启状态顺利启动到可操作的操作系统环境。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img lazyload placeholder&quot; src=&quot;https://tumytime.github.io/picx-images-hosting/image.70</summary>
      
    
    
    
    <category term="操作系统" scheme="http://tumytime.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="http://tumytime.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（二）操作系统的运行机制</title>
    <link href="http://tumytime.github.io/2024/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://tumytime.github.io/2024/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2024-10-13T12:48:42.000Z</published>
    <updated>2024-10-14T13:40:00.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h2><h3 id="内核程序VS应用程序"><a href="#内核程序VS应用程序" class="headerlink" title="内核程序VS应用程序"></a>内核程序VS应用程序</h3><blockquote><p>一条高级语言的代码翻译过来可能对应多条机器指令。程序运行的过程就是CPU执行一条一条的机器指令的过程。</p></blockquote><blockquote><p>微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”，由很多内核程序组成了“操作系统内核”，或简称“内核（Kernel）”<br>内核是操作系统最重要最核心的部分，也是最接近硬件的部分<br>甚至可以说，一个操作系统只要有内核就够了（eg: Docker-&gt;仅需Linux内核）<br>操作系统的功能未必都在内核中，如图形化用户界面GUI</p></blockquote><h3 id="特权指令VS非特权指令"><a href="#特权指令VS非特权指令" class="headerlink" title="特权指令VS非特权指令"></a>特权指令VS非特权指令</h3><blockquote><p>应用程序只能使用“非特权指令”，如：加法指令、减法指令等<br>操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”–即操作系统内核来使用</p></blockquote><blockquote><p>在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。</p></blockquote><h3 id="内核态VS用户态"><a href="#内核态VS用户态" class="headerlink" title="内核态VS用户态"></a>内核态VS用户态</h3><blockquote><p>CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序or应用程序</p></blockquote><blockquote><p>CPU有两种状态，“内核态”和“用户态”<br>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令<br>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p></blockquote><blockquote><p>CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”<br>别名：内核态&#x3D;核心态&#x3D;管态；用户态&#x3D;目态</p></blockquote><h3 id="内核态、用户态的切换"><a href="#内核态、用户态的切换" class="headerlink" title="内核态、用户态的切换"></a>内核态、用户态的切换</h3><blockquote><p><strong>内核态-&gt;用户态：</strong>执行一条特权指令–修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权<br><strong>用户态-&gt;内核态：</strong>由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p></blockquote><ol><li><p><strong>CPU使用权交给操作系统的含义</strong></p><ul><li><strong>指令执行权限角度</strong>：<ul><li>在计算机系统中，CPU是执行指令的核心部件。当把CPU使用权交给操作系统时，意味着CPU开始执行操作系统内核中的指令序列。例如，在计算机启动时，BIOS（基本输入输出系统）完成初始化后，会将CPU控制权交给引导加载程序，引导加载程序再把控制权交给操作系统内核。这时，CPU就按照操作系统内核的代码逻辑，开始执行诸如初始化硬件设备、创建进程管理的数据结构、加载驱动程序等一系列复杂的指令。</li></ul></li><li><strong>资源管理角度</strong>：<ul><li>操作系统负责管理计算机系统的各种资源，包括内存、I&#x2F;O设备、CPU时间等。当拥有CPU使用权时，操作系统可以合理地分配CPU时间片给不同的进程。比如，在多任务操作系统中，操作系统会根据一定的调度算法（如先来先服务、时间片轮转、优先级调度等），决定哪个进程可以使用CPU。这就好像一个交通警察（操作系统）在指挥交通（管理CPU资源），决定哪辆车（进程）可以通过路口（使用CPU）。</li></ul></li></ul></li><li><p><strong>操作系统执行指令的方式</strong></p><ul><li><strong>自动执行引导过程指令</strong>：<ul><li>在启动阶段，操作系统会自动执行一系列预先编写好的指令。例如，当计算机电源开启后，BIOS加载引导扇区的内容，引导扇区的代码引导操作系统内核加载到内存中，这个过程是自动进行的，由硬件和预先存储在固件中的程序触发，然后操作系统内核开始自动执行初始化指令，包括设置中断向量表、初始化内存管理单元等。</li></ul></li><li><strong>响应事件执行指令</strong>：<ul><li>操作系统会自动响应各种事件来执行指令。以系统调用为例，当用户程序需要执行一些特权操作（如文件读写、内存分配等），它会通过系统调用指令触发一个软件中断。操作系统内核收到这个中断信号后，会自动执行相应的处理指令。例如，当用户程序请求读取一个文件时，操作系统会自动执行文件系统相关的指令，如定位文件在磁盘上的位置、读取文件内容到内存缓冲区等，然后将结果返回给用户程序。</li></ul></li><li><strong>基于定时器中断执行指令</strong>：<ul><li>定时器中断是操作系统进行多任务调度的重要手段。操作系统设置一个定时器，每隔一定时间（如几毫秒）就会产生一次定时器中断。当定时器中断发生时，操作系统会自动执行指令来进行进程切换。例如，假设当前进程的时间片用完了，定时器中断触发后，操作系统会自动保存当前进程的上下文（如程序计数器、寄存器内容等），然后选择下一个要执行的进程，恢复其上下文并开始执行该进程的指令。</li></ul></li></ul></li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7egrgeuvlb.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7egrgeuvlb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>当操作系统通过中断夺回CPU控制权来处理引发中断的事件（如检测到用户态试图执行特权指令这种非法事件）时，会进行以下几种处理：</p><p><strong>一、异常处理相关操作</strong></p><ol><li><p><strong>识别异常类型和来源</strong></p><ul><li>操作系统首先会确定中断是由非法的特权指令执行尝试引发的。通过中断向量表（一个存储了各种中断处理程序入口地址的数据结构），操作系统可以快速定位到与这种特定类型的非法指令执行相关的处理程序。这个处理程序会详细记录异常发生的程序位置（例如，记录是哪个应用程序中的哪条指令引发了异常），这有助于后续的故障排查和安全审计。</li></ul></li><li><p><strong>保存应用程序上下文</strong></p><ul><li>在停止当前应用程序的执行之前，操作系统会保存应用程序的当前状态，包括程序计数器（PC）的值，即下一条要执行的指令的地址；各个通用寄存器（如累加器、索引寄存器等）的内容；以及其他与程序执行相关的状态信息（如栈指针、标志寄存器等）。这样做是为了在处理完中断后，如果决定继续执行该应用程序，能够恢复到中断发生前的状态。</li></ul></li><li><p><strong>报告异常情况</strong></p><ul><li>操作系统可能会向系统日志记录异常信息，包括异常类型（这里是用户态执行特权指令）、发生异常的应用程序标识符、异常发生的时间等。这对于系统管理员或安全软件来监控系统安全和稳定性非常重要。同时，操作系统也可能会向用户显示一个错误提示，告知用户应用程序出现了异常，不过具体是否显示提示以及如何显示会因操作系统设计和配置而异。</li></ul></li></ol><p><strong>二、安全相关操作</strong></p><ol><li><p><strong>终止违规应用程序</strong></p><ul><li>一种常见的处理方式是直接终止引发异常的应用程序。操作系统会回收该应用程序占用的所有资源，包括内存空间、打开的文件句柄、网络连接等。这可以防止恶意代码进一步破坏系统或者窃取用户数据。在终止应用程序后，操作系统可能会向用户显示一个错误消息，说明应用程序因为安全违规而被终止。</li></ul></li><li><p><strong>安全审计和监控</strong></p><ul><li>操作系统会更新安全审计记录，记录这次非法尝试执行特权指令的事件。这些记录可以用于后续的安全分析，例如统计特定应用程序或者用户账户的异常行为频率，以便发现潜在的安全威胁模式。安全监控软件可以利用这些记录来实时监控系统安全状态，并在发现异常行为频繁发生时采取更严格的安全措施，如限制可疑用户账户的权限或者对相关应用程序进行更深入的安全检查。</li></ul></li><li><p><strong>隔离和防护措施</strong></p><ul><li>如果操作系统检测到这种非法尝试可能是由于外部攻击（如黑客入侵）引起的，它可能会启动隔离机制。例如，将受到影响的应用程序所在的网络连接进行隔离，防止攻击扩散到其他网络节点。同时，操作系统可能会加强系统的防护措施，如更新防火墙规则、增加入侵检测系统的敏感度等。</li></ul></li></ol><p><strong>三、资源和系统状态恢复操作</strong></p><ol><li><strong>恢复系统资源状态</strong><ul><li>在处理中断的过程中，操作系统需要确保系统资源的状态是正确的。例如，如果应用程序在试图执行特权指令之前已经占用了某些硬件资源（如独占访问了某个I&#x2F;O设备），操作系统需要检查这些资源是否处于安全状态，是否需要进行清理或者重新初始化。如果资源状态被破坏，操作系统需要采取措施恢复它们，以保证其他应用程序能够正常使用这些资源。</li></ul></li><li><strong>重新调度CPU</strong><ul><li>完成对中断事件的处理后，操作系统会根据其调度策略重新安排CPU的使用。这可能涉及选择下一个要执行的应用程序或者内核任务。如果系统中有其他高优先级的任务等待执行（如实时性要求很高的系统服务），操作系统可能会优先安排这些任务上CPU运行。如果被终止的应用程序还有相关的清理工作需要完成（如保存未完成的数据），操作系统可能会安排一个专门的清理程序来执行这些任务，然后再将CPU使用权分配给其他正常的应用程序。</li></ul></li></ol><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lvpv9s3e0.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lvpv9s3e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><h4 id="内中断（也称“异常-例外”）"><a href="#内中断（也称“异常-例外”）" class="headerlink" title="内中断（也称“异常&#x2F;例外”）"></a>内中断（也称“异常&#x2F;例外”）</h4><ol><li><p>陷阱&#x2F;陷入：<br> 由陷入指令引发，是应用程序故意引发的</p></li><li><p>故障：<br> 由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。如：缺页故障（当cpu执行进程的某个页面时，发现他要访问的页(虚拟地址的页)没有在物理内存中，而导致的中断（页错误）。 （一个可执行文件可能很大，放在磁盘上，由局部性原理一次只将其中一部分读进内存））</p></li><li><p>终止：<br> 由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0（程序本身bug）、非法使用特权指令</p><blockquote><p>与当前执行的指令有关，中断信号来源于CPU内部。CPU在执行指令时会检查是否有异常发生</p></blockquote></li><li><p>尝试在用户态下执行特权指令</p></li><li><p>被除数为0</p></li><li><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊（不是特权）的指令–陷入指令，该指令会引发一个内部中断信号</p></li></ol><blockquote><p>执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的。</p></blockquote><h4 id="外中断（也称“中断”）"><a href="#外中断（也称“中断”）" class="headerlink" title="外中断（也称“中断”）"></a>外中断（也称“中断”）</h4><blockquote><p>与当前执行的指令无关，中断信号来源于CPU外部。每个指令周期末尾，CPU都会检查是否有外中断信号需要处理</p></blockquote><ol><li><p>时钟中断，由时钟部件发来的中断信号</p><ul><li><p><strong>时钟中断的基本概念</strong></p></li><li><p>时钟中断是由计算机系统中的硬件定时器产生的一种中断信号。定时器以固定的频率（例如，每秒产生100次中断，对应的时间间隔为10毫秒）发出中断请求。当定时器发出中断时，CPU会暂停当前正在执行的任务，转而执行与时钟中断相关的处理程序。</p></li><li><p>这个处理程序通常位于操作系统内核中，主要用于更新系统时间、统计进程的执行时间、进行进程调度等操作。例如，在一个分时操作系统中，时钟中断是实现时间片轮转调度算法的关键机制。</p></li><li><p><strong>并发的概念</strong></p></li><li><p>并发是指多个任务在宏观上看起来是同时执行的情况。实际上，在单CPU系统中，这些任务是通过分时复用CPU资源来实现“同时”执行的。例如，操作系统中有多个进程（如一个文本编辑进程和一个音乐播放进程），它们看起来是同时运行的，但在微观层面，CPU在每个瞬间只能执行一个进程的指令。</p></li><li><p><strong>时钟中断在并发中的作用</strong></p></li><li><p><strong>进程调度基础</strong>：</p><ul><li>在多进程并发环境下，时钟中断是实现进程调度的重要触发机制。假设系统中有进程A和进程B，每个进程都被分配了一个时间片来使用CPU。当定时器产生时钟中断时，操作系统内核会检查当前正在执行的进程（例如进程A）的时间片是否用完。如果用完了，内核就会暂停进程A的执行，保存其上下文（包括程序计数器、寄存器内容等），然后选择另一个进程（如进程B）来执行。通过这种方式，多个进程能够轮流使用CPU，实现并发执行。</li></ul></li><li><p><strong>公平性保障</strong>：</p><ul><li>时钟中断有助于保证各个并发进程能够公平地获得CPU资源。以时间片轮转调度为例，每个进程都有机会在固定的时间间隔内使用CPU。如果没有时钟中断，一个进程可能会一直占用CPU，导致其他进程无法执行。时钟中断的固定频率就像一个节拍器，确保每个进程都能在一定的节奏下得到CPU的服务。</li></ul></li><li><p><strong>系统响应性提升</strong>：</p><ul><li>对于具有不同优先级的并发进程，时钟中断也起到重要作用。例如，在一个实时操作系统中，高优先级的进程需要及时响应外部事件。当一个高优先级进程等待执行，而当前低优先级进程正在占用CPU时，时钟中断可以使操作系统内核有机会检查高优先级进程的等待时间是否超过了允许的限度。如果超过了，内核可以暂停低优先级进程，优先执行高优先级进程，从而提高系统对紧急事件的响应能力。</li></ul></li><li><p><strong>资源统计与管理</strong>：</p><ul><li>时钟中断还用于统计并发进程的资源使用情况。在每次时钟中断发生时，操作系统可以记录各个进程的执行时间、I&#x2F;O操作次数等信息。这些信息对于资源管理非常重要，例如，可以根据进程的资源使用情况来调整它们的优先级，或者决定是否需要为某个进程分配更多的内存或其他资源。同时，通过对资源使用情况的统计，操作系统可以更好地优化系统性能，避免某个进程过度占用资源而影响其他进程的正常运行。</li></ul></li></ul></li><li><p>I&#x2F;O中断：由输入&#x2F;输出设备发来的中断信号</p><p> 当输入&#x2F;输出任务完成后，向CPU发送中断信号</p></li></ol><h3 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h3><blockquote><p>不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。<br>中断向量表：中断信号类型-&gt;中断处理程序指针<br>显然，中断处理程序一定是内核程序，需要运行在“内核态”</p></blockquote><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><blockquote><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务（系统调用引发系统中断）</p></blockquote><h3 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.83a11spd0j.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.83a11spd0j.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="小例子：为什么系统调用是必须的"><a href="#小例子：为什么系统调用是必须的" class="headerlink" title="小例子：为什么系统调用是必须的"></a>小例子：为什么系统调用是必须的</h3><ol><li><p><strong>文件操作方面</strong></p><ul><li><strong>读取文件内容</strong>：<ul><li>假设你正在编写一个简单的文本编辑器应用程序。当用户在这个编辑器中打开一个文件并希望查看文件内容时，应用程序（运行在用户态）本身没有权限直接访问磁盘上的文件。这是因为直接的硬件访问是一种特权操作，防止用户程序由于错误或恶意目的而破坏文件系统或其他用户的数据。</li><li>应用程序需要通过系统调用（如在Linux中使用<code>read</code>系统调用）来请求操作系统内核（运行在内核态）执行文件读取操作。操作系统内核拥有管理文件系统和硬件设备的权限，它可以找到文件在磁盘上的存储位置，将文件内容从磁盘读取到内存缓冲区，然后将这些数据返回给应用程序。如果没有系统调用，应用程序将无法访问和读取文件内容，文本编辑器也就无法正常工作。</li></ul></li><li><strong>写入文件内容</strong>：<ul><li>当用户在文本编辑器中修改了文件内容并希望保存时，应用程序同样需要通过系统调用（如<code>write</code>系统调用）来请求操作系统将内存中的数据写入磁盘文件。操作系统会处理诸如更新文件的元数据（如文件大小、修改时间等）、确保数据的一致性（通过缓冲、同步等机制）以及处理磁盘I&#x2F;O错误等复杂任务。如果没有系统调用，用户程序可能会错误地写入文件，导致数据丢失或文件系统损坏。</li></ul></li></ul></li><li><p><strong>进程管理方面</strong></p><ul><li><strong>创建新进程</strong>：<ul><li>考虑一个多任务操作系统环境下的软件，例如一个图形处理软件，它可能需要启动一个子进程来执行一些额外的任务，如进行图像格式转换。应用程序（运行在用户态）本身无法直接创建新的进程，因为进程的创建涉及到系统资源的分配（如内存空间、进程控制块等）和复杂的内核操作。</li><li>通过系统调用（如在Linux中的<code>fork</code>系统调用），应用程序可以请求操作系统内核创建一个新的进程。操作系统内核会为新进程分配必要的资源，设置进程的初始状态，包括程序计数器、寄存器内容等，然后将新进程加入到进程调度队列中。没有系统调用，应用程序就无法创建新的进程，复杂的多任务协作功能将无法实现。</li></ul></li><li><strong>终止进程</strong>：<ul><li>当一个应用程序完成了它的任务或者遇到了不可恢复的错误时，它需要安全地终止自己。但是简单地停止程序执行可能会导致资源泄漏等问题。通过系统调用（如<code>exit</code>系统调用），应用程序可以请求操作系统内核来回收它所占用的所有资源，包括释放内存、关闭打开的文件和网络连接等。这可以确保系统的稳定性和资源的有效利用，若没有系统调用，进程终止过程可能会混乱，影响整个系统的正常运行。</li></ul></li></ul></li><li><p><strong>内存管理方面</strong></p><ul><li><strong>动态内存分配</strong>：<ul><li>编写一个动态数据结构相关的程序，例如一个链表程序。当需要向链表中添加新节点时，可能需要动态地分配内存来存储节点数据。应用程序（运行在用户态）不能直接访问和分配物理内存，因为这需要对内存管理单元（MMU）和物理内存进行精细的控制，以避免不同应用程序之间的内存冲突和系统崩溃。</li><li>通过系统调用（如在C语言中的<code>malloc</code>函数，其底层是通过系统调用实现的），应用程序可以请求操作系统内核为其分配一块合适大小的内存。操作系统内核会根据当前的内存使用情况，在内存池中找到一块空闲的内存区域，将其分配给应用程序，并更新内存管理的数据结构。如果没有系统调用，应用程序很难安全有效地获取和使用内存，可能会导致内存访问错误或系统内存管理混乱。</li></ul></li></ul></li></ol><h3 id="系统调用按功能分类"><a href="#系统调用按功能分类" class="headerlink" title="系统调用按功能分类"></a>系统调用按功能分类</h3><blockquote><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作</p></blockquote><ol><li>设备管理<br> 完成设备的  请求&#x2F;释放&#x2F;启动 等功能</li><li>文件管理<br> 完成文件的  读&#x2F;写&#x2F;创建&#x2F;删除 等功能</li><li>进程控制<br> 完成进程的  创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒 等功能</li><li>进程通信<br> 完成进程之间的  消息传递&#x2F;信号传递 等功能</li><li>内存管理<br> 完成内存的  分配&#x2F;回收 等功能</li></ol><h3 id="Linxu系统调用例子"><a href="#Linxu系统调用例子" class="headerlink" title="Linxu系统调用例子"></a>Linxu系统调用例子</h3><ol><li><p><strong>进程管理相关系统调用</strong></p><ul><li><strong>fork()</strong> ：</li><li>功能：用于创建一个新的进程。新进程（子进程）是调用进程（父进程）的副本，它们几乎共享相同的内存空间（代码段、数据段等），但有独立的进程地址空间。子进程会从<code>fork</code>调用返回的位置开始执行，在父进程中，<code>fork</code>返回子进程的进程ID，而在子进程中，<code>fork</code>返回0。</li><li>应用场景：在多进程程序中，比如服务器软件创建子进程来处理客户端请求，或者在命令行中执行一个程序并希望它在后台运行时，会使用<code>fork</code>系统调用。</li><li><strong>exec()系列（如execve、execl等）</strong> ：<ul><li>功能：用于在当前进程的上下文中加载并执行一个新的程序。<code>exec</code>系统调用会替换当前进程的地址空间内容，包括代码段、数据段和堆栈段等，以新程序的内容来运行。不同的<code>exec</code>函数变体主要是参数传递方式的不同。</li><li>应用场景：在需要启动其他程序来完成特定任务的场景中使用。例如，在一个脚本语言解释器中，当执行外部命令时，可能会使用<code>exec</code>系统调用来加载并运行相应的二进制程序。</li></ul></li><li><strong>wait()和waitpid()</strong> ：</li><li>功能：用于使父进程暂停执行，等待子进程结束。<code>wait</code>会阻塞父进程，直到任意一个子进程结束，然后返回子进程的状态信息。<code>waitpid</code>则可以更灵活地指定等待特定的子进程结束，并且可以设置一些选项，如非阻塞等待等。</li><li>应用场景：在父进程需要获取子进程的执行结果或者确保子进程正确退出的情况下使用。例如，在一个进程创建子进程来执行计算任务后，父进程可以使用<code>wait</code>或<code>waitpid</code>来获取子进程的计算结果并进行后续处理。</li></ul></li><li><p><strong>文件系统相关系统调用</strong></p><ul><li><strong>open()</strong> ：<ul><li>功能：用于打开一个文件或设备文件。它返回一个文件描述符，用于后续对文件进行读写操作等。可以指定打开文件的模式，如只读（<code>O_RDONLY</code>）、只写（<code>O_WRONLY</code>）、读写（<code>O_RDWR</code>），以及一些其他的选项，如创建新文件（<code>O_CREAT</code>）、追加模式（<code>O_APPEND</code>）等。</li><li>应用场景：在任何需要读取或写入文件的程序中都会用到。例如，在一个文本编辑器中，打开文件进行编辑时会使用<code>open</code>系统调用。</li></ul></li><li><strong>read()和write()</strong> ：<ul><li>功能：<code>read</code>用于从打开的文件描述符中读取数据到指定的缓冲区，<code>write</code>用于将缓冲区中的数据写入到打开的文件描述符中。它们可以用于各种文件类型，包括普通文件、设备文件等。</li><li>应用场景：广泛应用于文件读写操作。例如，在一个文件复制程序中，通过<code>read</code>从源文件读取数据，然后通过<code>write</code>将数据写入目标文件。</li></ul></li><li><strong>close()</strong> ：<ul><li>功能：用于关闭一个已经打开的文件描述符。当文件描述符关闭后，与之相关的内核资源会被释放，并且文件描述符可以被重新分配给其他文件。</li><li>应用场景：在文件操作结束后，为了释放资源和避免文件描述符泄漏，需要使用<code>close</code>系统调用。例如，在一个网络服务器程序中，当处理完一个客户端的文件上传或下载请求后，会关闭相关的文件描述符。</li></ul></li></ul></li><li><p><strong>内存管理相关系统调用</strong></p><ul><li><strong>mmap()和munmap()</strong> ：<ul><li>功能：<code>mmap</code>用于将文件或者设备的内容映射到进程的虚拟地址空间，这样进程可以像访问内存一样访问文件内容。<code>munmap</code>则用于解除这种映射关系。<code>mmap</code>可以提高文件访问的效率，并且在一些共享内存的场景中非常有用。</li><li>应用场景：在需要高效地访问文件内容或者实现进程间共享内存的场景中使用。例如，在一个数据库管理系统中，可能会使用<code>mmap</code>将数据库文件映射到内存中，以加快数据访问速度。</li></ul></li><li><strong>brk()和sbrk()</strong> ：<ul><li>功能：用于调整进程的堆空间大小。<code>brk</code>通过指定一个新的堆末尾地址来改变堆大小，<code>sbrk</code>则是通过指定一个增量来改变堆大小。</li><li>应用场景：在动态内存分配库（如<code>malloc</code>和<code>free</code>）的底层实现中可能会用到这些系统调用。当程序需要动态地增加或减少内存使用量时，会间接使用这些系统调用。</li></ul></li></ul></li><li><p><strong>信号处理相关系统调用</strong></p><ul><li><strong>signal()和sigaction()</strong> ：<ul><li>功能：<code>signal</code>用于设置信号处理函数，当指定的信号（如<code>SIGINT</code>中断信号、<code>SIGTERM</code>终止信号等）被接收到时，执行相应的处理函数。<code>sigaction</code>是一个更复杂、功能更强大的信号处理系统调用，它可以设置更多关于信号处理的细节，如信号的屏蔽、信号处理的属性等。</li><li>应用场景：在需要对系统信号做出响应的程序中使用。例如，在一个后台服务程序中，当接收到<code>SIGTERM</code>信号时，通过信号处理系统调用来执行清理工作并安全地退出程序。</li></ul></li></ul></li></ol><h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><ol><li><p><strong>应用程序发起系统调用</strong></p><ul><li><strong>调用接口函数</strong> ：<ul><li>在应用程序中，程序员通过调用特定的函数来发起系统调用。这些函数在不同的编程语言和操作系统中有不同的表现形式。例如，在C语言中，用于文件读写的<code>read</code>和<code>write</code>函数就是系统调用的接口。当应用程序执行这些函数时，实际上是在请求操作系统内核提供相应的服务。</li><li>这些接口函数通常会进行一些必要的参数检查和预处理。例如，对于文件读写系统调用，接口函数会检查文件描述符是否有效、读写缓冲区是否正确分配等。</li></ul></li></ul></li><li><p><strong>触发软中断（软件中断）</strong></p><ul><li><strong>指令执行</strong> ：<ul><li>在许多操作系统（如Linux）中，系统调用是通过软中断机制实现的。当应用程序调用系统调用接口函数后，会执行一条特殊的指令来触发软中断。例如，在传统的Linux系统中，通过执行<code>int 0x80</code>指令（在不同的硬件架构和操作系统版本可能有所不同）来产生软中断。</li><li>这个软中断信号会使CPU暂停当前应用程序的执行（此时应用程序处于用户态），并将控制权转移给操作系统内核。</li></ul></li></ul></li><li><p><strong>通过中断向量表找到系统调用处理程序</strong></p><ul><li><strong>中断向量表的作用</strong> ：<ul><li>计算机系统中有一个中断向量表，它存储了各种中断（包括软中断）处理程序的入口地址。当系统调用产生的软中断发生时，CPU根据中断向量表找到对应的系统调用处理程序的入口地址。</li><li>例如，在Linux系统中，每个系统调用都有一个对应的系统调用号，这个号码会作为索引或者参数的一部分，帮助CPU在中断向量表或者相关的数据结构中定位到准确的系统调用处理程序。</li></ul></li></ul></li><li><p><strong>系统调用处理程序执行内核服务</strong></p><ul><li><strong>内核态操作</strong> ：<ul><li>一旦找到系统调用处理程序，CPU开始执行这个处理程序。此时，CPU处于内核态，系统调用处理程序可以访问操作系统内核的所有资源，包括硬件设备、内存管理单元等。</li><li>以文件读取系统调用为例，系统调用处理程序会根据文件描述符找到对应的文件在内核中的数据结构，检查文件的权限和状态，然后通过磁盘I&#x2F;O操作从磁盘读取数据到内核缓冲区，再将数据从内核缓冲区复制到应用程序指定的用户缓冲区。</li></ul></li></ul></li><li><p><strong>返回结果给应用程序并恢复执行</strong></p><ul><li><strong>结果返回</strong> ：<ul><li>系统调用处理程序在完成内核服务后，会将结果返回给应用程序。例如，对于文件读取系统调用，返回读取的字节数或者错误码（如果读取过程中出现问题）。这些结果会通过寄存器或者内存中的特定位置传递给应用程序。</li><li>同时，操作系统会恢复应用程序的执行环境。这包括恢复应用程序的寄存器内容、程序计数器等，使应用程序能够从系统调用之后的指令继续执行。就好像应用程序在系统调用期间被“暂停”，现在又被“唤醒”，并且得到了它所请求的服务的结果。</li></ul></li></ul></li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.77djmdd76s.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.77djmdd76s.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统的运行机制&quot;&gt;&lt;a href=&quot;#操作系统的运行机制&quot; class=&quot;headerlink&quot; title=&quot;操作系统的运行机制&quot;&gt;&lt;/a&gt;操作系统的运行机制&lt;/h2&gt;&lt;h3 id=&quot;内核程序VS应用程序&quot;&gt;&lt;a href=&quot;#内核程序VS应用程序&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://tumytime.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="http://tumytime.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）计算机网络体系结构</title>
    <link href="http://tumytime.github.io/2024/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://tumytime.github.io/2024/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2024-10-12T13:26:38.000Z</published>
    <updated>2024-10-12T14:00:25.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.32hy7g2b2e.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.32hy7g2b2e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机网络的概念&quot;&gt;&lt;a href=&quot;#计算机网络的概念&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的概念&quot;&gt;&lt;/a&gt;计算机网络的概念&lt;/h2&gt;&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img cl</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://tumytime.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="计算机网络" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（一）操作系统概述</title>
    <link href="http://tumytime.github.io/2024/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://tumytime.github.io/2024/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2024-10-11T13:22:16.000Z</published>
    <updated>2024-10-13T12:48:10.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h3><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><ol><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ol><h4 id="向上层提供服务"><a href="#向上层提供服务" class="headerlink" title="向上层提供服务"></a>向上层提供服务</h4><h5 id="给普通用户用的"><a href="#给普通用户用的" class="headerlink" title="给普通用户用的"></a>给普通用户用的</h5><ol><li>GUI用户图形界面</li><li>命令接口：<ul><li>联机命令接口</li><li>脱机命令接口</li></ul></li></ol><h5 id="给软件-程序员用的"><a href="#给软件-程序员用的" class="headerlink" title="给软件&#x2F;程序员用的"></a>给软件&#x2F;程序员用的</h5><blockquote><p>程序接口，即系统调用</p></blockquote><h4 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h4><blockquote><p>扩充机器</p></blockquote><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote><p>指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。<br><strong>并行：</strong>指两个或多个事件在同一时刻同时发生。</p></blockquote><h4 id="操作系统的并发性"><a href="#操作系统的并发性" class="headerlink" title="操作系统的并发性"></a>操作系统的并发性</h4><p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上是交替运行的</p><blockquote><p><strong>单核CPU</strong>同一时刻只能执行一个程序，各个程序只能并发地执行<br><strong>多核CPU</strong>同一时刻可以同时执行多个程序，多个程序可以并行地执行</p></blockquote><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><blockquote><p>并非和共享是两个最基本的特征，二者互为存在条件</p></blockquote><blockquote><p>共享即资源共享，是指系统中地资源可供内存中多个并发执行的进程共同使用</p></blockquote><h4 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h4><h5 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h5><blockquote><p>系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源<br>如使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程</p></blockquote><h5 id="同时共享方式"><a href="#同时共享方式" class="headerlink" title="同时共享方式"></a>同时共享方式</h5><blockquote><p>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。<br>所谓的同时往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）<br>如使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的<br>也可以是真的共享，如扬声器（多个音频播放时）</p></blockquote><blockquote><p>发送文件的例子:</p><ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）<br>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义<br>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ol></blockquote><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><blockquote><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的<br>没有并发性，就谈不上虚拟性</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.13lrh1z3v2.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.13lrh1z3v2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6t73smvhea.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6t73smvhea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="空分复用技术（如虚拟存储器技术）"><a href="#空分复用技术（如虚拟存储器技术）" class="headerlink" title="空分复用技术（如虚拟存储器技术）"></a>空分复用技术（如虚拟存储器技术）</h4><h4 id="时分复用技术（如虚拟处理器）"><a href="#时分复用技术（如虚拟处理器）" class="headerlink" title="时分复用技术（如虚拟处理器）"></a>时分复用技术（如虚拟处理器）</h4><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><blockquote><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</p></blockquote><blockquote><p>失去了并发性，系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性</p></blockquote><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2krwitur68.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2krwitur68.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础概述&quot;&gt;&lt;a href=&quot;#基础概述&quot; class=&quot;headerlink&quot; title=&quot;基础概述&quot;&gt;&lt;/a&gt;基础概述&lt;/h2&gt;&lt;h3 id=&quot;功能和目标&quot;&gt;&lt;a href=&quot;#功能和目标&quot; class=&quot;headerlink&quot; title=&quot;功能和目标&quot;&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="http://tumytime.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="http://tumytime.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（三）存储系统</title>
    <link href="http://tumytime.github.io/2024/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://tumytime.github.io/2024/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-10-11T13:07:33.000Z</published>
    <updated>2024-10-11T13:20:27.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1zi8v366x0.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1zi8v366x0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><h3 id="按层次"><a href="#按层次" class="headerlink" title="按层次"></a>按层次</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2veqajmzvx.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2veqajmzvx.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="按存储介质"><a href="#按存储介质" class="headerlink" title="按存储介质"></a>按存储介质</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;存储器的层次化结构&quot;&gt;&lt;a href=&quot;#存储器的层次化结构&quot; class=&quot;headerlink&quot; title=&quot;存储器的层次化结构&quot;&gt;&lt;/a&gt;存储器的层次化结构&lt;/h2&gt;&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;im</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（二）数据基础</title>
    <link href="http://tumytime.github.io/2024/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://tumytime.github.io/2024/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-11T13:02:04.000Z</published>
    <updated>2024-10-15T12:42:39.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="其他进制转十进制"><a href="#其他进制转十进制" class="headerlink" title="其他进制转十进制"></a>其他进制转十进制</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3godzhclpl.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3godzhclpl.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="二进制与八进制、十六进制互转"><a href="#二进制与八进制、十六进制互转" class="headerlink" title="二进制与八进制、十六进制互转"></a>二进制与八进制、十六进制互转</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2h8ambjyp1.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2h8ambjyp1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="进制的表示"><a href="#进制的表示" class="headerlink" title="进制的表示"></a>进制的表示</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.64du9ulltg.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.64du9ulltg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="十进制转其他进制"><a href="#十进制转其他进制" class="headerlink" title="十进制转其他进制"></a>十进制转其他进制</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2rv4fhrl6e.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2rv4fhrl6e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1e8lbgpev0.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1e8lbgpev0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5mnsilkydf.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5mnsilkydf.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><blockquote><p>Binary-Coded Decimal使用二进制编码的十进制</p></blockquote><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lvptr8swu.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lvptr8swu.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><ul><li><strong>定义</strong>：8421码是最常用的 BCD 码（Binary-Coded Decimal，二进制编码的十进制数），是一种有权码。所谓有权码，即每一位都有固定的权值，从高到低依次为 8、4、2、1。</li><li><strong>编码方式</strong>：用 4 位二进制数来表示 1 位十进制数，0 到 9 的十进制数对应的 8421 码分别为：0 &#x3D; 0000、1 &#x3D; 0001、2 &#x3D; 0010、3 &#x3D; 0011、4 &#x3D; 0100、5 &#x3D; 0101、6 &#x3D; 0110、7 &#x3D; 0111、8 &#x3D; 1000、9 &#x3D; 1001。</li><li><strong>特点与应用</strong>：<ul><li>优点是 4 位码之间满足二进制的规律，与二进制数的转换较为直观，方便计算机对十进制数的处理和运算，在会计系统、需要高精确度计算的场景中应用广泛。</li><li>缺点是在进行加法运算时可能会出现一些不符合预期的情况，例如两个 8421 码相加结果大于 9 时需要进行修正。</li></ul></li></ul><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><ul><li><strong>定义</strong>：余 3 码是由 8421 BCD 码加上 0011 形成的一种无权码。因为它的每个字符编码比相应的 8421 码多 3，所以叫余 3 码。</li><li><strong>编码方式</strong>：比如十进制数 0 的 8421 码是 0000，那么余 3 码就是 0000 + 0011 &#x3D; 0011；十进制数 1 的 8421 码是 0001，余 3 码就是 0001 + 0011 &#x3D; 0100，以此类推。所以 0 到 9 的十进制数对应的余 3 码分别为：0 &#x3D; 0011、1 &#x3D; 0100、2 &#x3D; 0101、3 &#x3D; 0110、4 &#x3D; 0111、5 &#x3D; 1000、6 &#x3D; 1001、7 &#x3D; 1010、8 &#x3D; 1011、9 &#x3D; 1100。</li><li><strong>特点与应用</strong>：<ul><li>特点是当两个十进制数的和是 9 时，相应的余 3 码的和正好是 15，可自动产生进位信号，而不需修正；0 和 9、1 和 8 等的余 3 码互为反码，这在求对于 10 的补码时很方便。</li><li>常用于 BCD 码的运算电路中，但在运算后需要对结果进行修正，若有进位，则结果加 3；若无进位，则结果减 3。</li></ul></li></ul><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><ul><li><strong>定义</strong>：2421 码也是一种有权码，从左到右，第一位为 1 代表 2，为 0 代表 0；第二位为 1 代表 4，为 0 代表 0；第三位为 1 代表 2，为 0 代表 0；第四位为 1 代表 1，为 0 代表 0。</li><li><strong>编码方式</strong>：例如，十进制数 5 可以表示为 4 + 1，所以 5 的 2421 码为 1011；十进制数 7 可以表示为 4 + 2 + 1，所以 7 的 2421 码为 1110 等。</li><li><strong>特点与应用</strong>：2421 码是一种对 9 的自补代码，即每一个 2421 码只要与自身按位取反，便可得到该数按 9 的补数的 2421 码。这种特性使得它在一些数字电路的设计和运算中具有一定的应用价值，特别是在需要进行数字的反码运算或求补码运算的场景中。</li></ul><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6m3vyinif6.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6m3vyinif6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6bh25ddoyq.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6bh25ddoyq.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="无符号整数的加法运算"><a href="#无符号整数的加法运算" class="headerlink" title="无符号整数的加法运算"></a>无符号整数的加法运算</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9gwk4bc5ci.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9gwk4bc5ci.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="无符号整数的减法运算"><a href="#无符号整数的减法运算" class="headerlink" title="无符号整数的减法运算"></a>无符号整数的减法运算</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8s3akathf8.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8s3akathf8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7ax5iju84v.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7ax5iju84v.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5j46no4gd5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5j46no4gd5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="补码和反码"><a href="#补码和反码" class="headerlink" title="补码和反码"></a>补码和反码</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5mnsleaywx.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5mnsleaywx.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>快速计算技巧：</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1lbt708v07.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1lbt708v07.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>例子：</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4g4hcsrj9a.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4g4hcsrj9a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>补码的减法运算：</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.64du9zqebk.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.64du9zqebk.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8z6ifs9n71.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8z6ifs9n71.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="原码-反码-补码的特性对比"><a href="#原码-反码-补码的特性对比" class="headerlink" title="原码&#x2F;反码&#x2F;补码的特性对比"></a>原码&#x2F;反码&#x2F;补码的特性对比</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4g4hct7y2e.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4g4hct7y2e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="带符号整数移码表示"><a href="#带符号整数移码表示" class="headerlink" title="带符号整数移码表示"></a>带符号整数移码表示</h2><h3 id="原码-反码-补码-移码的互相转换"><a href="#原码-反码-补码-移码的互相转换" class="headerlink" title="原码&#x2F;反码&#x2F;补码&#x2F;移码的互相转换"></a>原码&#x2F;反码&#x2F;补码&#x2F;移码的互相转换</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4qrb5yrtub.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4qrb5yrtub.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.58hcujxkt5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.58hcujxkt5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="各码的特性总结"><a href="#各码的特性总结" class="headerlink" title="各码的特性总结"></a>各码的特性总结</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.eshyffn1r.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.eshyffn1r.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="用几种码表示整数"><a href="#用几种码表示整数" class="headerlink" title="用几种码表示整数"></a>用几种码表示整数</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3d4s1xp6d6.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3d4s1xp6d6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="定点小数的表示和运算"><a href="#定点小数的表示和运算" class="headerlink" title="定点小数的表示和运算"></a>定点小数的表示和运算</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进位计数制&quot;&gt;&lt;a href=&quot;#进位计数制&quot; class=&quot;headerlink&quot; title=&quot;进位计数制&quot;&gt;&lt;/a&gt;进位计数制&lt;/h2&gt;&lt;h3 id=&quot;其他进制转十进制&quot;&gt;&lt;a href=&quot;#其他进制转十进制&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（一）计算机基础</title>
    <link href="http://tumytime.github.io/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-10-10T06:52:52.000Z</published>
    <updated>2024-10-17T19:24:16.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h2><p>8位，16位，32位，64位：<br>计算机一次整数运算所能处理的二进制位数</p><h2 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>概括的来讲，冯·诺伊曼结构消除了原始计算机体系中，只能依靠硬件控制程序的状况（当时程序作为控制器的一部分，作为硬件存在），它将程序编码储存在存储器中，实现了可编程的计算机功能</p><ol><li>构成程序的指令和存储的数据均采用二进制表示</li><li>指令和数据以同等地位存放在主（内）存储器中，计算机在工作时按地址访问并执行</li><li>指令由操作码和地址码组成，每一段指令都有其地址</li><li>计算机硬件由运算器、控制器、存储器、输入设备、输出设备这五大部分组成</li><li>机器以运算器为中心，输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成</li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7i0d9optcc.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i0d9optcc.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>在冯诺依曼结构中，控制器与其他4个部件都通过控制线与反馈线相连接，控制器通过控制线发送信号控制4个部件进行工作，这些部件通过反馈线将信息反馈给控制器。控制器将用户通过输入设备输入的信息交由运算器进行运算，存储器存储输入设备输入的数据和要控制器要执行的指令，在控制的控制下也可以将存储器存储的信息交由输出设备进行输出。这样一次信息的运算（交互）在5个部件的协同配合下完成了。<br>但是这样以运算器为中心的结构中也存在一定的问题，那就是即使不需要运算器参与的输入&#x2F;输出操作时运算器也会参与进来运算，浪费了运算器性能。<br>现代计算机一般以存储器为中心，这样输入&#x2F;输出设备就可以直接与存储器交换数据，提高整体效率，如图所示。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3rb7ofzl2z.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3rb7ofzl2z.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p>CPU&#x3D;运算器+控制器</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1lbt2oy3z2.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1lbt2oy3z2.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></blockquote><h2 id="计算机各个硬件的工作原理"><a href="#计算机各个硬件的工作原理" class="headerlink" title="计算机各个硬件的工作原理"></a>计算机各个硬件的工作原理</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6wqpnet5zv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6wqpnet5zv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="存储体"><a href="#存储体" class="headerlink" title="存储体"></a>存储体</h4><p>用于存放数据，由一系列存储元件构成，可以存放二进制0或1</p><ol><li>数据在存储体内按地址存储<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.eshu3rjmq.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.eshu3rjmq.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>一个字的位数不一定是8，取决于计算机</li></ol><h4 id="MAR-Memory-Address-Register"><a href="#MAR-Memory-Address-Register" class="headerlink" title="MAR(Memory Address Register)"></a>MAR(Memory Address Register)</h4><p>存储地址寄存器</p><h4 id="MDR-Memory-Data-Register"><a href="#MDR-Memory-Data-Register" class="headerlink" title="MDR(Memory Data Register)"></a>MDR(Memory Data Register)</h4><p>存储数据寄存器</p><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p>用于实现算数运算（加减乘除）和逻辑运算（与或非）</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5q7eetnr3s.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5q7eetnr3s.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="ACC"><a href="#ACC" class="headerlink" title="ACC"></a>ACC</h4><p>累加器，用于存放操作数或运算结果</p><h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p>乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</p><h4 id="X"><a href="#X" class="headerlink" title="X"></a>X</h4><p>通用的操作数寄存器，用于存放操作数</p><h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>算数逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><p>完成一条指令：</p><ol><li>取指令：PC</li><li>分析指令：IR</li><li>执行指令：CU</li></ol><h4 id="CU"><a href="#CU" class="headerlink" title="CU"></a>CU</h4><p>控制单元，分析指令，给出控制信号</p><h4 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h4><p>指令寄存器，存放当前执行的指令</p><h4 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h4><p>程序寄存器，存放下一条指令地址，有自动+1功能</p><h3 id="计算机的控制过程"><a href="#计算机的控制过程" class="headerlink" title="计算机的控制过程"></a>计算机的控制过程</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.wijipkvpp.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.wijipkvpp.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6bh2153y7o.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6bh2153y7o.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.361k27dlre.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.361k27dlre.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5j46jesptc.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5j46jesptc.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.77djglr3f5.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.77djglr3f5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.wijiq8l4i.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.wijiq8l4i.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><ol><li>MAR的位数反应存储单元的个数（最多支持多少个）</li><li>MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</li></ol><blockquote><p>总容量&#x3D;存储单元个数*存储字长 bit<br>1Byte&#x3D;8bit</p></blockquote><p>Eg: MAR32位，MDR8位<br>$总容量&#x3D;2^{32} × 8 bit&#x3D;4GB$</p><h4 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h4><ol><li>CPU主频：CPU内数字脉冲信号振荡的频率（类似于工作处理节奏），很大程度上反映了CPU的性能<br> CPU主频&#x3D;1&#x2F;CPU时钟周期</li><li>CPI：执行一条指令所需的时钟周期数<br> 不同的指令，CPI不同。甚至相同的指令，CPI也可能不同<br> 比如说当cpu要从主存里取出一个数时，这个指令的执行除了与CPU相关，也与主存当前的状态有关，如果主存当前的负荷比较大，就可能花费更多的时间</li><li>执行一条指令的耗时&#x3D;CPI×CPU时钟周期</li><li>IPS：每秒执行多少指令<br> IPS&#x3D;主频&#x2F;平均CPI</li><li>FLOPS：每秒执行多少次浮点运算</li></ol><blockquote><p>当我们在描述存储器的容量或文件的大小：<br>$2^10:K    2^20:M    2^30:G    2^40:T$</p></blockquote><blockquote><p>当我们在描述数据的处理速率时：<br>$K:10^3    M:10^6  G:10^9  T:10^12$</p></blockquote><h4 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h4><ol><li><p>数据通路带宽：<br> 数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p></li><li><p>吞吐量：<br> 指系统在单位时间内处理请求的数量<br> 它取决与信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备</p></li><li><p>响应时间：<br> 指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等时间</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机器字长&quot;&gt;&lt;a href=&quot;#机器字长&quot; class=&quot;headerlink&quot; title=&quot;机器字长&quot;&gt;&lt;/a&gt;机器字长&lt;/h2&gt;&lt;p&gt;8位，16位，32位，64位：&lt;br&gt;计算机一次整数运算所能处理的二进制位数&lt;/p&gt;
&lt;h2 id=&quot;冯诺依曼体系结构&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="计算机组成原理" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux报错合集</title>
    <link href="http://tumytime.github.io/2024/09/30/Linux%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/"/>
    <id>http://tumytime.github.io/2024/09/30/Linux%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</id>
    <published>2024-09-30T13:18:22.000Z</published>
    <updated>2024-09-30T13:19:49.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无法定位软件包"><a href="#无法定位软件包" class="headerlink" title="无法定位软件包"></a>无法定位软件包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><blockquote><p>如果你的默认仓库没有这个软件包，你可能需要添加额外的仓库。例如，对于Ubuntu，你可以添加universe仓库，它通常包含更多的软件包</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无法定位软件包&quot;&gt;&lt;a href=&quot;#无法定位软件包&quot; class=&quot;headerlink&quot; title=&quot;无法定位软件包&quot;&gt;&lt;/a&gt;无法定位软件包&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://tumytime.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用OpenCV写UI界面</title>
    <link href="http://tumytime.github.io/2024/09/27/%E7%94%A8OpenCV%E5%86%99UI%E7%95%8C%E9%9D%A2/"/>
    <id>http://tumytime.github.io/2024/09/27/%E7%94%A8OpenCV%E5%86%99UI%E7%95%8C%E9%9D%A2/</id>
    <published>2024-09-27T13:29:55.000Z</published>
    <updated>2024-09-30T11:34:54.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前电赛队友的物理按钮不够了，为了方便快捷，就用了这个，好用，就是运行时间长了可能失效(在树莓派5上当时使用的时候是这样)</p></blockquote><div class="tagLink"><a class="link-card" title="cvui" href="https://fernandobevilacqua.com/cvui/"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">cvui</p><p class="url">https://fernandobevilacqua.com/cvui/</p></div></a></div><div class="tagLink"><a class="link-card" title="cvui的github仓库地址" href="https://github.com/Dovyski/cvui/releases/tag/v2.7.0"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/1b83b88d3cf497d2d322e0fc1cdc77e.3uusmgziev.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">cvui的github仓库地址</p><p class="url">https://github.com/Dovyski/cvui/releases/tag/v2.7.0</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前电赛队友的物理按钮不够了，为了方便快捷，就用了这个，好用，就是运行时间长了可能失效(在树莓派5上当时使用的时候是这样)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; ti</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="opencv" scheme="http://tumytime.github.io/tags/opencv/"/>
    
    <category term="UI" scheme="http://tumytime.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>【Jetson-Nano学习笔记】Jetson_Inference</title>
    <link href="http://tumytime.github.io/2024/09/24/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91py%E7%89%88Jetson-Inference/"/>
    <id>http://tumytime.github.io/2024/09/24/%E3%80%90Jetson-Nano%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91py%E7%89%88Jetson-Inference/</id>
    <published>2024-09-24T09:38:47.000Z</published>
    <updated>2024-09-24T10:03:17.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人体姿态检测的网络模型加载脚本"><a href="#人体姿态检测的网络模型加载脚本" class="headerlink" title="人体姿态检测的网络模型加载脚本"></a>人体姿态检测的网络模型加载脚本</h2><details open><summary pointer> posenet.py </summary>              <div class='content'>              <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Permission is hereby granted, free of charge, to any person obtaining a</span></span><br><span class="line"><span class="comment"># copy of this software and associated documentation files (the &quot;Software&quot;),</span></span><br><span class="line"><span class="comment"># to deal in the Software without restriction, including without limitation</span></span><br><span class="line"><span class="comment"># the rights to use, copy, modify, merge, publish, distribute, sublicense,</span></span><br><span class="line"><span class="comment"># and/or sell copies of the Software, and to permit persons to whom the</span></span><br><span class="line"><span class="comment"># Software is furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"># all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span></span><br><span class="line"><span class="comment"># THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span></span><br><span class="line"><span class="comment"># DEALINGS IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jetson_inference <span class="keyword">import</span> poseNet</span><br><span class="line"><span class="keyword">from</span> jetson_utils <span class="keyword">import</span> videoSource, videoOutput, Log</span><br><span class="line"></span><br><span class="line"><span class="comment"># parse the command line</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;Run pose estimation DNN on a video/image stream.&quot;</span>, </span><br><span class="line">                                 formatter_class=argparse.RawTextHelpFormatter, </span><br><span class="line">                                 epilog=poseNet.Usage() + videoSource.Usage() + videoOutput.Usage() + Log.Usage())</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&quot;input&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;&quot;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;URI of the input stream&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;output&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;&quot;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;URI of the output stream&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--network&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;resnet18-body&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;pre-trained model to load (see below for options)&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--overlay&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;links,keypoints&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;pose overlay flags (e.g. --overlay=links,keypoints)\nvalid combinations are:  &#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--threshold&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.15</span>, <span class="built_in">help</span>=<span class="string">&quot;minimum detection threshold to use&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">args = parser.parse_known_args()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">parser.print_help()</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load the pose estimation model</span></span><br><span class="line">net = poseNet(args.network, sys.argv, args.threshold)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create video sources &amp; outputs</span></span><br><span class="line"><span class="built_in">input</span> = videoSource(args.<span class="built_in">input</span>, argv=sys.argv)</span><br><span class="line">output = videoOutput(args.output, argv=sys.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process frames until EOS or the user exits</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># capture the next image</span></span><br><span class="line">    img = <span class="built_in">input</span>.Capture()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># timeout</span></span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform pose estimation (with overlay)</span></span><br><span class="line">    poses = net.Process(img, overlay=args.overlay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print the pose results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;detected &#123;:d&#125; objects in image&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(poses)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pose <span class="keyword">in</span> poses:</span><br><span class="line">        <span class="built_in">print</span>(pose)</span><br><span class="line">        <span class="built_in">print</span>(pose.Keypoints)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Links&#x27;</span>, pose.Links)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># render the image</span></span><br><span class="line">    output.Render(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the title bar</span></span><br><span class="line">    output.SetStatus(<span class="string">&quot;&#123;:s&#125; | Network &#123;:.0f&#125; FPS&quot;</span>.<span class="built_in">format</span>(args.network, net.GetNetworkFPS()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print out performance info</span></span><br><span class="line">    net.PrintProfilerTimes()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># exit on input/output EOS</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">input</span>.IsStreaming() <span class="keyword">or</span> <span class="keyword">not</span> output.IsStreaming():</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>当然，以下是关于 <code>sys</code> 模块以及 <code>sys.exit(0)</code> 和 <code>sys.argv</code> 的详细解释：</p><h4 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a><code>sys</code> 模块</h4><p><code>sys</code> 是 Python 的一个内置模块，它提供了对解释器使用或维护的某些变量的访问，以及与解释器强烈相关的函数。这个模块包含了与 Python 解释器及其环境操作相关的功能。<br>以下是一些 <code>sys</code> 模块提供的常见功能：</p><ul><li>访问命令行参数 (<code>sys.argv</code>)</li><li>控制解释器行为（例如，<code>sys.exit()</code>）</li><li>访问系统特定的参数和函数（例如，<code>sys.platform</code>）</li><li>捕获和处理异常（例如，<code>sys.exc_info()</code>）</li></ul><h4 id="sys-exit-arg"><a href="#sys-exit-arg" class="headerlink" title="sys.exit([arg])"></a><code>sys.exit([arg])</code></h4><p><code>sys.exit()</code> 是一个函数，用于从 Python 程序中退出。当你调用 <code>sys.exit()</code> 时，它会引发一个 <code>SystemExit</code> 异常。这个异常可以通过代码捕获，如果不被捕获，则会终止程序。<br>参数 <code>arg</code> 可以是以下之一：</p><ul><li>如果没有提供参数或参数为 <code>None</code>，则退出代码默认为 <code>0</code>，表示正常退出。</li><li>如果提供了整数，则该整数将用作退出代码返回给调用环境。通常，退出代码 <code>0</code> 表示成功，非零值表示错误或特定类型的错误。<br>在示例代码中，<code>sys.exit(0)</code> 用于在解析命令行参数失败时退出程序，返回代码 <code>0</code> 表示正常退出。</li></ul><h4 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a><code>sys.argv</code></h4><p><code>sys.argv</code> 是一个列表，包含了命令行传递给 Python 脚本的参数。<code>argv</code> 是 “argument vector” 的缩写，它通常包含以下内容：</p><ul><li><code>sys.argv[0]</code>：脚本的名称（作为执行命令的一部分）。</li><li><code>sys.argv[1]</code>：第一个命令行参数。</li><li><code>sys.argv[2]</code>：第二个命令行参数。</li><li>…以此类推。<br>例如，如果你从命令行运行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py arg1 arg2 arg3</span><br></pre></td></tr></table></figure>那么 <code>sys.argv</code> 将会是这样的列表：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;script.py&#x27;</span>, <span class="string">&#x27;arg1&#x27;</span>, <span class="string">&#x27;arg2&#x27;</span>, <span class="string">&#x27;arg3&#x27;</span>]</span><br></pre></td></tr></table></figure>在示例代码中，<code>sys.argv</code> 被传递给 <code>argparse</code> 解析器，以便它可以解析脚本名称后面的所有命令行参数。此外，<code>sys.argv</code> 也被传递给 <code>videoSource</code> 和 <code>videoOutput</code>，这样它们就可以处理传递给它们的任何额外参数。</li></ul><h3 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h3><p><code>argparse</code> 是 Python 标准库中的一个模块，它提供了一个方便的方式来解析命令行参数。这个模块使得编写用户友好的命令行接口变得简单。下面是关于 <code>argparse</code> 的详细解释：</p><h4 id="为什么要使用-argparse？"><a href="#为什么要使用-argparse？" class="headerlink" title="为什么要使用 argparse？"></a>为什么要使用 <code>argparse</code>？</h4><p>在命令行工具和脚本中，经常需要处理用户输入的参数。在没有 <code>argparse</code> 之前，开发者通常会使用 <code>sys.argv</code> 直接处理这些参数，但这种方法在参数类型多样、参数数量较多或者需要帮助信息和错误处理时变得复杂。<code>argparse</code> 模块提供以下功能：</p><ul><li>自动生成帮助信息和使用说明。</li><li>支持不同类型的参数（如整数、浮点数、布尔值等）。</li><li>支持默认值。</li><li>生成错误信息并处理非法输入。</li></ul><h4 id="argparse-基础使用"><a href="#argparse-基础使用" class="headerlink" title="argparse 基础使用"></a><code>argparse</code> 基础使用</h4><p>以下是使用 <code>argparse</code> 的基本步骤：</p><ol><li><strong>导入模块</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure></li><li><strong>创建解析器</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some integers.&#x27;</span>)</span><br></pre></td></tr></table></figure>这里 <code>description</code> 参数是可选的，但建议提供，因为它会在帮助信息中显示。</li><li><strong>添加参数</strong>：<br>使用 <code>add_argument()</code> 方法添加参数。例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;an integer for the accumulator&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sum&#x27;</span>, dest=<span class="string">&#x27;accumulate&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>,</span><br><span class="line">                    const=<span class="built_in">sum</span>, default=<span class="built_in">max</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;sum the integers (default: find the max)&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>&#39;integers&#39;</code> 是参数的名字，它在命令行中使用。</li><li><code>metavar=&#39;N&#39;</code> 定义了在帮助信息中显示的参数名。</li><li><code>type=int</code> 指定了参数应该被转换为整数。</li><li><code>nargs=&#39;+&#39;</code> 表示这个参数可以接收一个或多个值。</li><li><code>help=&#39;...&#39;</code> 提供了关于参数的简要说明。</li></ul></li><li><strong>解析参数</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>这将处理命令行参数并返回一个包含所有参数值的 <code>Namespace</code> 对象。</li><li><strong>使用参数</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure>在这个例子中，<code>args.integers</code> 包含了所有提供的整数，<code>args.accumulate</code> 是一个函数（<code>sum</code> 或 <code>max</code>），它将被应用到这些整数上。</li></ol><h4 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h4><p><code>argparse</code> 还提供了许多高级功能，比如：</p><ul><li><strong>子命令</strong>：可以为程序定义多个子命令，每个子命令有自己的参数。</li><li><strong>互斥组</strong>：使用 <code>argparse</code> 的 <code>add_mutually_exclusive_group()</code> 方法可以创建一组参数，它们之间是互斥的。</li><li><strong>自定义动作</strong>：可以定义自定义动作来处理特定的参数。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的 <code>argparse</code> 使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 创建解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;示例脚本&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;filename&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;文件名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--verbose&#x27;</span>, <span class="string">&#x27;-v&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;详细输出&#x27;</span>)</span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># 使用参数</span></span><br><span class="line"><span class="keyword">if</span> args.verbose:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;处理文件：<span class="subst">&#123;args.filename&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在命令行中，你可以这样调用这个脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py example.txt --verbose</span><br></pre></td></tr></table></figure><p>或者使用简写形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py example.txt -v</span><br></pre></td></tr></table></figure><p><code>argparse</code> 模块功能强大，能够帮助开发者快速构建出健壮、用户友好的命令行工具。</p><h4 id="argparse-解析器配置"><a href="#argparse-解析器配置" class="headerlink" title="argparse 解析器配置"></a><code>argparse</code> 解析器配置</h4><p>以下是对提供的 <code>argparse</code> 解析器配置的详细中文解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 ArgumentParser 对象，用于解析命令行参数。</span></span><br><span class="line"><span class="comment"># ArgumentParser 的参数描述如下：</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">&quot;Run pose estimation DNN on a video/image stream.&quot;</span>,  <span class="comment"># 描述：这个脚本运行在视频/图像流上的姿态估计深度神经网络。</span></span><br><span class="line">    formatter_class=argparse.RawTextHelpFormatter,  <span class="comment"># 格式化类：使用 RawTextHelpFormatter 以保持帮助信息的原始文本格式。</span></span><br><span class="line">    epilog=poseNet.Usage() + videoSource.Usage() + videoOutput.Usage() + Log.Usage()  <span class="comment"># 结尾信息：显示 poseNet、videoSource、videoOutput 和 Log 的使用说明。</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 添加命令行参数，每个 add_argument 方法的参数解释如下：</span></span><br><span class="line"><span class="comment"># 输入流参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;input&quot;</span>,  <span class="comment"># 参数名：input</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;&quot;</span>,  <span class="comment"># 默认值：空字符串</span></span><br><span class="line">    nargs=<span class="string">&#x27;?&#x27;</span>,  <span class="comment"># 参数数量：0或1个，即这个参数是可选的</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;URI of the input stream&quot;</span>  <span class="comment"># 帮助信息：输入流的统一资源标识符（URI）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 输出流参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;output&quot;</span>,  <span class="comment"># 参数名：output</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;&quot;</span>,  <span class="comment"># 默认值：空字符串</span></span><br><span class="line">    nargs=<span class="string">&#x27;?&#x27;</span>,  <span class="comment"># 参数数量：0或1个，即这个参数是可选的</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;URI of the output stream&quot;</span>  <span class="comment"># 帮助信息：输出流的统一资源标识符（URI）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 网络模型参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--network&quot;</span>,  <span class="comment"># 参数名：network，前缀 &#x27;--&#x27; 表示这是一个可选参数</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;resnet18-body&quot;</span>,  <span class="comment"># 默认值：&quot;resnet18-body&quot;</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;pre-trained model to load (see below for options)&quot;</span>  <span class="comment"># 帮助信息：要加载的预训练模型（请参阅下面的选项）</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 覆盖层参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--overlay&quot;</span>,  <span class="comment"># 参数名：overlay</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">str</span>,  <span class="comment"># 参数类型：字符串</span></span><br><span class="line">    default=<span class="string">&quot;links,keypoints&quot;</span>,  <span class="comment"># 默认值：&quot;links,keypoints&quot;</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;&quot;&quot;pose overlay flags (e.g. --overlay=links,keypoints)</span></span><br><span class="line"><span class="string">valid combinations are: &#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;&quot;&quot;&quot;</span>  <span class="comment"># 帮助信息：姿态覆盖标志（例如：--overlay=links,keypoints）</span></span><br><span class="line">    <span class="comment"># 合法的组合有：&#x27;links&#x27;, &#x27;keypoints&#x27;, &#x27;boxes&#x27;, &#x27;none&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 阈值参数</span></span><br><span class="line">parser.add_argument(</span><br><span class="line">    <span class="string">&quot;--threshold&quot;</span>,  <span class="comment"># 参数名：threshold</span></span><br><span class="line">    <span class="built_in">type</span>=<span class="built_in">float</span>,  <span class="comment"># 参数类型：浮点数</span></span><br><span class="line">    default=<span class="number">0.15</span>,  <span class="comment"># 默认值：0.15</span></span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;minimum detection threshold to use&quot;</span>  <span class="comment"># 帮助信息：要使用的最小检测阈值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个配置为脚本定义了一系列命令行参数，用户可以通过这些参数来控制脚本的运行行为。以下是对每个参数的详细解释：</p><ul><li><code>input</code>：这是一个位置参数，用户必须提供输入流的URI，如果没有提供，则默认为空字符串。这个参数用于指定要处理的视频或图像流的来源。</li><li><code>output</code>：这也是一个位置参数，用户可以提供输出流的URI，如果没有提供，则默认为空字符串。这个参数用于指定处理后的视频或图像流的目的地。</li><li><code>--network</code>：这是一个可选参数，用于指定要加载的预训练模型。用户可以通过这个参数选择不同的网络模型来执行姿态估计。</li><li><code>--overlay</code>：这是一个可选参数，用于指定在输出流上要显示的姿态覆盖层。用户可以选择显示链接、关键点、边界框或者不显示任何覆盖层。</li><li><code>--threshold</code>：这是一个可选参数，用于设置检测姿态的最小阈值。只有当检测置信度高于这个阈值时，姿态才会被识别和显示。<br>用户可以在命令行中按照以下格式提供这些参数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py input_stream_uri output_stream_uri --network model_name --overlay <span class="built_in">type</span> --threshold value</span><br></pre></td></tr></table></figure>其中 <code>input_stream_uri</code> 和 <code>output_stream_uri</code> 是必须提供的，其他参数根据需要选择性地提供。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;人体姿态检测的网络模型加载脚本&quot;&gt;&lt;a href=&quot;#人体姿态检测的网络模型加载脚本&quot; class=&quot;headerlink&quot; title=&quot;人体姿态检测的网络模型加载脚本&quot;&gt;&lt;/a&gt;人体姿态检测的网络模型加载脚本&lt;/h2&gt;&lt;details open&gt;&lt;summar</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/tags/Jetson-Nano/"/>
    
  </entry>
  
  <entry>
    <title>Linux嵌入式QT开发</title>
    <link href="http://tumytime.github.io/2024/09/19/Linux%E5%B5%8C%E5%85%A5%E5%BC%8FQT%E5%BC%80%E5%8F%91/"/>
    <id>http://tumytime.github.io/2024/09/19/Linux%E5%B5%8C%E5%85%A5%E5%BC%8FQT%E5%BC%80%E5%8F%91/</id>
    <published>2024-09-19T12:26:36.000Z</published>
    <updated>2024-10-10T13:31:22.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;小狗的名字是:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="string">&quot;年龄是:&quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dog dog1;</span><br><span class="line"></span><br><span class="line">    dog1.name=<span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">    dog1.age=<span class="number">2</span>;</span><br><span class="line">    dog1.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    Dog *dog2 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == dog2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dog2-&gt;name=<span class="string">&quot;富贵&quot;</span>;</span><br><span class="line">    dog2-&gt;age=<span class="number">1</span>;</span><br><span class="line">    dog2-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> dog2;</span><br><span class="line">    dog2=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="栈上创建-dog1"><a href="#栈上创建-dog1" class="headerlink" title="栈上创建 (dog1)"></a>栈上创建 (<code>dog1</code>)</h4><p><strong>解释：</strong></p><ol><li><strong>声明和定义：</strong> <code>Dog dog1;</code> 在栈上声明并定义了一个<code>Dog</code>类型的对象<code>dog1</code>。栈上的对象在定义它的作用域结束时自动销毁。</li><li><strong>成员赋值：</strong> 通过点操作符<code>.</code>，您可以访问和修改<code>dog1</code>对象的公共成员变量<code>name</code>和<code>age</code>。</li><li><strong>调用成员函数：</strong> <code>dog1.run();</code> 调用了<code>dog1</code>对象的<code>run</code>成员函数，输出小狗的名字和年龄。</li><li><strong>生命周期：</strong> 当<code>main</code>函数执行完毕，<code>dog1</code>对象的生命周期结束，它的析构函数（如果有的话）将被调用，释放它所占用的资源。</li></ol><h4 id="堆上创建-dog2"><a href="#堆上创建-dog2" class="headerlink" title="堆上创建 (dog2)"></a>堆上创建 (<code>dog2</code>)</h4><p><strong>解释：</strong></p><ol><li><strong>动态分配：</strong> <code>Dog *dog2 = new Dog();</code> 使用<code>new</code>关键字在堆上动态分配了一个<code>Dog</code>类型的对象，并返回了这个对象的指针。指针<code>dog2</code>存储了对象在内存中的地址。</li><li><strong>成员赋值：</strong> 由于<code>dog2</code>是一个指针，您需要使用箭头操作符<code>-&gt;</code>来访问对象的成员变量。</li><li><strong>调用成员函数：</strong> 同样使用箭头操作符<code>-&gt;</code>来调用<code>dog2</code>指向的对象的成员函数。</li><li><strong>手动管理生命周期：</strong> 在堆上分配的对象不会自动销毁，需要程序员手动管理。使用<code>delete dog2;</code>来释放<code>dog2</code>指向的内存，防止内存泄漏。之后，将<code>dog2</code>设置为<code>NULL</code>是一个好习惯，这样可以避免悬空指针的问题，即避免使用已经释放的内存。<br> <strong>总结</strong></li></ol><ul><li><strong>栈上创建</strong>的对象生命周期由编译器管理，简单且安全，但栈空间有限，不适合创建大量或大对象。</li><li><strong>堆上创建</strong>的对象生命周期由程序员管理，提供了更大的灵活性，但需要手动释放内存，容易出错（如忘记释放或重复释放内存）。<br>两种方式的选择取决于具体的应用场景和性能要求。在大多数情况下，简单的对象可以使用栈分配，而复杂或大量对象则适合使用堆分配。</li></ul><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><blockquote><p>属于特殊的成员函数</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote><p>构造函数在对象实例化时被系统自动调用，仅调用一次。定义类时，如果没有定义构造函数和析构函数，编译器就会生成一个构造函数和析构函数，只是这个构造函数和析构函数什么事情也不做。</p></blockquote><blockquote><p>构造函数的特点如下:</p><ol><li>构造函数必须与类名同名</li><li>可以重载</li><li>没有返回类型，即使是void也不行</li></ol></blockquote><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><blockquote><p>与构造函数相反，在对象结束其生命周期时系统自动执行析构函数。实际上定义类时，编译器会生成一个析构函数</p></blockquote><blockquote><p>析构函数的特点如下:</p><ol><li>析构函数的格式为~类名()</li><li>调用时释放内存(资源)</li><li>~类名()不能加参数</li><li>没有返回值，即使是void也不行</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Dog</span>();</span><br><span class="line">~<span class="built_in">Dog</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数与析构函数示例&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::<span class="built_in">Dog</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::~<span class="built_in">Dog</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果:</strong><br>构造函数执行！<br>构造函数与析构函数示例<br>析构函数执行！</p><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>在 C++ 中，对象的生命周期指的是对象从创建到销毁的整个过程。生命周期结束意味着对象不再存在，其占用的内存将被回收，并且与该对象相关的资源（如打开的文件句柄、网络连接等）也将被释放。以下是详细说明：</p><h4 id="对象生命周期的几个阶段："><a href="#对象生命周期的几个阶段：" class="headerlink" title="对象生命周期的几个阶段："></a>对象生命周期的几个阶段：</h4><ol><li><strong>创建（Construction）</strong>：<ul><li>当对象被创建时，其生命周期开始。这可以通过多种方式完成，例如在栈上声明、在堆上使用 <code>new</code> 分配或者在全局&#x2F;静态存储区中声明。</li></ul></li><li><strong>存在（Existence）</strong>：<ul><li>在这个阶段，对象是有效的，可以访问其成员变量和调用成员函数。</li></ul></li><li><strong>销毁（Destruction）</strong>：<ul><li>对象的生命周期结束，通常由以下情况触发：<ul><li>栈上的局部对象：当包含它们的代码块（如函数体）结束时。</li><li>堆上的对象：当使用 <code>delete</code> 操作符显式释放它们时。</li><li>全局&#x2F;静态对象：当程序结束时。</li></ul></li></ul></li></ol><h4 id="生命周期结束的具体含义："><a href="#生命周期结束的具体含义：" class="headerlink" title="生命周期结束的具体含义："></a>生命周期结束的具体含义：</h4><ul><li><strong>栈对象</strong>：<ul><li>对于在栈上创建的对象，当它们离开作用域（例如，函数返回）时，它们的析构函数（如果有的话）会被自动调用，随后对象占用的内存将被回收。</li></ul></li><li><strong>堆对象</strong>：<ul><li>对于在堆上创建的对象，必须使用 <code>delete</code> 操作符来显式结束其生命周期。当 <code>delete</code> 被调用时，对象的析构函数会被执行，然后对象占用的内存被回收。</li></ul></li><li><strong>全局&#x2F;静态对象</strong>：<ul><li>全局或静态对象的析构函数会在程序结束时自动调用。</li></ul></li></ul><h4 id="生命周期结束后的行为："><a href="#生命周期结束后的行为：" class="headerlink" title="生命周期结束后的行为："></a>生命周期结束后的行为：</h4><ul><li><strong>成员变量</strong>：<ul><li>对象的成员变量所占用的内存也随之释放。</li></ul></li><li><strong>资源管理</strong>：<ul><li>如果对象负责管理资源（如动态分配的内存、文件句柄等），则其析构函数通常会负责释放这些资源。</li></ul></li><li><strong>引用或指针</strong>：<ul><li>如果有其他变量（如引用或指针）指向该对象，那么这些变量将变成悬空引用或悬空指针，继续使用它们将导致未定义行为。<br>理解对象的生命周期对于编写高效且无内存泄漏的 C++ 程序至关重要。正确管理对象的生命周期可以帮助避免许多常见的编程错误，如内存泄漏、悬挂指针和资源泄露。</li></ul></li></ul><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>一个类的不同对象在调用自己的成员函数时，其实他们调用的是同一段函数代码，那么成员函数如何知道要访问哪个对象的数据成员呢？</p><p>没错，就是通过this指针。每个对象都有一个this指针，this指针记录对象的内存地址。在C++中，this指针是指向类自身数据的指针，简单的来说就是指向当前类的当前实例对象。</p><p>关于类的this指针有以下特点:</p><ol><li>this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为T *const this。也就是一个类里面的成员函数int func(int p),func的原型在编译器看来应该是int func(T *const this,int p)</li><li>this在成员函数的开始前构造，在成员函数的结束后清除</li><li>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好，我是&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> string&amp; newName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = newName; <span class="comment">// 使用this指针更新当前实例的name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个Person实例</span></span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">person2</span><span class="params">(<span class="string">&quot;李四&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用greet方法，通过this指针输出各自的名字</span></span><br><span class="line">    person1.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是张三。</span></span><br><span class="line">    person2.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是李四。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改person1的名字，并再次调用greet方法</span></span><br><span class="line">    person1.<span class="built_in">rename</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    person1.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是王五。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改person2的名字，并再次调用greet方法</span></span><br><span class="line">    person2.<span class="built_in">rename</span>(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    person2.<span class="built_in">greet</span>(); <span class="comment">// 输出: 你好，我是赵六。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，<code>Person(const string&amp; name) : name(name) &#123;&#125;</code> 是一个类 <code>Person</code> 的构造函数的定义，使用了初始化列表来初始化成员变量。<br>让我们分解这个构造函数：</p><ul><li><code>Person(const string&amp; name)</code>：这是构造函数的声明，它接受一个 <code>const string&amp;</code> 类型的参数 <code>name</code>。使用 <code>const string&amp;</code> 是一种引用传递的方式，这样可以避免不必要的字符串拷贝，并且保证传递的字符串在函数内部不会被修改。</li><li><code>: name(name)</code>：这是构造函数的初始化列表部分。在这里，<code>name(name)</code> 表示将构造函数的参数 <code>name</code> 的值传递给类的成员变量 <code>name</code>。在初始化列表中，<code>name</code> 出现了两次，第一个 <code>name</code> 是成员变量的名字，第二个 <code>name</code> 是构造函数参数的名字。这种写法有时会导致一些混淆，但它是在告诉编译器，将传入的 <code>name</code> 参数的值赋给成员变量 <code>name</code>。</li><li><code>&#123;&#125;</code>：这是构造函数的函数体。在这个例子中，函数体是空的，因为所有的初始化工作已经在初始化列表中完成了。<br>综上所述，这个构造函数的作用是创建一个 <code>Person</code> 对象，并将其 <code>name</code> 成员变量初始化为传入的参数值。使用初始化列表是一种效率较高的初始化成员变量的方式，特别是当成员变量是引用或常量时，它必须在构造函数体执行之前被初始化。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。在QT里大量的使用了这种特性，当QT里的类不满足自己的要求是，我们可以重写这个类，就是通过继承需要重写的类，来实现自己的类的功能。</p><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>与类的访问修饰限定符一样，继承的方式也有几种。其中，访问修饰符<code>access-specifier</code>是public、protect或private其中的一个，base-class是之前定义过的某个类的名称。如果未使用访问修饰符<code>access-specifier</code>，则默认为private。</p><h3 id="公有继承public"><a href="#公有继承public" class="headerlink" title="公有继承public"></a>公有继承public</h3><p>当一个类派生继承公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问</p><h3 id="保护继承protected"><a href="#保护继承protected" class="headerlink" title="保护继承protected"></a>保护继承protected</h3><p>当一个类派生继承保护基类时，基类的公有和保护成员将成为派生类的保护成员</p><h3 id="私有继承private"><a href="#私有继承private" class="headerlink" title="私有继承private"></a>私有继承private</h3><p>当一个类派生继承私有基类时，基类的公有和保护成员将成为派生类的私有成员</p><p>在面向对象的编程语言中，如 C++，类成员可以被指定为公有（public）、保护（protected）或私有（private），这些关键字用于实现封装，即控制类成员的访问权限。以下是这三种成员的详细解释：<br><strong>公有成员（Public Members）</strong><br>公有成员是在类定义中使用 <code>public</code> 关键字声明的成员。公有成员可以被类的对象直接访问，也可以被类的外部函数访问。</p><ul><li><strong>特点</strong>：<ul><li>可以被类的任何对象访问。</li><li>可以在类的外部通过对象直接访问。</li><li>通常包含类的接口，即那些用于与类交互的函数和属性。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>setName</code> 和 <code>getName</code> 是公有成员函数，它们可以被任何 <code>Person</code> 类的对象调用。<br><strong>保护成员（Protected Members）</strong><br>保护成员是在类定义中使用 <code>protected</code> 关键字声明的成员。保护成员的行为类似于私有成员，但它们可以被派生类访问。</li><li><strong>特点</strong>：<ul><li>不能被类的对象直接访问。</li><li>可以被类的成员函数访问。</li><li>可以被派生类（子类）的成员函数访问。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProtectedData</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        protectedData = data; <span class="comment">// 在派生类中可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>protectedData</code> 是保护成员，它不能被 <code>Base</code> 类的对象直接访问，但可以在 <code>Derived</code> 类的成员函数 <code>setProtectedData</code> 中访问。<br><strong>私有成员（Private Members）</strong><br>私有成员是在类定义中使用 <code>private</code> 关键字声明的成员。私有成员只能被类的成员函数访问，不能被类的对象或类的外部函数直接访问。</li><li><strong>特点</strong>：<ul><li>不能被类的对象直接访问。</li><li>可以被类的成员函数访问。</li><li>不能被派生类访问，除非通过基类的公有或保护成员函数。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> newAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newAge &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            age = newAge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在这个例子中，<code>age</code> 是私有成员，它不能被 <code>Person</code> 类的对象直接访问，但可以通过公有成员函数 <code>setAge</code> 和 <code>getAge</code> 来设置和获取。<br>通过使用公有、保护和私有成员，C++ 类可以隐藏其内部实现细节，只暴露必要的接口，这是面向对象编程中的一个重要原则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">animal</span> &#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">string color;</span><br><span class="line"></span><br><span class="line">&#125;animal;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.age = <span class="number">2</span>;</span><br><span class="line">dog.animal.color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">dog.animal.weight = <span class="number">120</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;名字:&quot;</span> &lt;&lt; dog.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; dog.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;颜色:&quot;</span> &lt;&lt; dog.animal.color &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;体重:&quot;</span> &lt;&lt; dog.animal.weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<code>函数重载</code>和<code>运算符重载</code></p><p>重载声明是指一个与之前已经在该作用域声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义(实现)不相同</p><p>当调用时，编译器通过使用的参数类型和定义中的参数类型进行比较。决定选用最合适的定义，这个过程称为<code>重载决策</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数必须不同。我们不能仅通过返回类型的不同来重载函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的体重是:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;kG&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getWeight</span><span class="params">(<span class="type">double</span> weight)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的体重是:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;kG&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.<span class="built_in">getWeight</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="built_in">getWeight</span>(<span class="number">10.5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免用户传入的参数类型不在我们写的重载函数里，还可以多写几个类型的</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的C++多态。要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式:operatorp(argument-list),operator后面的<code>p</code>为要重载的运算符符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt;<span class="built_in">operator</span>&lt;运算符符号&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">Dog <span class="keyword">operator</span>+(<span class="type">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.weight = <span class="keyword">this</span>-&gt;weight + d;</span><br><span class="line"><span class="keyword">return</span> dog;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Dog dog1;</span><br><span class="line">Dog dog2;</span><br><span class="line">Dog dog3;</span><br><span class="line"></span><br><span class="line">dog1.weight = <span class="number">10</span>;</span><br><span class="line">dog2.weight = <span class="number">20</span>;</span><br><span class="line">dog3 = dog1 + <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三只狗的体重:&quot;</span> &lt;&lt; dog3.weight &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；<br>形成多态必须具备三个条件:</p><ol><li>必须存在继承关系</li><li>继承关系必须有同名虚函数(其中虚函数是在基类中使用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数)</li><li>存在基类类型的指针或引用，通过该指针或引用调用虚函数</li></ol><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。虚函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span></span></span><br></pre></td></tr></table></figure><p>虚函数必须实现。如果不实现，编译器将报错</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>若在基类中定义虚函数，以便在派生类中重新定义改函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。纯虚函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向该抽象类的具体类的指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Dog的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat的run()方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal;</span><br><span class="line">Dog dog;</span><br><span class="line">Cat cat;</span><br><span class="line"></span><br><span class="line">animal = &amp;dog;</span><br><span class="line">animal-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">animal = &amp;cat;</span><br><span class="line">animal-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受外界的干扰和误用，从而保证了安全。数据封装引申出了另一个重要的OOP概念，即数据隐藏。<br>数据封装是一种把数据和操作数据的函数绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，C++通过创建类来支持封装和数据隐藏(public、protected、private)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">total = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addFood</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">total = total + number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line"></span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line"></span><br><span class="line">dog.<span class="built_in">addFood</span>(<span class="number">3</span>);</span><br><span class="line">dog.<span class="built_in">addFood</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dog.name &lt;&lt; <span class="string">&quot;总共获得了&quot;</span> &lt;&lt; dog.<span class="built_in">getFood</span>() &lt;&lt; <span class="string">&quot;份食物&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="QT" scheme="http://tumytime.github.io/categories/QT/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="QT" scheme="http://tumytime.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>智能台灯</title>
    <link href="http://tumytime.github.io/2024/09/18/%E6%99%BA%E8%83%BD%E5%8F%B0%E7%81%AF/"/>
    <id>http://tumytime.github.io/2024/09/18/%E6%99%BA%E8%83%BD%E5%8F%B0%E7%81%AF/</id>
    <published>2024-09-18T13:29:31.000Z</published>
    <updated>2024-10-03T16:33:20.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jetson Nano引脚图<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6m3v0bkaa5.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6m3v0bkaa5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></p></blockquote><blockquote><p>本来想在jetson nano上跑一个live2d，但是live2d官方编译好的链接库对于linux只有x86_64的版本，我又没找到怎么重新编译，然后就想到也许live2d在windows的电脑上跑然后和jetson nano主控进行一个交互也许更有意思（例如点击什么的会有灯光特效）就有点像对于一个桌宠有了灯光外设</p></blockquote><blockquote><p>现在的方案是，主控全部使用Jetson Nano，虽然因为机箱的拓展板把所有Jetson Nano的IO口都占了，所以有关检测光照强度的任务就不使用光照传感器了，直接使用opencv检测光照强度，虽然不精准，但是在大的范围，比如说在实验室测试的开关灯，还是可以大致检测出来的。</p></blockquote><blockquote><p>然后就是用QT写界面，现在已经有了一个大致的带滑动转换界面的一个Demo，可以魔改</p></blockquote><blockquote><p>然后人与桌面距离检测的方案就是，AI部分使用Jetson Inferenced的人体关键点检测（主要用到的就是人脸关键点和肩膀位置的关键点），精准距离检测方案就是假设人的眼距是大致相同的（取一个标准值），然后根据鼻子到脖子中间拉的一条线的斜率得出人体相对摄像头的旋转角度，计算出这个旋转角度下人的平面眼距的绝对值，然后和图片里的眼距长度对比，从而判断出人距离摄像头的距离，</p></blockquote><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Jetson Nano引脚图&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img lazyload placeholder&quot; src=&quot;https://tumytime.github.i</summary>
      
    
    
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/categories/Jetson-Nano/"/>
    
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="Jetson Nano" scheme="http://tumytime.github.io/tags/Jetson-Nano/"/>
    
  </entry>
  
  <entry>
    <title>【李飞飞的AI课】Introduction to Convolut</title>
    <link href="http://tumytime.github.io/2024/09/16/%E3%80%90%E6%9D%8E%E9%A3%9E%E9%A3%9E%E7%9A%84AI%E8%AF%BE%E3%80%91Introduction-to-Convolut/"/>
    <id>http://tumytime.github.io/2024/09/16/%E3%80%90%E6%9D%8E%E9%A3%9E%E9%A3%9E%E7%9A%84AI%E8%AF%BE%E3%80%91Introduction-to-Convolut/</id>
    <published>2024-09-16T12:24:34.000Z</published>
    <updated>2024-09-18T13:10:43.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k-Nearest-Neighbors分类算法"><a href="#k-Nearest-Neighbors分类算法" class="headerlink" title="k-Nearest Neighbors分类算法"></a>k-Nearest Neighbors分类算法</h2><blockquote><p>单纯比较相似性</p></blockquote><p>k-最近邻（k-Nearest Neighbors，k-NN）算法是一种简单的机器学习算法，用于分类和回归分析。在分类问题中，k-NN 算法根据训练数据集中的 k 个最接近的样本（称为“邻居”）来预测新样本的类别。<br>以下是 k-NN 算法的基本步骤：</p><ol><li><strong>选择 k 值</strong>：首先，你需要选择一个正整数 k，这决定了算法中要考虑的最近邻的数量。k 的值通常通过交叉验证等方法来确定，但也可以根据具体问题设定。</li><li><strong>计算距离</strong>：对于新样本，计算它与训练数据集中每个样本的距离。常用的距离度量有欧几里得距离、曼哈顿距离、余弦距离等。</li><li><strong>选择邻居</strong>：根据距离，选择 k 个最近的样本。这些样本称为“k 个最近邻”。</li><li><strong>预测类别</strong>：根据最近邻的类别，对新样本进行预测。通常使用多数表决原则，即新样本的类别是 k 个最近邻中出现次数最多的类别。如果 k 个邻居中有多个类别出现次数相同，那么新样本的类别是不确定的。</li><li><strong>回归分析</strong>：在回归问题中，k-NN 算法预测新样本的值是 k 个最近邻的值的平均值或加权平均值。<br>k-NN 算法的一些关键特性：</li></ol><ul><li><strong>简单直观</strong>：k-NN 算法非常直观，易于理解和实现。</li><li><strong>不需要训练</strong>：k-NN 算法不需要训练模型，因为它不需要学习参数，而是直接使用训练数据进行预测。</li><li><strong>高维数据</strong>：k-NN 算法可以处理高维数据，因为它只是计算样本之间的距离，而不是对数据进行降维或特征选择。</li><li><strong>计算复杂度</strong>：k-NN 算法的计算复杂度较高，因为它需要计算新样本与所有训练样本的距离，并选择最近的 k 个邻居。<br>k-NN 算法在处理小规模数据集或当新样本的类别可以从其邻近样本的类别中直观地推断出来时效果较好。然而，在处理大规模数据集或当新样本的类别难以从其邻近样本的类别中推断出来时，k-NN 算法可能不够有效。此外，k-NN 算法对噪声和异常值比较敏感，因此在实际应用中可能需要对数据进行预处理。</li></ul><details open><summary pointer> 欧式距离与曼哈顿距离的区别 </summary>              <div class='content'>              <ul><li><p><strong>欧氏距离就是我们最常用的两点之间的直线距离。</strong></p><p> 以二维空间为例，两点(x1,y1),(x2,y2)之间的欧式距离为：</p><p> $ \rho  &#x3D; \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} $</p></li><li><p><strong>曼哈顿距离则表示两个点在标准坐标系上的绝对轴距之和。</strong></p><p>  还是以二维空间为例，两点(x1,y1),(x2,y2)之间的曼哈顿距离为：</p><p>  $ c &#x3D; |x_1-x_2|+|y_1-y_2| $</p></li></ul><p>用一张图来区分一下两者:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4xuhzreg8k.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4xuhzreg8k.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>为什么要提出曼哈顿距离呢？</strong><br>——为了简化计算。</p><p>曼哈顿距离中的距离计算公式比欧氏距离的计算公式看起来简洁很多，只需要把两个点坐标的 x 坐标相减取绝对值，y 坐标相减取绝对值，再加和。<br>从公式定义上看，曼哈顿距离一定是一个非负数，距离最小的情况就是两个点重合，距离为 0，这一点和欧氏距离一样。<br>曼哈顿距离和欧氏距离的意义相近，也是为了描述两个点之间的距离，不同的是曼哈顿距离只需要做加减法，这使得计算机在大量的计算过程中代价更低，而且会消除在开平方过程中取近似值而带来的误差。不仅如此，曼哈顿距离在人脱离计算机做计算的时候也会很方便。</p>              </div>            </details><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NearestNeighbor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;X is N x D where each row is an example.</span></span><br><span class="line"><span class="string">        Y is l-dimension of size N&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;X is N x D where each row is an example we wish to predict label for&quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        Ypred = np.zeros(num_test, dtype=self.ytr.dtype)</span><br><span class="line">        distances = np.zeros((X.shape[<span class="number">0</span>], self.Xtr.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># loop over all test rows</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> np.xrange(num_test):</span><br><span class="line">            <span class="comment"># find the nearest training image to the i&#x27;th test image</span></span><br><span class="line">            <span class="comment"># using the L1 distance (sum of absolute value differences)</span></span><br><span class="line">            distances[i] = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i, :]), axis=<span class="number">1</span>)</span><br><span class="line">            min_index = np.argmin(distances[i])  <span class="comment"># get the index with the smallest distance</span></span><br><span class="line">            Ypred[i] = self.ytr[min_index]  <span class="comment"># predict the label of the nearest example</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure><blockquote><p>为什么distance是二维的：<br>对于测试样本集中的每个测试样本 X[i, :]，我们计算它与训练样本集中的每个训练样本 self.Xtr[j, :] 之间的 L1 距离，并存储在 distances[i] 中。由于有多个测试样本，所以需要一个矩阵来存储这些距离。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8l01nbuxa8.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8l01nbuxa8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;k-Nearest-Neighbors分类算法&quot;&gt;&lt;a href=&quot;#k-Nearest-Neighbors分类算法&quot; class=&quot;headerlink&quot; title=&quot;k-Nearest Neighbors分类算法&quot;&gt;&lt;/a&gt;k-Nearest Neighbo</summary>
      
    
    
    
    <category term="AI" scheme="http://tumytime.github.io/categories/AI/"/>
    
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>windows查看当前目录下文件夹大小的命令</title>
    <link href="http://tumytime.github.io/2024/09/16/windows%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://tumytime.github.io/2024/09/16/windows%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-16T03:34:56.000Z</published>
    <updated>2024-09-16T03:55:55.239Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>D盘突然爆红，我还以为是我环境下多了，最后发现是steam删游戏是假删。。。。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-Directory</span> | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">    <span class="variable">$sizeInBytes</span> = (<span class="built_in">Get-ChildItem</span><span class="variable">$_</span>.FullName <span class="literal">-Recurse</span> | <span class="built_in">Measure-Object</span> <span class="literal">-Property</span> Length <span class="literal">-Sum</span>).Sum</span><br><span class="line">    <span class="variable">$sizeInGB</span> =<span class="variable">$sizeInBytes</span> / <span class="number">1</span>GB</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$sizeInGB</span> <span class="operator">-gt</span> <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable">$_</span>.FullName + <span class="string">&quot; &quot;</span> +<span class="variable">$sizeInGB</span>.ToString(<span class="string">&quot;F2&quot;</span>) + <span class="string">&quot; GB&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;D盘突然爆红，我还以为是我环境下多了，最后发现是steam删游戏是假删。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="windows" scheme="http://tumytime.github.io/categories/windows/"/>
    
    
    <category term="windows" scheme="http://tumytime.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
