<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello！Welcom to Tumy-Time！</title>
  
  
  <link href="http://tumytime.github.io/atom.xml" rel="self"/>
  
  <link href="http://tumytime.github.io/"/>
  <updated>2024-06-16T03:45:54.974Z</updated>
  <id>http://tumytime.github.io/</id>
  
  <author>
    <name>tumytime</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>videocapture的bug</title>
    <link href="http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/"/>
    <id>http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/</id>
    <published>2024-06-16T03:45:42.000Z</published>
    <updated>2024-06-16T03:45:54.974Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;  &lt;body class=&quot;nodata &quot; style=&quot;&quot;&gt;         &lt;main style=&quot;width:100%&quot;&gt;      &lt;div class=&quot;blog-content-box&quot;&gt;         &lt;div class=&quot;article-title-box&quot;&gt;            &lt;h1 class=&quot;title-article&quot; id=&quot;articleContentId&quot;&gt;opencv读取摄像头不是实时的处理方法&lt;/h1&gt;        &lt;/div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css&quot;&gt;                     &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; style=&quot;display: none;&quot;&gt;                    &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot; style=&quot;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&quot;&gt;&lt;/path&gt;                &lt;/svg&gt;                &lt;pre data-index=&quot;0&quot; class=&quot;set-code-show prettyprint&quot;&gt;&lt;code class=&quot;prism language-python has-numbering&quot; onclick=&quot;mdcp.copyCode(event)&quot; style=&quot;position: unset;&quot;&gt;cap &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cv2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;VideoCapture&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> <h2><a name="t0"></a><a id="___5"></a>读取的不是实时的画面 ，存在延迟 怎么处理</h2> <blockquote>  <p>如果你使用的是<a href="https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;OpenCV库\&quot;}&quot;}" data-tit="OpenCV库" data-pretit="opencv库">OpenCV库</a>，你可以通过将缓冲区大小设置为更小的值来减小延迟。默认情况下，缓冲区大小是16，但可以通过在cv2.VideoCapture()中传递参数来更改。例如：</p> </blockquote> <pre data-index="1" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><div class="hljs-button &#123;2&#125;" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> <blockquote>  <p>这将把缓冲区大小减小到1，从而减小延迟。但是，如果你将缓冲区大小设置得太小，你可能会遇到画面卡顿或丢帧的问题。</p> </blockquote> <p>另一种方式是使用多线程或异步处理来实现更快的画面更新。你可以在一个线程中读取摄像头的帧，并将它们传递到另一个线程或进程中进行处理和显示。这将使你能够更快地处理帧并减少延迟。但是，这需要更多的编程和计算资源，并可能会增加代码的复杂性。</p> <h2><a name="t1"></a><a id="OpenCV_19"></a>下面是一个基本的多线程处理OpenCV视频帧的例子：</h2> <pre data-index="2" class="prettyprint set-code-show"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">VideoCapture</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span>src<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>grabbed<span class="token punctuation">,</span> self<span class="token punctuation">.</span>frame <span class="token operator">=</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>read_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><pre><code>&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;VideoCapture already started&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; threading&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Thread&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;update&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; args&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;start&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; grabbed            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed        frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;join&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__exit__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; traceback&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;release&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p><span class="token keyword">if</span> <strong>name</strong> <span class="token operator">&#x3D;&#x3D;</span> <span class="token string">‘<strong>main</strong>‘</span><span class="token punctuation">:</span><br>    cap <span class="token operator">&#x3D;</span> VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><br>        grabbed<span class="token punctuation">,</span> frame <span class="token operator">&#x3D;</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token keyword">if</span> <span class="token keyword">not</span> grabbed<span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">‘frame’</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><br>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">&#x3D;&#x3D;</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">‘q’</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>    cap<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li></ul></pre> <blockquote>  <p>这个例子使用了一个<a href="https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-tit="VideoCapture" data-pretit="videocapture">VideoCapture</a>类，该类在一个线程中不断读取摄像头帧，并将它们保存在一个共享的grabbed和frame变量中。在主程序中，我们通过调用start()方法来启动线程，然后不断读取帧并在窗口中显示它们，直到用户按下’q’键退出。最后，我们调用stop()方法来停止线程并释放资源。</p> </blockquote> <p>需要注意的是，这个例子仅仅是一个基本的框架，你可能需要对其进行修改和扩展以适应你的具体应用场景。例如，你可以添加一个另一个线程来处理帧，然后显示处理后的结果，以此来减少延迟。</p>                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_26696715/article/details/129686980&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-f23dff6052.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-c216769e99.css" rel="stylesheet">        </div>            </div>             <pre><code>          &lt;/main&gt;        &lt;/body&gt;   &lt;/html&gt;        </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++多线程</title>
    <link href="http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-06-03T05:30:23.000Z</published>
    <updated>2024-06-14T11:54:39.061Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)</p></div><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当我们谈论多线程时，可以想象成一个人同时在做多个事情，就像一个人既可以同时吃饭又可以同时写作业一样。在C++中，使用多线程可以让我们的程序同时执行多个任务，提高程序的效率和性能。</p><p>首先，让我们用一个简单的例子来理解多线程。假设你有一个厨房，里面有一个厨师在煮面条，一个厨师在炒菜，还有一个服务员在端菜。这就相当于一个有多个线程的程序，每个线程负责不同的任务。</p><p>在C++中，我们可以使用 <code>&lt;thread&gt;</code> 头文件来创建和管理线程。首先，我们需要定义一个函数，在这个函数中包含我们希望线程执行的任务。然后，我们使用 <code>std::thread</code> 类来创建线程并指定要执行的函数。</p><p>让我们来看一个示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，作为线程的入口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程，并指定要执行的函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行自己的任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程 t1 执行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个简单的函数 <code>printMessage</code>，并在主函数中创建了一个新线程 <code>t1</code>，让它执行这个函数。同时，主函数也会继续执行，输出 “Hello from main thread!”。最后我们使用 <code>join()</code> 函数等待线程 <code>t1</code> 的执行完成。</p><p>这样，就实现了一个简单的多线程程序。通过合理地使用多线程，我们可以更高效地利用计算机的资源，加快程序的运行速度。当然，在实际编程中，还需要考虑线程之间的同步、互斥访问等问题，以保证程序的正确性和稳定性。</p><h3 id="std-thread-t1-printMessage-代表着线程开始执行吗"><a href="#std-thread-t1-printMessage-代表着线程开始执行吗" class="headerlink" title="std::thread t1(printMessage);代表着线程开始执行吗"></a>std::thread t1(printMessage);代表着线程开始执行吗</h3><p>是的，当你创建一个 <code>std::thread</code> 对象并传入要执行的函数，线程就会开始执行这个函数。在你的例子中，<code>std::thread t1(printMessage);</code>这一行代码就代表着线程开始执行 <code>printMessage</code> 函数。这意味着在运行时，会产生一个新的线程来执行 <code>printMessage</code> 函数中的代码，同时主线程会继续执行后面的代码。</p><p>但需要注意的是，线程的启动并不是立即执行 <code>printMessage</code> 函数中的代码，而是在<code>std::thread</code> 对象被创建之后才会执行。如果立即调用 <code>join()</code> 函数，主线程会等待新线程执行完毕再继续往下执行。这种方式保证了线程的同步执行。</p><p>因此，在上面提供的示例代码中，<code>std::thread t1(printMessage);</code>这一行代码会使得新线程开始执行 <code>printMessage</code> 函数，而主线程会继续执行紧随其后的代码，直到遇到 <code>t1.join();</code>。</p><p>在C++中，如果我们使用std::thread来创建线程，线程的启动确实不会立即执行线程函数中的代码。当我们创建一个std::thread对象，指定要执行的线程函数，并调用该std::thread对象的构造函数时，线程对象就会被创建，但线程函数的代码并不会立即执行。实际上线程的实际执行时机取决于操作系统的调度器，在合适的时机会开始执行线程函数。</p><p>如果在主线程中立即调用新线程的join()函数，主线程将会被阻塞，直到新线程的执行完成。这种方式确保了线程的同步执行，即主线程会等待新线程执行完毕后才会继续往下执行。在这种情况下，主线程和新线程是同步执行的，主线程起到了等待和协调的作用。</p><p>总结：通过调用join()函数实现线程同步执行的流程是这样的，先创建新的线程对象，然后调用join()函数使得主线程等待新线程的执行完成，待新线程执行完毕后，主线程才继续往下执行。这种方式保证了线程的同步执行，特别适用于需要新线程执行完毕后才能继续主线程操作的场景。</p><h2 id="进阶实例-互斥锁"><a href="#进阶实例-互斥锁" class="headerlink" title="进阶实例(互斥锁)"></a>进阶实例(互斥锁)</h2><p>让我们来看一个稍微复杂一点的多线程例子，考虑一个生产者-消费者模型。在这个例子中，有一个生产者线程负责生产数据，然后将数据发送给一个缓冲区，同时一个消费者线程从缓冲区中取出数据进行消费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产数据的耗时操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            buffer.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> data = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个互斥锁（std::mutex）来保护共享的数据结构（队列buffer），生产者线程往队列中写入数据，消费者线程从队列中读取数据。通过条件变量（std::condition_variable）实现了生产者与消费者之间的同步。</p><p>生产者不断地在队列中插入数据，消费者则等待队列中有数据后进行消费。当队列中有数据时，消费者线程被唤醒，消费数据并输出，直至生产者生产完所有数据。整个过程利用互斥锁和条件变量实现了线程之间的同步操作，确保了数据的正确生产和消费。</p><ol><li><p><strong>前三行意思</strong></p><p> 这三行代码声明了一个整型队列 <code>buffer</code>，一个互斥锁 <code>mtx</code> 和一个条件变量 <code>cv</code>。 </p><ul><li><p><code>std::queue&lt;int&gt; buffer;</code>：这行代码定义了一个STL队列，其中存储整型数据。在生产者和消费者模型中，<code>buffer</code>用于存储生产者生成的数据，在生产者线程将数据写入队列，消费者线程从队列中取出数据进行消费。</p></li><li><p><code>std::mutex mtx;</code>：这行代码定义了一个互斥锁，用于在多线程环境中对共享数据结构进行访问控制。在此例中，<code>mtx</code> 用于保护队列 <code>buffer</code>，确保在任一时刻只有一个线程可以访问队列。</p></li><li><p><code>std::condition_variable cv;</code>：这行代码定义了一个条件变量，用于线程间的同步。在此例中，<code>cv</code> 用于通知消费者线程有新的数据可用于消费。消费者线程会通过 <code>wait()</code> 来等待生产者通知，一旦有数据可用，它会被 <code>notify_one()</code> 通知可以继续执行。</p></li></ul><p> 这些机制共同构成了一个生产者-消费者模型，确保在多线程环境下数据的安全访问和同步处理。</p></li><li><p><strong>为什么确保在任一时刻只有一个线程可以访问队列</strong><br> 在多线程环境中，如果不对共享数据结构（比如队列）进行保护，就可能导致数据竞争（Data Race）的问题。数据竞争指的是多个线程同时访问共享数据，其中至少一个线程对数据进行写操作，而其他线程进行读或写操作，从而导致未定义行为。对于队列这样的数据结构，如果没有互斥访问，会导致以下问题：</p><ul><li><p>不确定性：多个线程同时对队列进行操作，可能造成队列中数据的乱序或丢失，导致程序逻辑错误。</p></li><li><p>数据损坏：当一个线程正在修改队列中的数据时，另一个线程可能同时读取或修改这些数据，造成意外的数据损坏。</p></li><li><p>死锁：如果多个线程同时尝试对队列进行读写操作而没有恰当的同步机制，可能会出现死锁情况，使得程序无法继续执行。</p></li></ul><p> 因此，通过使用互斥锁（<code>mutex</code>）来保护队列，在任一时刻只允许一个线程访问队列，可以确保在多线程环境下数据的安全访问，避免数据竞争和可能导致的问题。</p></li><li><p><strong>什么是死锁</strong><br> 死锁（Deadlock）是指在并发系统中，两个或多个进程（线程）因争夺共享资源而进入一种互相等待的状态，导致它们都无法继续执行下去的情况。在死锁情况下，每个进程都在等待其他进程释放资源，而同时又不愿意主动释放自己当前已经占有的资源，从而形成了一种僵局。死锁是多线程编程中常见的并发问题，需要通过合理的设计和实现来避免和解决死锁问题。</p></li><li><p><strong>std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#x2F;&#x2F; 模拟生产数据的耗时操作</strong></p><p> 这行代码是使用C++标准库提供的线程库<code>&lt;thread&gt;</code>中的<code>std::this_thread::sleep_for</code>函数，用来模拟在生产数据过程中的耗时操作。让我们来详细解释一下这行代码的作用：</p><ul><li><p><code>std::this_thread::sleep_for</code>：这是C++标准库中用于线程操作的静态成员函数，允许当前线程休眠一段时间。因为是<code>this_thread</code>所以是当前线程。</p></li><li><p><code>std::chrono::milliseconds(500)</code>：这里使用<code>std::chrono::milliseconds</code>来创建一个表示时间间隔的对象，参数为500，表示500毫秒（即0.5秒）的时间间隔。<code>std::chrono</code>是C++标准库提供的日期和时间库，用于处理时间相关的操作。</p></li><li><p><code>// 模拟生产数据的耗时操作</code>：这是一行注释，说明了这行代码的目的，即模拟在生产数据过程中的耗时操作。通常在生产数据或其他需要等待的操作中，为了模拟真实场景的延迟，会使用类似的休眠操作来延迟线程的执行。</p></li></ul><p> 因此，这行代码的作用是让当前线程休眠500毫秒，模拟生产数据过程中的耗时操作，以便更好地测试和理解程序的行为。</p></li><li><p><strong>std::lock_guard &lt; std::mutex &gt; lock(mtx);</strong></p><p> <code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>是C++中使用RAII机制来管理互斥锁（<code>std::mutex</code>）的典型语法格式。这行代码的作用是创建一个<code>lock_guard</code>对象并用其构造函数锁住一个<code>std::mutex</code>对象<code>mtx</code>。</p><p> 具体解释如下：</p><ul><li><code>std::lock_guard</code>是一个模板类，用于管理锁对象（互斥锁）。它会在构造时锁住给定的互斥锁，在析构时解锁互斥锁，实现了RAII机制。</li><li><code>&lt;std::mutex&gt;</code>是模板参数，表示<code>std::lock_guard</code>将要管理的互斥锁的类型是<code>std::mutex</code>。</li><li><code>lock</code>是<code>std::lock_guard</code>对象的名称，可以根据需要命名。</li><li><code>(mtx)</code>表示用<code>mtx</code>（一个名为<code>mtx</code>的<code>std::mutex</code>对象）来初始化<code>lock_guard</code>对象，即在构造<code>lock_guard</code>对象时锁住<code>mtx</code>。</li></ul><p> <code>std::lock_guard</code>是C++标准库提供的一个RAII（资源获取即初始化）风格的互斥量封装类，通过它可以在一个作用域中保持互斥锁的持有状态。在这段代码中，<code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>的作用是使用互斥量<code>mtx</code>对临界区进行加锁，确保对共享数据结构<code>buffer</code>的访问是线程安全的。让我们来详细解释其作用：</p><ul><li><p><strong>RAII机制</strong>：RAII（Resource Acquisition Is Initialization）是一种C++编程范式，它通过对象的生命周期来管理资源的获取和释放，确保资源在对象构造时被正确获取，而在对象析构时被自动释放。这种机制的核心思想是利用局部对象的生命周期控制资源的获取和释放，从而确保资源的正确管理，提高代码的可靠性和可维护性。</p><p>  下面是RAII机制的工作原理和优势：</p><ol><li><p><strong>资源获取即初始化</strong>：当一个对象被创建时，同时获取所需的资源，例如内存、文件句柄、互斥锁等，这样资源的获取和初始化是统一的操作。</p></li><li><p><strong>资源的自动释放</strong>：当对象离开其作用域时（比如函数返回、作用域结束等），其析构函数会被调用，负责释放已获取的资源，无论是正常执行还是异常发生，资源都会被正常释放。</p></li><li><p><strong>避免资源泄漏和确保资源管理</strong>：通过RAII机制，程序员无需手动管理资源的获取和释放，减少了因忘记释放资源而导致的内存泄漏或资源泄漏问题。</p></li><li><p><strong>异常安全性</strong>：RAII可确保在异常发生时，资源能够被正确释放，避免资源泄漏，同时保证程序的安全性。</p></li><li><p><strong>提高代码的可维护性和可读性</strong>：RAII使资源管理的逻辑更加清晰明了，代码更易于理解和维护，同时降低了在多线程环境下出现的死锁等问题。</p></li></ol><p>  在C++中，标准库中的智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等）和锁（<code>std::lock_guard</code>、<code>std::unique_lock</code>等）都是基于RAII机制设计的。通过合理利用RAII机制，可以有效管理资源，提高代码的健壮性和可靠性。</p></li><li><p><strong>加锁</strong>：当<code>std::lock_guard</code>对象<code>lock</code>被创建时，它会在构造函数中对互斥量<code>mtx</code>进行加锁操作，即锁住<code>mtx</code>。这样就确保了在<code>lock_guard</code>对象的作用域内（在这个括号内）对<code>buffer</code>的访问是受到保护的，其他线程无法同时修改<code>buffer</code>的内容，避免了数据竞争和不一致性。<code>在这个括号内</code>指的是<code>std::lock_guard</code>对象<code>lock</code>的作用域范围，即<code>lock</code>对象的生命周期。在C++中，作用域用花括号<code>&#123;&#125;</code>表示，也叫做代码块。当<code>std::lock_guard</code>对象<code>lock</code>的作用域范围结束（即超出了花括号的范围），该对象的析构函数会被调用，从而自动释放锁。这种方式确保了在<code>lock</code>对象的作用域内，互斥锁被保持，从而保护了共享资源（如<code>buffer</code>）的访问并避免了数据竞争和不一致性的问题。</p></li></ul><p> 因此，通过在花括号内创建<code>std::lock_guard</code>对象并锁住互斥量，可以确保只有一个线程能够访问或修改被保护的共享资源，从而提高多线程程序的安全性。</p><ul><li><strong>解锁</strong>：当<code>lock_guard</code>对象的作用域结束时，会调用其析构函数，在析构函数中会自动解锁互斥量<code>mtx</code>，即释放<code>mtx</code>的锁，使得其他线程可以访问共享资源。</li></ul><p> 通过使用<code>std::lock_guard</code>和互斥量，可以简化了对临界区的加锁和解锁过程，并且可以避免因为忘记解锁导致的死锁情况。这样的操作保证了对临界区资源的访问是互斥的，确保了多线程环境下的数据安全性。</p></li><li><p><strong>cv.notify_one();</strong><br> 在多线程编程中，<code>cv.notify_one()</code> 是用来通知等待在条件变量上的某个线程继续执行的函数。当某个线程调用 <code>cv.wait()</code> 方法并在条件变量上等待时，其他线程可以通过调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来通知等待的线程可以继续执行。</p><p> 具体来说，<code>cv.notify_one()</code> 会唤醒在条件变量上等待的一个线程（如果有的话），让其可以从等待状态中醒来并继续执行。如果没有线程在条件变量上等待，那么调用 <code>cv.notify_one()</code> 也不会有任何效果。</p><p> 在多线程协作中，通常会结合条件变量和互斥量来实现线程之间的同步操作。当一个线程修改了共享数据，并希望通知其他线程有关此数据的改变时，可以使用条件变量来实现线程之间的同步通信。通常的流程是，先获得互斥锁，然后修改共享数据，再通知等待在条件变量上的线程，最后释放互斥锁。</p><p> 在这段示例代码中，生产者线程和消费者线程通过条件变量 <code>cv</code> 和互斥量 <code>mtx</code> 实现了线程之间的同步通信。生产者线程通过 <code>notify_one()</code> 方法通知消费者线程，告知其有新的数据可以被消费。具体来说，<code>cv.notify_one()</code> 的作用是：</p><ol><li>当生产者线程生产了一个数据后（通过 <code>buffer.push(i)</code>），它会立即通知等待在条件变量 <code>cv</code> 上的消费者线程。</li><li>在消费者线程中，当它通过 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 进入等待状态时，会自动释放 <code>mtx</code> 互斥量并等待，直到生产者线程调用 <code>cv.notify_one()</code> 来唤醒它。</li><li>一旦消费者线程被唤醒，它会重新获取 <code>mtx</code> 互斥量并继续执行，从 <code>buffer</code> 中取出数据消费。</li><li>生产者线程每生产一个数据，就会唤醒一个等待的消费者线程。如果有多个消费者线程在等待，只有一个会被唤醒。</li></ol><p> 综上所述，<code>cv.notify_one()</code> 的作用是唤醒一个等待在条件变量上的线程，用来提示该线程可以继续执行，适用于协调多线程之间的操作顺序和数据传递。</p></li><li><p><strong>为什么一个用std::lock_guard一个用std::unique_lock</strong><br> 在上述代码中，<code>producer()</code> 函数使用了 <code>std::lock_guard</code> 来锁定互斥量，而 <code>consumer()</code> 函数则使用了 <code>std::unique_lock</code>。这种选择并非绝对，而是根据不同的需求和情境来决定使用哪种锁定方式。</p><ol><li><strong><code>std::lock_guard</code> 在 producer 函数中的使用：</strong></li></ol><ul><li>在 <code>producer()</code> 函数中，生产者生产数据到缓冲区，并在数据生产完成后立即释放互斥量。由于在生产者生产完数据后就会释放互斥量，因此使用 <code>std::lock_guard</code> 而不是 <code>std::unique_lock</code> 更加简洁和合适。<code>std::lock_guard</code> 自动锁定互斥量，并在作用域结束时自动释放互斥量，非常适合这种简单的锁定和释放情况。</li></ul><ol start="2"><li><strong><code>std::unique_lock</code> 在 consumer 函数中的使用：</strong></li></ol><ul><li>在 <code>consumer()</code> 函数中，消费者需要等待缓冲区中有数据可消费时才能继续执行。为了支持在等待期间手动解锁互斥量并等待条件变量，这里使用了 <code>std::unique_lock</code>。<code>std::unique_lock</code> 提供了更灵活的加锁和解锁操作，同时支持条件变量的等待。在等待缓冲区有数据可消费时，我们使用 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 来等待条件变量满足。</li></ul><p> 综上所述，选择使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 取决于具体的应用场景和需求。在简单的自动锁定和释放互斥量情况下，可以使用 <code>std::lock_guard</code>；而在需要更多灵活性和条件变量支持的情况下，可以选择使用 <code>std::unique_lock</code>。在生产者消费者模型中，生产者和消费者可能有不同的需求，因此可以根据具体情况选择不同的锁定方式。</p></li><li><p><strong>cv.wait(lock, [] { return !buffer.empty(); });</strong></p><p> <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 这行代码是在<code>consumer()</code>函数中使用条件变量等待的部分。让我们详细解释这段代码的作用和具体执行流程：</p><ol><li><p><code>cv.wait(lock, condition)</code>：这是条件变量 <code>cv</code> 的等待函数调用。在这里，<code>lock</code> 是一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，通过将 <code>lock</code> 传递给 <code>cv.wait</code>，会在等待期间将互斥量解锁，以便其他线程可以在该互斥量上执行操作。<code>condition</code> 是一个 lambda 函数，用于指定等待条件。在这种情况下，<code>cv.wait</code>会在等待期间检查 lambda 函数返回的布尔值，只有在 lambda 函数返回 <code>true</code> 时才会继续执行。</p></li><li><p><code>[] &#123; return !buffer.empty(); &#125;</code>：这是一个 lambda 函数，它检查 <code>buffer</code> 是否为空。条件变量的 <code>wait</code> 操作依赖于用户提供的条件函数。在这里，条件函数检查 <code>buffer</code> 是否为空，如果为空，则条件为假， <code>cv.wait</code> 会一直等待，直到条件变为真。一旦条件为真，<code>cv.wait</code> 将继续执行，即互斥量被重新锁定，并且线程继续执行下去。</p></li><li><p>执行流程：</p><ul><li>当消费者线程开始执行 <code>consumer()</code> 函数时，首先会创建一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象 <code>lock</code>，该对象在实例化时会锁定其关联的互斥量 <code>mtx</code>。</li><li>接着，消费者线程调用 <code>cv.wait(lock, condition)</code>，这会导致线程释放互斥量的锁并等待，直到<code>condition</code>返回 <code>true</code>。</li><li>在等待过程中，其他线程可以获得互斥量的锁并修改共享数据，但由于条件未满足，消费者线程会一直保持等待状态。</li><li>当生产者线程向 <code>buffer</code> 中加入数据并调用 <code>cv.notify_one()</code> 通知时，条件 <code>!buffer.empty()</code> 变为真，这会导致条件变量通知消费者线程继续执行。</li><li>消费者线程被唤醒后，会重新获得互斥量的锁，这时可以安全地从 <code>buffer</code> 中取出数据进行消费，然后继续执行后续的操作。</li></ul></li></ol><p> 总之，通过使用条件变量和 lambda 函数等待特定条件，可以实现线程间的同步和协调，确保消费者在有数据可消费时才执行消费操作，从而有效避免了竞态条件和数据不一致的问题。</p></li><li><p><strong>lambda 表达式</strong><br> 用于定义函数对象：</p><ol><li><p><code>[]</code>：lambda 表达式的开头以一对方括号开始。在这里，<code>[]</code> 表示 lambda 表达式不捕获任何外部变量。这意味着 lambda 表达式只能访问传递给它的参数，而不能访问外部作用域的变量。</p></li><li><p><code>&#123;&#125;</code>：lambda 表达式的主体使用一对大括号来定义，在大括号内部是 lambda 表达式的具体实现。</p></li></ol></li></ol><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在多线程编程中，为了避免多个线程同时访问共享资源而引起的竞争条件和数据不一致性问题，我们使用互斥锁（Mutex，全称Mutual Exclusion）。互斥锁是一种同步原语，它允许线程在进入临界区（对共享资源操作的临界区域）前先获取锁，执行完后再释放锁，从而确保在同一时刻只有一个线程能进入临界区进行操作。</p><p>详细解释互斥锁包括以下几点：</p><ol><li><p><strong>锁的状态</strong>: 互斥锁有两种状态，分别是锁定（locked）和解锁（unlocked）。线程在进入临界区之前需要先获取锁（即将锁定状态设定为locked），执行完后再释放锁（将状态设定为unlocked）。</p></li><li><p><strong>互斥性</strong>: 互斥锁的特性确保了同一时刻只有一个线程能够获取锁，其他线程需要等待当前持有锁的线程释放锁后才能继续执行。这样可以避免多个线程同时访问共享资源导致的数据竞争和不一致性问题。</p></li><li><p><strong>使用方法</strong>: 在多线程代码中使用互斥锁时，一般会使用<code>std::mutex</code>或类似的互斥锁类型。典型的用法是在临界区开始之前调用<code>lock()</code>方法获取锁，在临界区结束后调用<code>unlock()</code>方法释放锁。</p></li><li><p><strong>死锁</strong>: 如果在多线程代码中使用互斥锁不当，可能会导致死锁（Deadlock）的问题。死锁指的是多个线程相互等待对方释放资源而无法继续执行的情况，因此在使用互斥锁时要注意避免造成死锁。</p></li></ol><p>总之，互斥锁是一种重要的同步工具，用于在多线程环境下控制对共享资源的访问，确保线程安全性并避免竞争条件和数据不一致性问题的发生。在正确使用互斥锁的情况下，可以有效地保证多线程程序的正确性和稳定性。</p><h3 id="临界区（对共享资源操作的临界区域）"><a href="#临界区（对共享资源操作的临界区域）" class="headerlink" title="临界区（对共享资源操作的临界区域）"></a>临界区（对共享资源操作的临界区域）</h3><p>临界区是指在多线程程序中，多个线程共享的某一段代码或数据区域，这里的代码或数据可能会被多个线程同时访问和操作。在临界区中，如果多个线程同时对共享资源进行读写操作，就会发生竞态条件（Race Condition），导致程序出现错误或产生不确定的结果。</p><p>让我们通过一个生动的比喻来解释临界区：</p><p>假设有一个小咖啡厅只有一个咖啡机可以制作咖啡。多个服务员（线程）需要制作咖啡时，他们需要先检查咖啡机是否空闲。如果咖啡机正在被使用，那么其他服务员必须等待直到当前制作完成并释放咖啡机。在这个过程中，检查咖啡机状态、占用咖啡机、释放咖啡机的这一段代码就是临界区。只能有一个服务员进入临界区，占用咖啡机，制作咖啡，防止出现多个服务员同时操作导致的错误。</p><p>所以，临界区是指在多线程环境下，需要同步访问共享资源的代码区域或数据区域，为了避免竞态条件，需要通过互斥锁等同步机制来确保同一时刻只有一个线程能够访问临界区，保证数据的正确性和一致性。通过合理管理临界区，可以有效避免多线程程序中的各种潜在问题，确保程序的正确性和稳定性。</p><h2 id="复杂一点点的例子"><a href="#复杂一点点的例子" class="headerlink" title="复杂一点点的例子"></a>复杂一点点的例子</h2><p>以下是一个更复杂的多线程示例，其中包含两个线程，一个是生产者线程，一个是消费者线程，它们之间通过共享的缓冲区进行通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line">        </span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，生产者线程负责向缓冲区中放入数据，而消费者线程则负责从缓冲区中取出数据。生产者线程会一直生产数据直到生产完20个数据为止。消费者线程会在生产者线程生产数据时，从缓冲区中消费数据，并且当生产者线程结束时也会结束。</p><p>通过使用互斥锁和条件变量来实现对缓冲区的访问控制和线程通信。生产者线程会根据缓冲区的状态来决定是否生产数据，而消费者线程也会根据缓冲区的状态来决定是否消费数据。在主函数中，调用了 <code>join()</code> 来等待生产者线程和消费者线程的结束。</p><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>当加上sleep_for后:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line"></span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Consumed: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Consumed: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Consumed: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Consumed: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Consumed: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Consumed: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Consumed: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Consumed: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>在生产者线程中使用<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>来模拟生产数据的耗时操作是为了模拟实际生产数据可能存在的耗时情况，而不是立即连续生产数据。这种模拟有几个关键的影响：</p><ol><li><p><strong>模拟实际情况</strong>：在实际情况下，生产数据可能涉及到一些繁重的计算或I&#x2F;O操作，这可能导致需要一定的时间来生成数据。通过这种模拟，可以更好地反映现实情况下的生产数据过程。</p></li><li><p><strong>线程调度</strong>：使用<code>sleep_for</code>会使得当前线程在指定的时间内暂停执行，其他线程有机会继续执行。这有助于模拟并发环境中不同线程之间的调度和竞争。</p></li><li><p><strong>避免资源争夺</strong>：由于生产者线程在生产数据时会暂停一段时间，消费者线程有机会访问和处理已生产的数据，而不会因为生产速度过快导致队列溢出或数据丢失。</p></li></ol><p>如果去掉<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>部分，生产者线程将会变得非常快速，可能导致生产的数据迅速填满队列，消费者线程无法及时消费，从而导致队列溢出。因此，这段代码中的延时操作对于正确模拟生产者和消费者之间的交互过程和线程调度是非常重要的。</p><ol><li><p><strong>为什么done&#x3D;true后面要加consumeCondition.notify_one();</strong></p><p> 在典型的生产者消费者模型中，<code>done=true</code>通常表示生产者已经完成了生产任务，没有更多的数据可供消费者消费。当<code>done</code>被设置为<code>true</code>时，消费者线程需要被唤醒并退出循环，以避免不必要的等待和资源浪费。为了实现这一点，通常会使用条件变量（condition variable）来实现线程的等待和唤醒。</p><p> 在设置<code>done=true</code>之后，通过调用<code>consumeCondition.notify_one()</code>来唤醒等待在<code>consumeCondition</code>条件变量上的一个消费者线程。这样做可以确保消费者线程在<code>done=true</code>之后能够立即被唤醒，检查条件并退出循环。没有这一步的唤醒操作，消费者线程可能会一直阻塞在条件变量上，无法及时退出循环，导致资源浪费或程序逻辑错误。</p><p> 因此，通过在<code>done=true</code>之后调用<code>consumeCondition.notify_one()</code>来唤醒消费者线程，确保了生产者完成生产后消费者能够及时退出循环，有效地管理线程的执行顺序和资源的利用。</p></li><li><p><strong>condition_variable是什么</strong></p><p> <code>std::condition_variable</code> 是 C++ 标准库中用来实现多线程同步的一种机制。它允许一个或多个线程等待，直到某个条件得到满足后再继续执行。在多线程编程中，我们经常需要一种方式来进行线程之间的通信和同步，<code>std::condition_variable</code> 就是为此而设计的。</p><p> 在使用 <code>std::condition_variable</code> 时通常和 <code>std::mutex</code> 配合使用，具体步骤如下：</p><ol><li>使用 <code>std::mutex</code> 来保护需要等待的条件变量和共享资源。</li><li>当条件不满足时，线程通过 <code>std::condition_variable</code> 的 <code>wait()</code> 方法释放锁并进入等待状态，直到其他线程通知条件满足。</li><li>当其他线程满足了条件后，调用 <code>std::condition_variable</code> 的 <code>notify_one()</code> 或 <code>notify_all()</code> 方法来唤醒等待的线程。</li></ol><p> 通过 <code>std::condition_variable</code>，我们可以实现线程之间的有效协作和同步，避免了线程忙等待，提高了程序的效率和性能。</p></li></ol><h2 id="4个线程来并发计算部分和"><a href="#4个线程来并发计算部分和" class="headerlink" title="4个线程来并发计算部分和"></a>4个线程来并发计算部分和</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)&lt;/p&gt;&lt;/div&gt;


&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; cl</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="C++" scheme="http://tumytime.github.io/tags/C/"/>
    
    <category term="智能车，多线程" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一些图像处理的函数</title>
    <link href="http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2024-04-29T11:47:24.000Z</published>
    <updated>2024-04-29T12:18:44.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p><strong>卷积核大小为7：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">medianFilter</span><span class="params">(Mat imgO)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个新的Mat对象用于存储滤波后的图像</span></span><br><span class="line">Mat img1 = Mat::<span class="built_in">zeros</span>(imgO.rows - <span class="number">6</span>, imgO.cols - <span class="number">6</span>, CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入图像进行中值滤波</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">3</span>; y &lt; imgO.rows - <span class="number">3</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">3</span>; x &lt; imgO.cols - <span class="number">3</span>; x++) &#123;</span><br><span class="line">vector&lt;uchar&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-3</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-3</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">values.<span class="built_in">push_back</span>(imgO.<span class="built_in">at</span>&lt;uchar&gt;(y + j, x + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对values数组中的值进行排序</span></span><br><span class="line"><span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算中值并赋值给输出图像</span></span><br><span class="line">img1.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">3</span>, x - <span class="number">3</span>) = values[values.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> img1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="sobel算子边缘检测"><a href="#sobel算子边缘检测" class="headerlink" title="sobel算子边缘检测"></a>sobel算子边缘检测</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">sobel3</span><span class="params">(Mat inputImg)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gx, gy;</span><br><span class="line">Mat tempImg;</span><br><span class="line">inputImg.<span class="built_in">copyTo</span>(tempImg); <span class="comment">// 为了能够在输出图像中访问原始输入图像的像素值</span></span><br><span class="line"></span><br><span class="line">Mat outputImg = Mat::<span class="built_in">zeros</span>(inputImg.<span class="built_in">size</span>(), inputImg.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; inputImg.rows - <span class="number">1</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; inputImg.cols - <span class="number">1</span>; x++) &#123;</span><br><span class="line">gx = (<span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>)) / <span class="number">4</span>;</span><br><span class="line">gy = (<span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) - <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x) - <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">outputImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x) = (<span class="built_in">abs</span>(gx) + <span class="built_in">abs</span>(gy)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outputImg.<span class="built_in">clone</span>(); <span class="comment">// 返回outputImg的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中值滤波&quot;&gt;&lt;a href=&quot;#中值滤波&quot; class=&quot;headerlink&quot; title=&quot;中值滤波&quot;&gt;&lt;/a&gt;中值滤波&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;卷积核大小为7：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AuTop代码整理</title>
    <link href="http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <id>http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/</id>
    <published>2024-04-28T11:36:06.000Z</published>
    <updated>2024-05-03T17:37:19.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="圆环circle"><a href="#圆环circle" class="headerlink" title="圆环circle"></a>圆环circle</h2><details ><summary pointer> circle.c </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;motor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span> =</span> CIRCLE_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便串口收发</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM] = &#123;</span><br><span class="line">        <span class="string">&quot;CIRCLE_NONE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_BEGIN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_BEGIN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_RUNNING&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_RUNNING&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_IN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_IN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_OUT&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_OUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_END&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_END&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码器，用于防止一些重复触发等。</span></span><br><span class="line"><span class="type">int64_t</span> circle_encoder;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> none_left_line = <span class="number">0</span>, none_right_line = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> have_left_line = <span class="number">0</span>, have_right_line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆环模式下的调试图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> circle.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> &#123;</span></span><br><span class="line">    CIRCLE_NONE = <span class="number">0</span>,                            <span class="comment">// 非圆环模式</span></span><br><span class="line">    CIRCLE_LEFT_BEGIN, CIRCLE_RIGHT_BEGIN,      <span class="comment">// 圆环开始，识别到单侧L角点另一侧长直道。</span></span><br><span class="line">    CIRCLE_LEFT_IN, CIRCLE_RIGHT_IN,            <span class="comment">// 圆环进入，即走到一侧直道，一侧圆环的位置。</span></span><br><span class="line">    CIRCLE_LEFT_RUNNING, CIRCLE_RIGHT_RUNNING,  <span class="comment">// 圆环内部。</span></span><br><span class="line">    CIRCLE_LEFT_OUT, CIRCLE_RIGHT_OUT,          <span class="comment">// 准备出圆环，即识别到出环处的L角点。</span></span><br><span class="line">    CIRCLE_LEFT_END, CIRCLE_RIGHT_END,          <span class="comment">// 圆环结束，即再次走到单侧直道的位置。</span></span><br><span class="line">    CIRCLE_NUM,                                 <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CIRCLE_H</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="非圆环模式下判断圆环"><a href="#非圆环模式下判断圆环" class="headerlink" title="非圆环模式下判断圆环"></a>非圆环模式下判断圆环</h3><p><strong>单边L角点, 单边长直道</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆环执行"><a href="#圆环执行" class="headerlink" title="圆环执行"></a>圆环执行</h3><details ><summary pointer> run_circle() </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> 详细解读 </summary>              <div class='content'>              <details open><summary pointer> get_total_encoder() </summary>          <div class='content'>          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">get_total_encoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int64_t</span>) ((motor_l.total_encoder + motor_r.total_encoder) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个函数 <code>get_total_encoder()</code>，用于计算左右两个电机的编码器总和并取平均值。具体步骤如下：</p><ol><li>获取左电机和右电机的编码器值 <code>motor_l.total_encoder</code> 和 <code>motor_r.total_encoder</code>。</li><li>将左右两个电机的编码器值相加得到总和。</li><li>将总和除以2取平均值，然后以 <code>int64_t</code> 类型返回结果。</li></ol>          </div>        </details>              </div>            </details><p>track_type：单边得中线的边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">          current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑似乎与之前的代码相关，用于检测编码器在打表过1&#x2F;4圆时的状态，并进行相应的修正。让我来解释一下这段代码的作用：</p><ol><li>首先判断条件 <code>rpts0s_num &lt; 0.1 / sample_dist</code>，如果条件成立，说明小车还未行驶到1&#x2F;4圆的位置，或者右线未被检测到。</li><li>或者判断条件 <code>current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (3.14 * 1 / 2)</code>，这个条件看起来是在判断当前编码器值与开始打表时的编码器值之差是否超过了1&#x2F;4圆的周长对应的编码器值。</li><li>如果以上两个条件有一个成立，就会将 <code>circle_type</code> 设置为 <code>CIRCLE_LEFT_RUNNING</code>，表示小车正在左环行驶的阶段。</li></ol><p>在检测到小车行驶过1&#x2F;4圆或者右线为转弯时将 <code>circle_type</code> 修改为 <code>CIRCLE_LEFT_RUNNING</code>，可能是为了校准小车在左环赛道上行驶时的特定状态。这段代码与之前的代码一起，似乎在实现一个复杂的状态机来控制小车在左环赛道上的运动。如果您有更多的问题或需要进一步解释，请随时告诉我。</p><hr><p>什么是编码器打表:<br>编码器打表（Encoder Look-Up Table）通常指的是在编码器模块中使用查找表（Look-Up Table）来进行编码的过程。在信号处理领域或者通信系统中，编码器的作用是将输入信号转换为特定的编码形式，以便传输、存储或处理。而编码器打表的概念是通过预先构建一个表格，将输入信号映射到特定的编码值，从而实现编码的过程。</p><p>在这种情况下，编码器打表的优势在于可以提高编码的速度和效率。通过查找表，编码器可以以常量时间复杂度快速查找到对应的编码值，而不必每次都进行复杂的计算或逻辑判断。这样可以加快编码过程，特别是在需要频繁编码大量数据时，可以节省时间和计算资源。</p><p>总的来说，编码器打表是一种提高编码效率的方法，通过预先建立编码映射表，可以在编码过程中快速准确地找到对应的编码值，提高系统性能和速度。</p><hr><h2 id="迷宫巡线部分"><a href="#迷宫巡线部分" class="headerlink" title="迷宫巡线部分"></a>迷宫巡线部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前进方向定义：</span></span><br><span class="line"><span class="comment"> *   0</span></span><br><span class="line"><span class="comment"> * 3   1</span></span><br><span class="line"><span class="comment"> *   2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_front[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">1</span>,  <span class="number">0</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontleft[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontright[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_lefthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; half &lt; x &amp;&amp; x &lt; img-&gt;width - half - <span class="number">1</span> &amp;&amp; half &lt; y &amp;&amp; y &lt; img-&gt;height - half - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontleft_value = <span class="built_in">AT</span>(img, x + dir_frontleft[dir][<span class="number">0</span>], y + dir_frontleft[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontleft_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontleft[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontleft[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 右手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_righthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; <span class="number">0</span> &lt; x &amp;&amp; x &lt; img-&gt;width - <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt; img-&gt;height - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontright_value = <span class="built_in">AT</span>(img, x + dir_frontright[dir][<span class="number">0</span>], y + dir_frontright[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontright_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontright[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontright[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">warpPerspective</span><span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> flags = INTER_LINEAR, <span class="type">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> Scalar &amp;borderValue = Scalar())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>(!src.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">CV_Assert</span>(src.<span class="built_in">depth</span>() == CV_8U || src.<span class="built_in">depth</span>() == CV_32F);</span><br><span class="line">    <span class="built_in">CV_Assert</span>(M.<span class="built_in">rows</span>() == <span class="number">3</span> &amp;&amp; M.<span class="built_in">cols</span>() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">mapx</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">mapy</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">transform</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, CV_64F)</span></span>;</span><br><span class="line">    M.<span class="built_in">getMat</span>().<span class="built_in">colRange</span>(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">convertTo</span>(transform, transform.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buildWarpPerspectiveMaps</span>(transform, flags, dsize, mapx, mapy);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remap</span>(src, dst, mapx, mapy, flags, borderMode, borderValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是OpenCV中的warpPerspective函数的实现，用于对输入图像进行透视变换。下面是对代码中的函数及参数的详细解释：</p><h3 id="warpPerspective函数参数解释："><a href="#warpPerspective函数参数解释：" class="headerlink" title="warpPerspective函数参数解释："></a>warpPerspective函数参数解释：</h3><ul><li><strong>src</strong>：输入图像，类型为InputArray。</li><li><strong>dst</strong>：输出图像，类型为OutputArray。</li><li><strong>M</strong>：3x3的变换矩阵，描述了透视变换，类型为InputArray。</li><li><strong>dsize</strong>：输出图像的尺寸，类型为Size。</li><li><strong>flags</strong>：插值方法，用于指定在进行像素值插值时要使用的方法，默认为INTER_LINEAR。</li><li><strong>borderMode</strong>：边界像素插值模式，用于指定当目标图像像素位于源图像之外时的处理方式，默认为BORDER_CONSTANT。</li><li><strong>borderValue</strong>：边界填充的像素值，类型为Scalar。</li></ul><h3 id="warpPerspective函数主要步骤解释："><a href="#warpPerspective函数主要步骤解释：" class="headerlink" title="warpPerspective函数主要步骤解释："></a>warpPerspective函数主要步骤解释：</h3><ol><li><p><strong>CV_INSTRUMENT_REGION</strong>：用于性能测量和优化的宏定义。</p></li><li><p><strong>CV_Assert</strong>：断言，用于判断条件是否成立，如果条件不成立则会抛出一个异常。</p></li><li><p><strong>Mat mapx</strong>和<strong>Mat mapy</strong>：分别用于存储X和Y方向的映射结果。</p></li><li><p><strong>Mat transform</strong>：是一个2x3的矩阵，用于保存M矩阵的前两列，并将其转换为CV_64F类型。</p></li><li><p><strong>buildWarpPerspectiveMaps</strong>：根据透视变换矩阵和指定的插值方法，构建出目标图像在源图像上的映射关系。</p></li><li><p><strong>remap</strong>：根据生成的映射关系对输入图像进行透视变换，并存储结果到输出图像dst中。<br>  M.getMat().colRange(0, 2).convertTo(transform, transform.type());详细解释<br>  这行代码是针对OpenCV中的矩阵操作。让我逐步解释一下：</p></li><li><p><code>M.getMat()</code>: 这部分获取一个OpenCV的矩阵<code>M</code>。</p></li><li><p><code>.colRange(0, 2)</code>: 这个部分表示对该矩阵<code>M</code>的列进行切片操作，只选择从第0列到第2列（不包括第2列）的部分。</p></li><li><p><code>.convertTo(transform, transform.type())</code>: 这一部分是将切片后的列数据进行类型转换并赋值给另外一个矩阵<code>transform</code>。这里的<code>transform</code>是一个目标矩阵，它将包含转换后的数据。<code>transform.type()</code>返回<code>transform</code>矩阵的类型。</p></li></ol><p>因此，整体来看，这行代码的作用是从矩阵<code>M</code>中选择第0列到第1列的数据，并将其转换为指定类型，然后存储到矩阵<code>transform</code>中。</p><p>这是 <code>buildWarpPerspectiveMaps</code> 函数的伪代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWarpPerspectiveMaps</span><span class="params">(Size src_size, Matx33f M, <span class="type">bool</span> inverse_map, Mat&amp; xmap, Mat&amp; ymap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = src_size.width;</span><br><span class="line">    <span class="type">int</span> height = src_size.height;</span><br><span class="line">    </span><br><span class="line">    xmap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line">    ymap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            Vec3f src_pt = <span class="built_in">Vec3f</span>(x, y, <span class="number">1</span>); <span class="comment">// Source point</span></span><br><span class="line">            Vec3f dst_pt = M * src_pt;      <span class="comment">// Apply transformation matrix</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> map_x, map_y;</span><br><span class="line">            <span class="keyword">if</span> (!inverse_map) &#123;</span><br><span class="line">                map_x = dst_pt[<span class="number">0</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">                map_y = dst_pt[<span class="number">1</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map_x = src_pt[<span class="number">0</span>] - dst_pt[<span class="number">0</span>];</span><br><span class="line">                map_y = src_pt[<span class="number">1</span>] - dst_pt[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xmap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_x;</span><br><span class="line">            ymap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个伪代码实现描述了 <code>buildWarpPerspectiveMaps</code> 函数的大致操作步骤。实际的 <code>buildWarpPerspectiveMaps</code> 函数是 OpenCV 中用于构建透视变换映射的函数，具体实现会更加复杂并且包含了更多细节。如果你需要实际的代码实现，建议查阅 OpenCV 的源代码或者官方文档中提供的具体函数实现。希望这个简要描述能够帮助到你，如果有其他问题或者需要更多帮助，请随时告诉我。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>输入图像src不能为空。</li><li>输入图像src的深度必须为CV_8U或CV_32F。</li><li>变换矩阵M必须为一个3x3矩阵。</li><li>warpPerspective函数实现了透视变换的核心逻辑，通过构建变换矩阵并利用remap函数实现对图像的透视变换操作。</li></ul><p>如果你有任何关于这段代码的疑问或需要进一步解释，请随时告诉我。</p><p>@brief Applies a perspective transformation to an image.</p><p>The function warpPerspective transforms the source image using the specified matrix:</p><p>  [$\texttt{dst} (x,y) &#x3D;  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,<br>     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )$] </p><p>when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert<br>and then put in the formula above instead of M. The function cannot operate in-place.</p><p>@param src input image.<br>@param dst output image that has the size dsize and the same type as src .<br>@param M  $ 3\times 3 $ transformation matrix.<br>@param dsize size of the output image.<br>@param flags combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the<br>optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (<br>$\texttt{dst}\rightarrow\texttt{src} $ ).<br>@param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).<br>@param borderValue value used in case of a constant border; by default, it equals 0.</p><p>@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;圆环circle&quot;&gt;&lt;a href=&quot;#圆环circle&quot; class=&quot;headerlink&quot; title=&quot;圆环circle&quot;&gt;&lt;/a&gt;圆环circle&lt;/h2&gt;&lt;details &gt;&lt;summary pointer&gt; circle.c &lt;/summary&gt;
 </summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>逆透视</title>
    <link href="http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/"/>
    <id>http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/</id>
    <published>2024-04-26T17:14:17.000Z</published>
    <updated>2024-04-26T17:17:07.839Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief IPM初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param origSize 输入原始图像Size</span></span><br><span class="line"><span class="comment">     * @param dstSize 输出图像Size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> cv::Size &amp;origSize, <span class="type">const</span> cv::Size &amp;dstSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原始域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points at the input image</span></span><br><span class="line">        m_origPoints.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// [第二版无带畸变镜头参数]</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">0</span>, <span class="number">214</span>));   <span class="comment">// 左下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">319</span>, <span class="number">214</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">192</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">128</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矫正域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points correspondences in the destination image</span></span><br><span class="line">        m_dstPoints.<span class="built_in">clear</span>();</span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">400</span>)); <span class="comment">// 左下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">400</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        m_origSize = origSize;</span><br><span class="line">        m_dstSize = dstSize;</span><br><span class="line">        <span class="built_in">assert</span>(m_origPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; m_dstPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; <span class="string">&quot;Orig. points and Dst. points must vectors of 4 points&quot;</span>);</span><br><span class="line">        m_H = <span class="built_in">getPerspectiveTransform</span>(m_origPoints, m_dstPoints); <span class="comment">// 计算变换矩阵 [3x3]</span></span><br><span class="line">        m_H_inv = m_H.<span class="built_in">inv</span>();                                      <span class="comment">// 求解逆转换矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">createMaps</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>void init(const cv::Size &amp;origSize, const cv::Size &amp;dstSize)</code>: 这是一个名为<code>init</code>的函数，它接受两个参数<code>origSize</code>和<code>dstSize</code>，这两个参数是OpenCV库中的<code>cv::Size</code>类型，用来表示图像的尺寸。</p></li><li><p><code>m_origPoints.clear();</code>: 清空存储原始域点坐标的容器<code>m_origPoints</code>。</p></li><li><p><code>m_origPoints.push_back(Point2f(0, 214));</code>: 将<code>(0, 214)</code>点坐标添加到原始域的点坐标集合中，代表原始图像的左下角。</p></li><li><p>依次类推，将原始域的四个角的点坐标添加到<code>m_origPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_dstPoints.clear();</code>: 清空存储矫正域点坐标的容器<code>m_dstPoints</code>。</p></li><li><p><code>m_dstPoints.push_back(Point2f(100, 400));</code>: 将<code>(100, 400)</code>点坐标添加到矫正域的点坐标集合中，代表矫正图像的左下角。</p></li><li><p>依次类推，将矫正域的四个角的点坐标添加到<code>m_dstPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_origSize = origSize;</code>和<code>m_dstSize = dstSize;</code>: 将原始图像尺寸和目标图像尺寸保存下来。</p></li><li><p><code>assert(m_origPoints.size() == 4 &amp;&amp; m_dstPoints.size() == 4 &amp;&amp; &quot;Orig. points and Dst. points must vectors of 4 points&quot;);</code>: 使用<code>assert</code>断言来确保原始域和矫正域的点坐标集合都包含四个点。</p></li><li><p><code>m_H = getPerspectiveTransform(m_origPoints, m_dstPoints);</code>: 通过原始域和矫正域的点坐标计算透视变换矩阵<code>m_H</code>。</p></li><li><p><code>m_H_inv = m_H.inv();</code>: 求解透视变换矩阵<code>m_H</code>的逆矩阵，存储在<code>m_H_inv</code>中。</p></li><li><p><code>createMaps();</code>: 调用<code>createMaps</code>函数，创建地图。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据集标注json转xml脚本</title>
    <link href="http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/"/>
    <id>http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/</id>
    <published>2024-04-26T12:43:07.000Z</published>
    <updated>2024-04-26T12:47:40.715Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_json_to_xml</span>(<span class="params">json_data</span>):</span><br><span class="line">    root = ET.Element(<span class="string">&quot;annotation&quot;</span>)</span><br><span class="line">    filename = ET.SubElement(root, <span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    filename.text = json_data[<span class="string">&quot;imagePath&quot;</span>]</span><br><span class="line">    object_num = ET.SubElement(root, <span class="string">&quot;object_num&quot;</span>)</span><br><span class="line">    object_num.text = <span class="built_in">str</span>(<span class="built_in">len</span>(json_data[<span class="string">&quot;shapes&quot;</span>]))</span><br><span class="line">    size = ET.SubElement(root, <span class="string">&quot;size&quot;</span>)</span><br><span class="line">    width = ET.SubElement(size, <span class="string">&quot;width&quot;</span>)</span><br><span class="line">    width.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageWidth&quot;</span>])</span><br><span class="line">    height = ET.SubElement(size, <span class="string">&quot;height&quot;</span>)</span><br><span class="line">    height.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageHeight&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> json_data[<span class="string">&quot;shapes&quot;</span>]:</span><br><span class="line">        object_element = ET.SubElement(root, <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        name = ET.SubElement(object_element, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">        name.text = shape[<span class="string">&quot;label&quot;</span>]</span><br><span class="line">        difficult = ET.SubElement(object_element, <span class="string">&quot;difficult&quot;</span>)</span><br><span class="line">        difficult.text = <span class="string">&quot;0&quot;</span></span><br><span class="line">        bndbox = ET.SubElement(object_element, <span class="string">&quot;bndbox&quot;</span>)</span><br><span class="line">        xmin = ET.SubElement(bndbox, <span class="string">&quot;xmin&quot;</span>)</span><br><span class="line">        xmin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">        ymin = ET.SubElement(bndbox, <span class="string">&quot;ymin&quot;</span>)</span><br><span class="line">        ymin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line">        xmax = ET.SubElement(bndbox, <span class="string">&quot;xmax&quot;</span>)</span><br><span class="line">        xmax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">        ymax = ET.SubElement(bndbox, <span class="string">&quot;ymax&quot;</span>)</span><br><span class="line">        ymax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ET.tostring(root, encoding=<span class="string">&quot;unicode&quot;</span>)</span><br><span class="line">current_dir = os.getcwd()</span><br><span class="line">parent_dir = os.path.abspath(os.path.join(current_dir, os.pardir))</span><br><span class="line">output_dir = os.path.join(parent_dir, <span class="string">&quot;xml_output&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(current_dir):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&quot;.json&quot;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(current_dir, file), <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json_data = json.load(json_file)</span><br><span class="line">            xml_data = convert_json_to_xml(json_data)</span><br><span class="line">            xml_filename = file.replace(<span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">            output_path = os.path.join(output_dir, xml_filename)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> xml_file:</span><br><span class="line">                xml_file.write(xml_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有JSON文件已经转换为XML并保存在文件夹 xml_output 中&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="python" scheme="http://tumytime.github.io/tags/python/"/>
    
    <category term="数据集" scheme="http://tumytime.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>无人驾驶汽车系统入门（一）卡尔曼滤波与目标追踪</title>
    <link href="http://tumytime.github.io/2024/04/25/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    <id>http://tumytime.github.io/2024/04/25/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/</id>
    <published>2024-04-25T10:40:25.000Z</published>
    <updated>2024-04-26T07:50:11.547Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="卡尔曼滤波教程" href="https://www.kalmanfilter.net/CN/background_cn.html"><span class="link-card-backdrop" style="background-image: url(https://www.kalmanfilter.net/img/profile.png)"></span><div class="left"><img src="https://www.kalmanfilter.net/img/profile.png" class="lazyload placeholder" data-srcset="https://www.kalmanfilter.net/img/profile.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">卡尔曼滤波教程</p><p class="url">https://www.kalmanfilter.net/CN/background_cn.html</p></div></a></div><div class="tagLink"><a class="link-card" title="一个例子搞清楚（先验分布/后验分布/似然估计）" href="https://blog.csdn.net/qq_23947237/article/details/78265026"><span class="link-card-backdrop" style="background-image: url(https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)"></span><div class="left"><img src="https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">一个例子搞清楚（先验分布/后验分布/似然估计）</p><p class="url">https://blog.csdn.net/qq_23947237/article/details/78265026</p></div></a></div><p>在贝叶斯推断中，后验分布与先验分布和似然之间存在一种重要的关系，即后验分布正比于先验分布乘以似然。这种关系可以通过贝叶斯定理来进行推导和解释。</p><h3 id="贝叶斯定理："><a href="#贝叶斯定理：" class="headerlink" title="贝叶斯定理："></a>贝叶斯定理：</h3><p>贝叶斯定理描述了在观测到数据 $( D ) $后，参数 $( \theta )$ 的后验概率如何根据先验概率 $( P(\theta) )$ 和似然性函数 $( P(D|\theta) )$ 来更新。表达式如下：<br>$[ P(\theta|D) &#x3D; \frac{P(D|\theta) \times P(\theta)}{P(D)} ]$</p><p>其中：</p><ul><li>$( P(\theta|D) )$ 是在给定观测数据 $( D )$ 后参数$ ( \theta )$ 的后验概率；</li><li>$( P(D|\theta) )$ 是在给定参数 $( \theta ) $的条件下观测数据 $( D )$ 的似然性；</li><li>$( P(\theta) )$ 是参数 $( \theta )$ 的先验概率；</li><li>$( P(D) )$ 是数据 $( D )$ 的边际概率。</li></ul><h3 id="后验分布正比于先验分布乘以似然："><a href="#后验分布正比于先验分布乘以似然：" class="headerlink" title="后验分布正比于先验分布乘以似然："></a>后验分布正比于先验分布乘以似然：</h3><p>从贝叶斯定理中可以得出后验分布正比于先验分布乘以似然的结论，表达式如下：<br>$[ P(\theta|D) \propto P(D|\theta) \times P(\theta) ]$</p><p>这意味着后验分布与先验分布乘以似然性函数之间存在比例关系。具体解释如下：</p><ul><li>先验分布 $( P(\theta) )$ 描述了在观测数据之前对参数 $( \theta )$ 的不确定性的初始估计；</li><li>似然性函数 $( P(D|\theta) ) $描述了在给定参数 $( \theta )$ 的情况下观测到数据 $( D )$ 的概率；</li><li>后验分布 $( P(\theta|D) )$ 结合了先验信息和新数据的信息，提供了在给定数据 $( D )$ 后对参数 $( \theta )$ 的更准确估计。</li></ul><p>通过这种关系，我们可以利用先验知识和观测到的数据来更新对参数的估计，从而更好地理解数据和进行推断。这种贝叶斯方法在处理不确定性和小样本数据时非常有用。</p><iframe src="//player.bilibili.com/player.html?aid=399758288&bvid=BV1zo4y1J76H&cid=1164008541&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>卡尔曼滤波（Kalman Filter）是一种用于估计系统状态的数学算法，通过融合系统模型的预测信息和实际观测的测量信息，以优化对系统当前状态的估计。卡尔曼滤波算法的核心思想就是通过对系统状态的动态建模和不确定性的估计，来获得系统状态的最优估计。</p><p>具体来说，卡尔曼滤波通过以下步骤实现对当前状态的估计：</p><ol><li><p><strong>预测状态</strong>：首先根据系统的动态模型，利用系统的上一个状态值和系统的状态转移方程，预测系统的当前状态值。这一步是基于系统的内在规律进行的状态预测，不考虑观测值。</p></li><li><p><strong>更新状态</strong>：接着，卡尔曼滤波考虑到当前的测量值，即观测到的系统状态值。通过比较实际观测值和预测状态值之间的差异，结合系统的测量方程和协方差矩阵，更新对系统当前状态的估计。这一步可以理解为根据测量结果对系统状态进行修正和优化，同时考虑到测量误差和系统动态的不确定性。</p></li><li><p><strong>状态更新</strong>：经过预测和更新之后，卡尔曼滤波会根据预测和更新的结果来更新系统的状态估计和状态的不确定性，然后循环迭代这些步骤以获得对系统状态的连续估计。</p></li></ol><p>总的来说，卡尔曼滤波算法充分利用了系统动态模型和传感器测量信息，通过预测和更新的步骤来获得对系统状态的最优估计。通过同时考虑上一个状态值和当前的测量值，卡尔曼滤波能够有效地处理系统动态、测量误差和不确定性，从而提高对系统状态的估计精度。</p><h2 id="贝塞尔校正"><a href="#贝塞尔校正" class="headerlink" title="贝塞尔校正"></a>贝塞尔校正</h2><p>在高斯分布（正态分布）中，如果我们从总体分布中抽取一小部分样本来估计总体的方差，通常情况下样本方差会低估总体方差。这种现象的原因主要是由于样本抽取的局限性和高斯分布概率密度函数的形状所导致的。</p><p>当我们从高斯分布中抽取样本时，由于高斯分布的中心值（均值）具有更高的概率密度，大部分样本会集中在均值附近，而在分布的尾部（边沿）位置上，样本数量相对较少。因此，如果我们只从高斯分布的中心值附近抽取样本来估计总体方差，由于未能很好地覆盖整个分布，很可能会导致总体方差的低估。</p><p>样本方差的计算是基于样本数据与样本均值之间的差异来衡量的。当样本主要集中在总体分布的中心值附近时，部分样本与样本均值之间的差异相对较小，导致样本方差的计算结果较小。而总体的方差是考虑了整个分布范围内数据点与总体均值之间的差异（包括边缘值），因此总体方差通常会大于样本方差。</p><p>因此，由于样本主要集中在高斯分布的中心值附近且样本数量有限，使用这部分样本来估计总体的方差往往会低估总体方差。为了更准确地估计总体方差，可以考虑增加样本数量、在整个分布范围内均匀抽样或者使用更复杂的统计方法来处理这种情况。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2obbpl0e33.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2obbpl0e33.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;卡尔曼滤波器教程&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><h2 id="k阶原点矩和k阶中心矩"><a href="#k阶原点矩和k阶中心矩" class="headerlink" title="k阶原点矩和k阶中心矩"></a>k阶原点矩和k阶中心矩</h2><p>在统计学中，k阶原点矩和k阶中心矩是用于描述概率分布特性的概念。</p><ol><li><p>k阶原点矩：<br>对于一个随机变量X，它的k阶原点矩表示为μ_k &#x3D; E(X^k)，即该随机变量的k次幂的期望值。换句话说，k阶原点矩描述了随机变量X在k次幂上的平均值。</p></li><li><p>k阶中心矩：<br>对于一个随机变量X，它的k阶中心矩表示为μ’_k &#x3D; E[(X - μ)^k]，其中μ为随机变量X的期望值（均值）。k阶中心矩是指将随机变量X减去其均值后再取k次幂的期望。换句话说，k阶中心矩描述了随机变量X关于均值的k次幂的期望值。</p></li></ol><p>关于k阶原点矩和k阶中心矩的一些关键点：</p><ul><li>k阶原点矩包含数据的绝对信息，而k阶中心矩包含数据的相对信息。</li><li>一阶中心矩始终为0，因为它表示随机变量减去自身的均值，结果必然为0。</li><li>二阶中心矩是方差的平方根，用于衡量数据的离散程度。</li><li>三阶中心矩是偏度，用于衡量分布的对称性。</li><li>四阶中心矩是峰度，用于衡量分布的尖峭程度或平坦度。</li></ul><p>总的来说，k阶原点矩和k阶中心矩是用于深入了解随机变量数据分布特性的重要统计量。它们提供了关于数据的高阶统计信息，能够帮助我们更全面地理解随机变量的性质和行为。</p><h2 id="准度和精度"><a href="#准度和精度" class="headerlink" title="准度和精度"></a>准度和精度</h2><p>准度和精度是两个经常在科学与工程领域中使用的概念，它们表示了测量结果或数据的质量，但在含义上有所不同。</p><ol><li><p>准度（Accuracy）：<br>准度指的是测量结果或数据与真实数值之间的偏差程度，即测量结果的接近程度。如果测量结果与真实数值非常接近，则认为该测量是准确的，具有高准度。准度通常用误差或偏差来表示，可以是系统性的（偏差恒定）或随机性的（随机误差）。在实际应用中，准度的提高意味着更接近真实值的测量结果，即更少的误差。</p></li><li><p>精度（Precision）：<br>精度指的是多次测量所得结果之间的一致性或重复性，即测量结果的稳定程度。如果多次测量所得结果非常接近，可以认为该测量是精确的，具有高精度。精度通常用标准偏差或方差来描述，用来衡量测量数据的离散程度。在实际应用中，精度的提高意味着测量结果之间的一致性更高，即数据更加稳定。</p></li></ol><p>区别总结：</p><ul><li>准度强调测量结果与真实值之间的接近程度，而精度强调多次测量结果之间的一致性。</li><li>准度涉及测量结果的准确程度，精度涉及测量结果的稳定程度。</li><li>提高准度意味着减少与真实值的差距，而提高精度意味着增加测量结果之间的一致性。</li></ul><p>在实际应用中，准确度和精度通常需要平衡考虑。一个测量既要准确地表达真实值，又要具有重复性和一致性，这样才能提供可靠的数据支持科学研究、工程设计等领域的决策和判断。</p><h2 id="α−β−γ滤波器和卡尔曼滤波器的联系和区别"><a href="#α−β−γ滤波器和卡尔曼滤波器的联系和区别" class="headerlink" title="α−β−γ滤波器和卡尔曼滤波器的联系和区别"></a>α−β−γ滤波器和卡尔曼滤波器的联系和区别</h2><p>α-β-γ滤波器和卡尔曼滤波器都是用于估计系统状态的滤波器，它们有一些联系和区别：</p><ol><li><p>联系：</p><ul><li>两者都是常用的滤波器算法，用于估计系统的状态，并对传感器数据进行平滑处理。</li><li>在一定程度上，α-β-γ滤波器可以看作是卡尔曼滤波器的一种简化版本，适用于一些简单的系统。</li></ul></li><li><p>区别：</p><ul><li>卡尔曼滤波器是一种基于状态空间模型的递归滤波器，可以处理具有高斯噪声的动态系统。它通过状态估计和误差协方差估计来最优地结合先验信息和测量数据。相比之下，α-β-γ滤波器是一种更简单的滤波器，通常用于低成本的应用和对计算资源要求较低的场景。</li><li>在单个维度上，α-β-γ滤波器可用于对加速度数据进行滤波和平滑处理，而卡尔曼滤波器更常用于多维度状态估计，例如跟踪移动目标。</li><li>卡尔曼滤波器在处理非线性系统和非高斯噪声时效果更好，因为它能够自适应地调整协方差矩阵。而α-β-γ滤波器则更适用于线性系统或高斯噪声的情况。</li></ul></li></ol><p>总的来说，卡尔曼滤波器是一种更加通用和灵活的滤波器算法，适用于较为复杂的系统状态估计问题，而α-β-γ滤波器则是一种简单的滤波器算法，适用于一些简单的系统平滑处理任务。选择哪种滤波器取决于具体的应用场景和系统要求。</p><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p><strong>Q:</strong><br>卡尔曼滤波是根据上一次的值得出的这一次的预测值和这一次的测量值这两个值加权求得的值吗<br><strong>A:</strong><br>卡尔曼滤波是一种用于估计系统状态的强大技术，确实涉及到对上一次状态的估计值、当前时刻的测量值和预测值进行加权平均。在卡尔曼滤波中，系统状态被表示为一个含有状态变量的向量，而系统的动态行为通常由一组线性动态方程和一组线性测量方程描述。</p><p>在每个时间步，卡尔曼滤波器执行以下两个主要步骤：</p><ol><li><p><strong>预测步骤（Predict）</strong>：基于上一次的状态估计以及系统动态方程，预测系统的当前状态。这一预测考虑了上一次的状态估计和系统行为模型，产生一个预测的状态和协方差估计。</p></li><li><p><strong>更新步骤（Update）</strong>：将预测的状态与当前的测量值进行比较，根据二者的关系来修正预测状态，得到更准确的状态估计。这一步骤涉及卡尔曼增益的计算，以确保预测状态和测量状态之间的加权平均。</p></li></ol><p>因此，在卡尔曼滤波中，通过将上一次的状态估计、当前时刻的预测值和测量值进行合理的加权组合，可以更好地估计系统的真实状态，并对噪声进行有效抑制。整个过程通过不断迭代预测和更新步骤，逐渐提高状态估计的准确性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;卡尔曼滤波教程&quot; href=&quot;https://www.kalmanfilter.net/CN/background_cn.html&quot;&gt;&lt;span class=&quot;link-card-b</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="无人驾驶" scheme="http://tumytime.github.io/tags/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6/"/>
    
    <category term="概率论" scheme="http://tumytime.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯嵌入式客观题笔记</title>
    <link href="http://tumytime.github.io/2024/03/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%A2%E8%A7%82%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://tumytime.github.io/2024/03/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%A2%E8%A7%82%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-30T08:23:34.000Z</published>
    <updated>2024-03-31T08:04:37.417Z</updated>
    
    <content type="html"><![CDATA[<details open><summary pointer> 时序逻辑电路 </summary>              <div class='content'>              <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8hg8xhmilq.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8hg8xhmilq.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>时序逻辑电路:</strong><br>计数器<br>分频器<br>触发器<br>积分器<br>移位寄存器<br>时序比较器<br><strong>组合逻辑电路:</strong><br>逻辑门<br>译码器<br>编码器<br>多路选择器<br>加法器<br>比较器<br>数字比例调节器</p>              </div>            </details><details open><summary pointer> 减法计数器 </summary>              <div class='content'>              <p>一个 8位二进制减法计数器， 初始状态为 00000000， 问经过 268个输入脉冲后， 此计数器的状态为 ______。<br>A.11001111<br>B.11110100<br>C.11110010<br>D.11110011<br>答案：B<br>解析：8位二进制数计数2^8 &#x3D; 256次后回到00000000，还剩268-256&#x3D;12次计数，计数1次后从“00000000”减为“11111111”，此后再减11（00001011），得到11110100，选B。<br>1111 1111<br>– 0000 1011<br>1111 0100</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;details open&gt;&lt;summary pointer&gt; 时序逻辑电路 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="stm32" scheme="http://tumytime.github.io/tags/stm32/"/>
    
    <category term="蓝桥杯" scheme="http://tumytime.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>摄像头考核</title>
    <link href="http://tumytime.github.io/2024/03/25/%E6%91%84%E5%83%8F%E5%A4%B4%E8%80%83%E6%A0%B8/"/>
    <id>http://tumytime.github.io/2024/03/25/%E6%91%84%E5%83%8F%E5%A4%B4%E8%80%83%E6%A0%B8/</id>
    <published>2024-03-25T13:50:31.000Z</published>
    <updated>2024-03-25T13:50:49.176Z</updated>
    
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像处理笔记（二）灰度变换和空间滤波基础</title>
    <link href="http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%92%8C%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%9F%BA%E7%A1%80/"/>
    <id>http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%92%8C%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-25T13:04:31.000Z</published>
    <updated>2024-03-25T13:50:12.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灰度变换和空间滤波基础"><a href="#灰度变换和空间滤波基础" class="headerlink" title="灰度变换和空间滤波基础"></a>灰度变换和空间滤波基础</h2><h3 id="灰度变换（灰度反转，对数变换，幂律变换）"><a href="#灰度变换（灰度反转，对数变换，幂律变换）" class="headerlink" title="灰度变换（灰度反转，对数变换，幂律变换）"></a>灰度变换（灰度反转，对数变换，幂律变换）</h3><h4 id="灰度变换原理"><a href="#灰度变换原理" class="headerlink" title="灰度变换原理"></a>灰度变换原理</h4><p>变换原理：通过变换函数T将原图像像素灰度值r映射为灰度值s：</p><p>$s&#x3D;T(r)$</p><h4 id="灰度反转"><a href="#灰度反转" class="headerlink" title="灰度反转"></a>灰度反转</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h5><p>灰度反转：将图像亮暗对调，可以增强图像中暗色区域细节<br>$s&#x3D;T(r)&#x3D;L-1-r$<br>其中L为图像灰度级，0~255灰度图像的灰度级为256.</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="comment">//遍历像素点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) = <span class="number">255</span> - image1_gray.at&lt;uchar&gt;(i, j);  <span class="comment">//灰度反转</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);  <span class="comment">//显示反转图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lvht9o5v6.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lvht9o5v6.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>对数变换：扩展图像中的暗像素值，压缩高灰度值。<br>$s&#x3D;T(r)&#x3D;c*log(1+r)$<br>$log(1+r)$斜率逐渐降低，上升趋势逐渐放缓</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) = <span class="number">6</span> * <span class="built_in">log</span>((<span class="type">double</span>)(image1_gray.at&lt;uchar&gt;(i, j)) + <span class="number">1</span>);  <span class="comment">//对数变换 s=6*log(r+1)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">normalize(output_image, output_image, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);  <span class="comment">//图像归一化，转到0~255范围内</span></span><br><span class="line">convertScaleAbs(output_image, output_image);  <span class="comment">//数据类型转换到CV_8U</span></span><br><span class="line">imshow(<span class="string">&quot; output_image&quot;</span>, output_image);  <span class="comment">//显示变换图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3uulpxj04i.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3uulpxj04i.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="幂律（伽马变换）"><a href="#幂律（伽马变换）" class="headerlink" title="幂律（伽马变换）"></a>幂律（伽马变换）</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>幂律变换与对数变换类似：<br>$s&#x3D;T(r)&#x3D;c*r^γ$</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) =<span class="number">6</span>*<span class="built_in">pow</span>((<span class="type">double</span>)image1_gray.at&lt;uchar&gt;(i, j),<span class="number">0.5</span>);  <span class="comment">//幂律变换 s=6*r^0.5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">normalize(output_image, output_image, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);  <span class="comment">//图像归一化，转到0~255范围内</span></span><br><span class="line">convertScaleAbs(output_image, output_image);  <span class="comment">//数据类型转换到CV_8U</span></span><br><span class="line">imshow(<span class="string">&quot; output_image&quot;</span>, output_image);  <span class="comment">//显示变换图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2obahbyue1.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2obahbyue1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="直方图处理（直方图均衡化，直方图匹配（规定化））"><a href="#直方图处理（直方图均衡化，直方图匹配（规定化））" class="headerlink" title="直方图处理（直方图均衡化，直方图匹配（规定化））"></a>直方图处理（直方图均衡化，直方图匹配（规定化））</h3><p>直方图显示了每个像素值在整幅图像中出现的频率或数量，从而帮助我们理解图像的亮度分布情况。</p><h4 id="图像直方图"><a href="#图像直方图" class="headerlink" title="图像直方图"></a>图像直方图</h4><p>非归一化直方图:<br>$h(r_k)&#x3D;n_k$<br>归一化直方图:<br>$p(r_k)&#x3D;{n_k \over MN}$<br>其中MN为图像行数和列数，常说的图像直方图就是归一化直方图。</p><p>获取图像直方图示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image, image_gray, hist;   <span class="comment">//定义输入图像，灰度图像, 直方图</span></span><br><span class="line">image = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image, image_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image_gray&quot;</span>, image_gray);   <span class="comment">//显示灰度图像</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取图像直方图</span></span><br><span class="line"><span class="type">int</span> histsize = <span class="number">256</span>;</span><br><span class="line"><span class="type">float</span> ranges[] = &#123; <span class="number">0</span>,<span class="number">256</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* histRanges = &#123; ranges &#125;;</span><br><span class="line">calcHist(&amp;image_gray, <span class="number">1</span>, <span class="number">0</span>, Mat(), hist, <span class="number">1</span>, &amp;histsize, &amp;histRanges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这段代码用于计算图像的直方图，下面是对这段代码的详细解释：</p><ol><li><p><strong>histsize &#x3D; 256：</strong> 这里定义了直方图的大小为256，表示直方图的横轴范围，通常对应着图像可能的像素值范围（0到255）。</p></li><li><p><strong>ranges[] &#x3D; {0, 256}：</strong> 这里定义了直方图可能的像素值范围为0到256，用于指定直方图中每个像素值的范围。</p></li><li><p><em><em>const float</em> histRanges &#x3D; {ranges};</em>* 这一行用于将ranges数组转换为指向常量浮点数的指针，供calcHist函数使用。</p></li><li><p><strong>calcHist(&amp;image_gray, 1, 0, Mat(), hist, 1, &amp;histsize, &amp;histRanges, true, false)：</strong></p><ul><li><strong>&amp;image_gray：</strong> 这是输入的灰度图像，表示要计算直方图的原始图像。</li><li><strong>1：</strong> 表示要计算的图像数量。</li><li><strong>0：</strong> 表示直方图要计算的通道索引，0表示灰度图像。</li><li><strong>Mat()：</strong> 这里是一个掩码图像，用于指定要计算直方图的区域；在这里没有使用，因此为空。</li><li><strong>hist：</strong> 这是用于存储计算后直方图的Mat对象。</li><li><strong>1：</strong> 直方图的维数，对于灰度图像是1维。</li><li><strong>&amp;histsize：</strong> 这是包含直方图大小（256）的指针。</li><li><strong>&amp;histRanges：</strong> 指向直方图范围的指针。</li><li><strong>true：</strong> 指示直方图是否均一化，即在范围0到255内对直方图进行归一化处理。</li><li><strong>false：</strong> 指示直方图是否累积，即表示直方图是否累积计算。</li></ul></li></ol><p>通过这段代码，可以通过calcHist函数计算图像image_gray的直方图，并将结果存储在hist对象中。直方图的范围是0到255之间，且进行了归一化处理。这能够帮助我们了解图像的像素值分布情况，为后续的图像处理和分析提供数据支持。希望这个解释对您有帮助，如果您有任何其他问题，请随时告诉我！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建直方图显示图像</span></span><br><span class="line"><span class="type">int</span> hist_h = <span class="number">300</span>;<span class="comment">//直方图的图像的高</span></span><br><span class="line"><span class="type">int</span> hist_w = <span class="number">512</span>; <span class="comment">//直方图的图像的宽</span></span><br><span class="line"><span class="type">int</span> bin_w = hist_w / histsize;<span class="comment">//直方图的等级</span></span><br><span class="line">Mat <span class="title function_">histImage</span><span class="params">(hist_h, hist_w, CV_8UC3, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span>;<span class="comment">//绘制直方图显示的图像</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制并显示直方图</span></span><br><span class="line">normalize(hist, hist, <span class="number">0</span>, hist_h, NORM_MINMAX, <span class="number">-1</span>, Mat());<span class="comment">//归一化直方图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; histsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">line(histImage, Point((i - <span class="number">1</span>) * bin_w, hist_h - cvRound(hist.at&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">Point((i)*bin_w, hist_h - cvRound(hist.at&lt;<span class="type">float</span>&gt;(i))), Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;histImage&quot;</span>, histImage);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于将归一化后的直方图数据绘制成直方图图像的过程。下面是对代码的详细解释：</p><ol><li><p><strong><code>for</code>循环：</strong></p><ul><li>这段代码使用<code>for</code>循环遍历直方图的每个条，从第2个条开始到最后一个条。</li><li><code>i</code>从1开始，因为第0个条通常代表背景，可以跳过不绘制。</li></ul></li><li><p><strong><code>line()</code>函数：</strong></p><ul><li><code>line()</code>函数用于在<code>histImage</code>上绘制直方图的条。</li><li><code>Point((i - 1) * bin_w, hist_h - cvRound(hist.at&lt;float&gt;(i - 1)))</code>表示当前条的起始点位置，前一个条的结束点位置。</li><li><code>Point((i)*bin_w, hist_h - cvRound(hist.at&lt;float&gt;(i)))</code> 表示当前条的终点位置。</li><li><code>Scalar(255, 0, 0)</code>指定绘制直线的颜色为蓝色。</li><li><code>2</code>表示线的粗细为2个像素。</li><li><code>8</code>表示线的类型为8-connected。</li><li><code>0</code>表示线的偏移值为0。</li></ul></li><li><p><strong>绘制直方图条：</strong></p><ul><li>通过计算每个直方图条的起始和终止点，使用<code>line()</code>函数在<code>histImage</code>上绘制直方图条。</li><li><code>cvRound()</code>用于将浮点值四舍五入为最接近的整数，确保直方图能够正确映射到图像上。</li></ul></li></ol><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>(我感觉差不多了，我去做考核咯~)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;灰度变换和空间滤波基础&quot;&gt;&lt;a href=&quot;#灰度变换和空间滤波基础&quot; class=&quot;headerlink&quot; title=&quot;灰度变换和空间滤波基础&quot;&gt;&lt;/a&gt;灰度变换和空间滤波基础&lt;/h2&gt;&lt;h3 id=&quot;灰度变换（灰度反转，对数变换，幂律变换）&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像处理笔记（一）基础操作</title>
    <link href="http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-1/</id>
    <published>2024-03-25T03:51:05.000Z</published>
    <updated>2024-03-25T13:05:31.723Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面一部分笔记都是学习一个大佬的教程做的，但是大佬用的python，我在笔记里都转换成了c++</p></blockquote><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2kroj52zde.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2kroj52zde.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.pf3qismjr.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.pf3qismjr.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4g49bri91j.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4g49bri91j.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1set1eq2uf.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1set1eq2uf.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.58h4ti0gy2.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.58h4ti0gy2.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1hrz89c5f9.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1hrz89c5f9.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="图片基本读取操作"><a href="#图片基本读取操作" class="headerlink" title="图片基本读取操作"></a>图片基本读取操作</h2><p>电脑上的彩色图是以 RGB(红 - 绿-蓝，Red-Green-Blue) 颜色模式显示的，但 OpenCV 中彩色图是以 B-G-R 通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是 y，列对应的是 x：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.54xivstf47.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.54xivstf47.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><blockquote><span class='pbg info'>imread()</span><blockquote><p><strong>两个参数:</strong></p><ul><li>参数 1：图片的文件名<br> 如果图片放在当前文件夹下，直接写文件名就行，如”lena.jpg”<br> 否则需要给出绝对路径，如”C:&#x2F;Users&#x2F;lxcqm&#x2F;Desktop&#x2F;图片和视频&#x2F;11111.png”</li><li>参数 2：读入方式，省略即采用默认值<br> cv2.IMREAD_COLOR：彩色图，默认值(1)or(IMREAD_COLOR)<br> cv2.IMREAD_GRAYSCALE：灰度图(0)or(IMREAD_GRAYSCALE)<br> cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)or(IMREAD_UNCHANGED)</li></ul></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载灰度图</span></span><br><span class="line">Mat  img = imread(<span class="string">&quot;C:/Users/lxcqm/Desktop/images/11111.png&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，print(img)的结果为 None，后面处理才会报错，算是个小坑。</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>使用<code>imshow()</code>显示图片，窗口会自适应图片的大小：</p><blockquote><p><code>imshow()</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载灰度图</span></span><br><span class="line">Mat  img = imread(<span class="string">&quot;C:/Users/lxcqm/Desktop/images/11111.png&quot;</span>,<span class="number">0</span>);</span><br><span class="line">imshow(<span class="string">&quot;pic&quot;</span>, img);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数 1 是窗口的名字，参数 2 是要显示的图片。不同窗口之间用窗口名区分，所以窗口名相同就表示是同一个窗口，显示结果如下：<br><strong>效果:</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.32hq7r8seh.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.32hq7r8seh.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p><code>waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒 ms）。<br>时间一到，会继续执行接下来的程序，传入 0 的话表示一直等待。等待期间也可以获取用户的按键输入：k &#x3D; waitKey(0)</p></blockquote><p>我们也可以先用<code>namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namedWindow(<span class="string">&quot;pic2&quot;</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">&quot;pic2&quot;</span>, img);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数 1 依旧是窗口的名字，参数 2 默认是<code>WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><blockquote><p><code>imwrite()</code></p></blockquote><p>使用<code>imwrite()</code>保存图片，参数 1 是包含后缀名的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imwrite(<span class="string">&quot;pictest.jpg&quot;</span>, img);</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.sypoa1fpo.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.sypoa1fpo.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>会保存在目录文件夹里</p><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><h3 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h3><p>要使用摄像头，需要使用<code>VideoCapture capture(0);</code>参数 <code>0</code> 指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第 2 个摄像头就可以传入 <code>1</code>，依此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        <span class="comment">//&gt;&gt; 是输入流提取运算符</span></span><br><span class="line">        <span class="comment">// 它通常用于从输入流中提取数据并将其存储在相应的变量中</span></span><br><span class="line">        <span class="comment">// 表示从 capture 输入流中读取数据，并将其存储在 frame 变量中</span></span><br><span class="line">        capture &gt;&gt; frame;</span><br><span class="line"></span><br><span class="line">        Mat gray;</span><br><span class="line">        cvtColor(frame, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        imshow(<span class="string">&quot;frame&quot;</span>, gray);</span><br><span class="line">        <span class="keyword">if</span> (waitKey(<span class="number">1</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。<br>通过cap.get(propId)可以获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等。propId 是从 0~18 的数字，代表不同的属性，完整的属性列表可以参考：VideoCaptureProperties(<a href="https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d">https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d</a>)<br>也可以使用cap.set(propId,value)来修改属性值。比如说，我们在 while 之前添加下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> width = capture.get(CAP_PROP_FRAME_WIDTH);</span><br><span class="line"><span class="type">double</span> height = capture.get(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">capture.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>);</span><br><span class="line">capture.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><details open><summary pointer> std::cout << Original width: << width << </summary>              <div class='content'>              <p>这行代码使用了C++中的流输出操作符”&lt;&lt;”，它用于将数据插入到输出流中。在这个语句中：</p><ul><li><code>std::cout</code>: 是C++标准库中的标准输出流对象，用于将数据输出到控制台。</li><li><code>&quot;Original width: &quot;</code>、<code>width</code>、<code>&quot;, height: &quot;</code>、<code>height</code>、<code>std::endl</code> 都是要输出的具体内容。</li><li><code>&lt;&lt;</code>：是流输出操作符，用于将后面的内容插入到输出流中。</li></ul><p>所以，<code>std::cout &lt;&lt; &quot;Original width: &quot; &lt;&lt; width &lt;&lt; &quot;, height: &quot; &lt;&lt; height &lt;&lt; std::endl;</code> 这行代码的作用是将描述原始宽度和高度的字符串以及相应的变量值输出到控制台，并在最后换行。</p>              </div>            </details><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.86texdkg7l.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.86texdkg7l.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h3 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h3><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为 <code>25</code> 或 <code>30</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="string">&quot;C:/Users/lxcqm/Desktop/WeChat_20240325194731.mp4&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error opening video file&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     Mat frame, gray;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!capture.read(frame)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cvtColor(frame, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        imshow(<span class="string">&quot;frame&quot;</span>, gray);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitKey(<span class="number">30</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    capture.release();</span><br><span class="line">    destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义编码方式并创建 VideoWriter 对象</span></span><br><span class="line">    VideoWriter <span class="title function_">outfile</span><span class="params">(<span class="string">&quot;output.avi&quot;</span>, VideoWriter::fourcc(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>), <span class="number">25.</span>, Size(<span class="number">640</span>, <span class="number">480</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (capture.isOpened()) &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture.read(frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!frame.empty()) &#123;</span><br><span class="line">            outfile.write(frame); <span class="comment">// 写入文件</span></span><br><span class="line">            imshow(<span class="string">&quot;frame&quot;</span>, frame);</span><br><span class="line">            <span class="keyword">if</span> (waitKey(<span class="number">1</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Mat创建图像（矩阵）"><a href="#Mat创建图像（矩阵）" class="headerlink" title="Mat创建图像（矩阵）"></a>Mat创建图像（矩阵）</h3><h4 id="创建图像（矩阵）：Mat"><a href="#创建图像（矩阵）：Mat" class="headerlink" title="创建图像（矩阵）：Mat"></a>创建图像（矩阵）：Mat</h4><p>使用Mat创建图像（矩阵）的常用形式有：</p><ol><li><p>创建一个空图像，大小为0</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat image1;</span><br></pre></td></tr></table></figure></li><li><p>指定矩阵大小，指定数据类型：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U)</span>;</span><br></pre></td></tr></table></figure><p> 参数:矩阵行数，矩阵列数，数据类型</p><p> 其中数据类型有很多种，常用的应该有：</p><p> CV_8U：8位无符号型（0~255），即灰度图像；</p><p> CV_8UC3：三通道8位无符号型，这里三通道指B（蓝）G（绿）R（红），与matlab中的RGB正好相反。</p><p> 这里创建矩阵时未指定矩阵的值，发现默认值的大小为205.</p></li><li><p>指定矩阵大小，指定数据类型，设置初始值：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, <span class="number">100</span>)</span>;</span><br></pre></td></tr></table></figure><p> 这里包含四个参数：矩阵行数，矩阵列数，数据类型，初始值；<br> 对于灰度图像：可以直接给出初始值，也可以使用Scalar（）；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, <span class="number">100</span>)</span>;</span><br><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, Scalar(<span class="number">100</span>))</span>;<span class="comment">//Scalar:标量</span></span><br></pre></td></tr></table></figure><p> 对于三通道图像：使用Scalar（）；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8UC3, Scalar(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>))</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取图像信息"><a href="#获取图像信息" class="headerlink" title="获取图像信息"></a>获取图像信息</h3><p>获取图像的宽度（列数），高度（行数），尺寸和通道数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的行数为： &quot;</span> &lt;&lt; image1.rows &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的高度，行数；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的列数为： &quot;</span> &lt;&lt; image1.cols &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的宽度，列数；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的通道数为： &quot;</span> &lt;&lt; image1.channels() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的通道数，彩色图=3，灰度图=1；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的尺寸为： &quot;</span> &lt;&lt; image1.size &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的尺寸，行*列；</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.64dm9cq5y1.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.64dm9cq5y1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="感兴趣区域"><a href="#感兴趣区域" class="headerlink" title="感兴趣区域"></a>感兴趣区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line">Mat <span class="title function_">imageROI</span><span class="params">(image1, Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>))</span>;  <span class="comment">//定义感兴趣区域</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Rect（）有四个参数，Rect（a,b,c,d）:</p><ul><li>a：感兴趣区域列(cols)的起点；</li><li>b：感兴趣区域行(rows)的起点；</li><li>c：感兴趣区域的列数(cols)；</li><li>d：感兴趣区域的行数(rows)；</li></ul><h3 id="通过鼠标点击操作获取图像的像素坐标和像素值"><a href="#通过鼠标点击操作获取图像的像素坐标和像素值" class="headerlink" title="通过鼠标点击操作获取图像的像素坐标和像素值"></a>通过鼠标点击操作获取图像的像素坐标和像素值</h3><h4 id="创建鼠标操作函数的头文件"><a href="#创建鼠标操作函数的头文件" class="headerlink" title="创建鼠标操作函数的头文件"></a>创建鼠标操作函数的头文件</h4><details open><summary pointer> onMouse.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span>;  <span class="comment">//evnet:鼠标事件类型 x,y:鼠标坐标 flags：鼠标哪个键</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span>  <span class="comment">//evnet:鼠标事件类型 x,y:鼠标坐标 flags：鼠标哪个键</span></span><br><span class="line">&#123;</span><br><span class="line">Mat* im = reinterpret_cast&lt;Mat*&gt;(param);</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVENT_LBUTTONDOWN:</span><br><span class="line"><span class="comment">//显示图像像素值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (static_cast&lt;<span class="type">int</span>&gt;(im-&gt;channels()) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若图像为单通道图像，则显示鼠标点击的坐标以及灰度值</span></span><br><span class="line"><span class="keyword">switch</span> (im-&gt;type())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;uchar&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">char</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;ushort&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">short</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">int</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">float</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">double</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若图像为彩色图像，则显示鼠标点击坐标以及对应的B, G, R值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;  B value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">0</span>])</span><br><span class="line">&lt;&lt; <span class="string">&quot;  G value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">1</span>])</span><br><span class="line">&lt;&lt; <span class="string">&quot;  R value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">2</span>])</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setMouseCallback(&quot;image1&quot;, onMouse, reinterpret_cast&lt;void*&gt;(&amp;image1)); //关联图像显示窗口和onMouse函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat每个格子内的数据格式---------- - Mat定义</span></span><br><span class="line"><span class="comment">//Mat_&lt;uchar&gt;-------- - CV_8U（0-255）</span></span><br><span class="line"><span class="comment">//Mat&lt;char&gt;---------- - CV_8S（-128-127）</span></span><br><span class="line"><span class="comment">//Nat_&lt;short&gt;-------- - CV_16S（-32768-32767）</span></span><br><span class="line"><span class="comment">//Mat_&lt;ushort&gt;--------CV_16U（0-65535）</span></span><br><span class="line"><span class="comment">//Mat_&lt;int&gt;---------- - CV_32S（-2147483648-2147483647）</span></span><br><span class="line"><span class="comment">//Mat_&lt;float&gt;----------CV_32F（-FLT_MAX…FLT_MAX，INF，NAN）</span></span><br><span class="line"><span class="comment">//Mat_&lt;double&gt;--------CV_64F（-DBL_MAX…DBL_MAX，INF，NAN）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat数据类型和通道对应的type()</span></span><br><span class="line"><span class="comment">//              C1          C2          C3          C4</span></span><br><span class="line"><span class="comment">//CV_8U         0           8           16          24</span></span><br><span class="line"><span class="comment">//CV_8S         1           9           17          25</span></span><br><span class="line"><span class="comment">//CV_16U        2          10           18          26</span></span><br><span class="line"><span class="comment">//CV_16S        3          11           19          27</span></span><br><span class="line"><span class="comment">//CV_32S        4          12           20          28</span></span><br><span class="line"><span class="comment">//CV_32F        5          13           21          29</span></span><br><span class="line"><span class="comment">//CV_64F        6          14           22          30</span></span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><details open><summary pointer>  </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onMouse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setMouseCallback(<span class="string">&quot;image1&quot;</span>, onMouse, reinterpret_cast&lt;<span class="type">void</span>*&gt;(&amp;image1)); <span class="comment">//关联图像显示窗口和onMouse函数</span></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6f0g2iecfm.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6f0g2iecfm.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="访问图像像素"><a href="#访问图像像素" class="headerlink" title="访问图像像素"></a>访问图像像素</h3><h4 id="访问（j-i）处像素"><a href="#访问（j-i）处像素" class="headerlink" title="访问（j,i）处像素"></a>访问（j,i）处像素</h4><p>以8位（0~255）灰度图像和BGR彩色图像为例，用at可以访问图像像素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灰度图像：</span></span><br><span class="line">image.at&lt;uchar&gt;(j, i) <span class="comment">//j为行数，i为列数</span></span><br><span class="line"><span class="comment">//BGR彩色图像</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>] <span class="comment">//B分量</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>] <span class="comment">//G分量</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>] <span class="comment">//R分量</span></span><br></pre></td></tr></table></figure><p><strong>例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">50</span>, j = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> b = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> g = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> r = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像该点的像素(BGR):&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">waitKey(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7p22d7s7r.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7p22d7s7r.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="在图像中加入白色椒盐噪声"><a href="#在图像中加入白色椒盐噪声" class="headerlink" title="在图像中加入白色椒盐噪声"></a>在图像中加入白色椒盐噪声</h4><h5 id="创建Salt头文件"><a href="#创建Salt头文件" class="headerlink" title="创建Salt头文件"></a>创建Salt头文件</h5><details open><summary pointer> Salt.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span>  <span class="comment">//随机数头文件</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Salt</span><span class="params">(Mat image, <span class="type">int</span> n)</span>; <span class="comment">//n：加入噪声点数</span></span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="创建Salt源文件"><a href="#创建Salt源文件" class="headerlink" title="创建Salt源文件"></a>创建Salt源文件</h5><details open><summary pointer> Salt.cpp </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Salt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Salt</span><span class="params">(Mat image, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//随机数生成器</span></span><br><span class="line">default_random_engine generater;</span><br><span class="line">uniform_int_distribution&lt;<span class="type">int</span>&gt;randomRow(<span class="number">0</span>, image.rows - <span class="number">1</span>);</span><br><span class="line">uniform_int_distribution&lt;<span class="type">int</span>&gt;randomCol(<span class="number">0</span>, image.cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">i = randomCol(generater);</span><br><span class="line">j = randomRow(generater);</span><br><span class="line"><span class="keyword">if</span> (image.channels() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.channels() == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><details open><summary pointer> main.cpp </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Salt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示原图像；</span></span><br><span class="line"></span><br><span class="line">Salt(image1, <span class="number">5000</span>); <span class="comment">//加入5000个噪声点</span></span><br><span class="line">imshow(<span class="string">&quot;image2&quot;</span>, image1);  <span class="comment">//显示噪声图像；</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.231muzt7o0.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.231muzt7o0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="遍历图像像素"><a href="#遍历图像像素" class="headerlink" title="遍历图像像素"></a>遍历图像像素</h3><h4 id="指针扫描"><a href="#指针扫描" class="headerlink" title="指针扫描"></a>指针扫描</h4><p>以下面模板对图像进行扫描运算为例：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2h82lv6z7m.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2h82lv6z7m.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image;   <span class="comment">//定义输入图像和输出图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">output_image = Mat(image1.size(), image1.type());  <span class="comment">//定义输出图像大小</span></span><br><span class="line">output_image = image1.clone();   <span class="comment">//克隆原图像素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rows = image1.rows;    <span class="comment">//原图行数</span></span><br><span class="line"><span class="type">int</span> stepx = image1.channels();   <span class="comment">//原图通道数</span></span><br><span class="line"><span class="type">int</span> cols = (image1.cols) * image1.channels();  <span class="comment">//矩阵总列数，在BGR彩色图像中，每个像素的BGR通道按顺序排列，因此总列数=像素宽度*通道数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row =<span class="number">1</span> ; row &lt; (rows - <span class="number">1</span>); row++)   <span class="comment">//对行遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> uchar* previous = image1.ptr&lt;uchar&gt;(row - <span class="number">1</span>);  <span class="comment">//原图上一行指针</span></span><br><span class="line"><span class="type">const</span> uchar* current = image1.ptr&lt;uchar&gt;(row);       <span class="comment">//原图当前行指针</span></span><br><span class="line"><span class="type">const</span> uchar* next = image1.ptr&lt;uchar&gt;(row + <span class="number">1</span>);      <span class="comment">//原图下一行指针</span></span><br><span class="line">uchar* output = output_image.ptr&lt;uchar&gt;(row);        <span class="comment">//输出图像当前行指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = stepx; col &lt; (cols- stepx); col++)  <span class="comment">//对列遍历</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//卷积计算</span></span><br><span class="line">output[col] = saturate_cast&lt;uchar&gt;(<span class="number">5</span>*current[col] - (previous[col]+ current[col- stepx]+ current[col + stepx]+ next[col]));</span><br><span class="line"><span class="comment">//saturate_cast&lt;uchar&gt;(a)，当a在0—255时输出a，当a小于0输出0，当a大于255输出255，保证a的值在0~255之间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2a4uqfua0g.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2a4uqfua0g.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>把卷积核中间改成4：</strong><br><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8hg8qlrb43.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8hg8qlrb43.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="opencv自带的卷积运算：filter2D"><a href="#opencv自带的卷积运算：filter2D" class="headerlink" title="opencv自带的卷积运算：filter2D"></a>opencv自带的卷积运算：filter2D</h4><p>上面的方法可以简化为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image;   <span class="comment">//定义输入图像和输出图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat kernel = (Mat_&lt;<span class="type">char</span>&gt;(<span class="number">3</span>,<span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);  <span class="comment">//创建滤波器</span></span><br><span class="line">filter2D(image1, output_image, image1.depth(), kernel);  <span class="comment">//卷积</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter2D函数中，image1.depth()是用来获取图像image1的深度（depth）信息的函数调用。</p><p>图像的深度表示图像中每个像素值的数据类型。在OpenCV中，常见的图像深度包括：</p><ul><li>CV_8U：8位无符号整数（即Unsigned char），对应于灰度图像的深度</li><li>CV_16U：16位无符号整数</li><li>CV_16S：16位有符号整数</li><li>CV_32S：32位有符号整数</li><li>CV_32F：32位浮点数</li><li>CV_64F：64位浮点数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前面一部分笔记都是学习一个大佬的教程做的，但是大佬用的python，我在笔记里都转换成了c++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础配置&quot;&gt;&lt;a href=&quot;#基础配置&quot; class=&quot;headerlink&quot; title=&quot;基础</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>c语言计算机二级笔记</title>
    <link href="http://tumytime.github.io/2024/03/23/c%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://tumytime.github.io/2024/03/23/c%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-23T08:39:11.000Z</published>
    <updated>2024-03-25T03:50:05.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><h3 id="E-R实体联系"><a href="#E-R实体联系" class="headerlink" title="E-R实体联系"></a>E-R实体联系</h3><ol><li><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2krogi3z4f.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2krogi3z4f.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div> 矩形表示实体，菱形表示实体之间的联系</li><li>在关系数据库中，用于表示实体间联系的是<strong>二维表</strong></li><li>将E-R图转换为关系模式时，实体和联系都可以表示为<strong>关系</strong>(关系就是二维表)</li><li><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.969i7jl0dn.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.969i7jl0dn.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li></li></ol><p>已经考完了。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统&quot;&gt;&lt;a href=&quot;#计算机系统&quot; class=&quot;headerlink&quot; title=&quot;计算机系统&quot;&gt;&lt;/a&gt;计算机系统&lt;/h2&gt;&lt;h3 id=&quot;E-R实体联系&quot;&gt;&lt;a href=&quot;#E-R实体联系&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="c语言" scheme="http://tumytime.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c语言" scheme="http://tumytime.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="计算机二级" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>收藏夹</title>
    <link href="http://tumytime.github.io/2024/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    <id>http://tumytime.github.io/2024/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/</id>
    <published>2024-03-22T11:54:52.000Z</published>
    <updated>2024-03-25T05:21:58.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><div class="tagLink"><a class="link-card" title="从头开始实现一个神经网络" href="https://mp.weixin.qq.com/s/lk12kP2fbuSBSV5lSFKTlA"><span class="link-card-backdrop" style="background-image: url(https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567)"></span><div class="left"><img src="https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">从头开始实现一个神经网络</p><p class="url">https://mp.weixin.qq.com/s/lk12kP2fbuSBSV5lSFKTlA</p></div></a></div><div class="tagLink"><a class="link-card" title="数据处理之归一化、标准化、正则化" href="https://job.yanxishe.com/blogDetail/27604"><span class="link-card-backdrop" style="background-image: url(https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png)"></span><div class="left"><img src="https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png" class="lazyload placeholder" data-srcset="https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">数据处理之归一化、标准化、正则化</p><p class="url">https://job.yanxishe.com/blogDetail/27604</p></div></a></div><iframe src="//player.bilibili.com/player.html?aid=770444004&bvid=BV18r4y1M71J&cid=760424160&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=541842600&bvid=BV1yi4y1g7ro&cid=227677652&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><details ><summary pointer> 存一下包版本 </summary>              <div class='content'>              <p>(Paddle_Py3.12) C:\Users\lxcqm&gt;pip list<br>Package                 Version</p><hr><p>absl-py                 2.1.0<br>anyio                   4.3.0<br>archspec                0.2.3<br>astor                   0.8.1<br>astunparse              1.6.3<br>boltons                 23.1.1<br>Brotli                  1.0.9<br>certifi                 2024.2.2<br>cffi                    1.16.0<br>charset-normalizer      3.3.2<br>cloudpickle             3.0.0<br>cmake                   3.28.3<br>colorama                0.4.6<br>conda                   24.1.2<br>conda-libmamba-solver   24.1.0<br>conda-package-handling  2.2.0<br>conda_package_streaming 0.9.0<br>contourpy               1.2.0<br>cycler                  0.11.0<br>Cython                  3.0.9<br>decorator               5.1.1<br>distro                  1.9.0<br>filelock                3.13.1<br>flatbuffers             24.3.7<br>fonttools               4.25.0<br>gast                    0.5.4<br>google-pasta            0.2.0<br>grpcio                  1.62.1<br>gym                     0.26.2<br>gym-notices             0.0.8<br>h11                     0.14.0<br>h5py                    3.10.0<br>httpcore                1.0.4<br>httpx                   0.27.0<br>idna                    3.6<br>Jinja2                  3.1.3<br>joblib                  1.3.2<br>jsonpatch               1.33<br>jsonpointer             2.4<br>keras                   3.1.1<br>kiwisolver              1.4.4<br>libclang                18.1.1<br>libmambapy              1.5.7<br>mamba                   1.5.7<br>Markdown                3.6<br>markdown-it-py          3.0.0<br>MarkupSafe              2.1.5<br>matplotlib              3.8.0<br>mdurl                   0.1.2<br>menuinst                2.0.2<br>meson                   1.3.2<br>mkl-fft                 1.3.8<br>mkl-random              1.2.4<br>mkl-service             2.4.0<br>ml-dtypes               0.3.2<br>mpmath                  1.3.0<br>munkres                 1.1.4<br>namex                   0.0.7<br>nes_py                  8.2.1<br>networkx                3.2.1<br>numpy                   1.26.4<br>opencv-python           4.9.0.80<br>opt-einsum              3.3.0<br>optree                  0.10.0<br>packaging               23.1<br>paddlepaddle-gpu        2.6.0.post120<br>pandas                  2.2.1<br>pillow                  10.2.0<br>pip                     24.0<br>platformdirs            4.2.0<br>pluggy                  1.4.0<br>ply                     3.11<br>protobuf                4.25.2<br>pycocotools             2.0<br>pycosat                 0.6.6<br>pycparser               2.21<br>pyglet                  1.5.21<br>Pygments                2.17.2<br>pyparsing               3.0.9<br>PyQt5                   5.15.10<br>PyQt5-sip               12.13.0<br>PySocks                 1.7.1<br>python-dateutil         2.8.2<br>pytz                    2024.1<br>PyYAML                  6.0.1<br>requests                2.31.0<br>rich                    13.7.1<br>ruamel.yaml             0.18.6<br>ruamel.yaml.clib        0.2.8<br>scipy                   1.12.0<br>setuptools              69.1.1<br>sip                     6.7.12<br>six                     1.16.0<br>sniffio                 1.3.1<br>sympy                   1.12<br>tensorboard             2.16.2<br>tensorboard-data-server 0.7.2<br>tensorflow              2.16.1<br>tensorflow-intel        2.16.1<br>termcolor               2.4.0<br>threadpoolctl           3.3.0<br>torch                   2.2.1<br>torchaudio              2.2.1<br>torchvision             0.17.1<br>tornado                 6.3.3<br>tqdm                    4.66.2<br>truststore              0.8.0<br>typing_extensions       4.10.0<br>tzdata                  2024.1<br>urllib3                 2.2.1<br>Werkzeug                3.0.1<br>wheel                   0.43.0<br>win-inet-pton           1.1.0<br>wrapt                   1.16.0<br>zstandard               0.22.0</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AI&quot;&gt;&lt;a href=&quot;#AI&quot; class=&quot;headerlink&quot; title=&quot;AI&quot;&gt;&lt;/a&gt;AI&lt;/h2&gt;&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;从头开始实现一个神经网络&quot; href=&quot;http</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="深度学习" scheme="http://tumytime.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="YoloV3" scheme="http://tumytime.github.io/tags/YoloV3/"/>
    
  </entry>
  
  <entry>
    <title>YoloV3模型构建</title>
    <link href="http://tumytime.github.io/2024/03/21/YoloV3%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/"/>
    <id>http://tumytime.github.io/2024/03/21/YoloV3%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/</id>
    <published>2024-03-21T13:28:10.000Z</published>
    <updated>2024-03-21T15:34:27.534Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="【yolov3详解】一文让你读懂yolov3目标检测原理" href="https://blog.csdn.net/weixin_39615182/article/details/109752498"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/image.7i057r983s.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/image.7i057r983s.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i057r983s.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">【yolov3详解】一文让你读懂yolov3目标检测原理</p><p class="url">https://blog.csdn.net/weixin_39615182/article/details/109752498</p></div></a></div><p><strong>yolov3检测分两步：</strong><br>1、确定检测对象位置<br>2、对检测对象分类（是什么东西）<br>即在识别图片是什么的基础上，还需定位识别对象的位置，并框出。</p><p>我们首先上一幅图宏观理解下</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7i057r983s.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i057r983s.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>图中的红框是通过在yolov3检测最后得出的<strong>边界框</strong>（bounding box），又如下图的黄色框也是边界框</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7smz0wp6zw.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7smz0wp6zw.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>yolov3处理图片过程如下</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.pf3lakvam.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.pf3lakvam.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>首先一张图片传进yolo，yolo会将其转化为416×416大小的网格，增加灰度条用于防止失真，之后图片会分成三个网格图片（13×13，26×26，52×52）<br>由于图像在多次卷积压缩后，小物体的特征容易丢失，所以用52x52的网格检测小物体，由于猫属于大物体，所以用13x13的网格检测</p><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8ad0phujlt.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8ad0phujlt.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>先上流程图，该图是基于<strong>voc数据集</strong>讲解的，voc数据集有20个类别，最下面红框中(13，13，75)表示预测结果的shape，实际上是13,13,3×25,表示有13*13的网格，每个网格有3个先验框（又称锚框，anchors，先验框下面有解释），每个先验框有25个参数(20个类别+5个参数)，这5个参数分别是<strong>x_offset</strong>、<strong>y_offset</strong>、<strong>height</strong>、<strong>width</strong>与<strong>置信度confidence</strong>，用这3个框去试探，试探是否框中有物体，如果有，就会把这个物体给框起来。如果是基于coco的数据集就会有80种类别，最后的维度应该为3x(80+5)&#x3D;255，最上面两个预测结果shape同理</p><p>yolov3主干网络为Darknet53，重要的是使用了<strong>残差网络Residual</strong>，darknet53的每一个卷积部分使用了特有的<strong>DarknetConv2D结构</strong>，每一次卷积的时候进行<strong>l2正则化</strong>，完成卷积后进行<strong>BatchNormalization标准化</strong>与<strong>LeakyReLU激活函数</strong></p><p>对应代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   单次卷积</span></span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line"><span class="meta">@wraps(<span class="params">Conv2D</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DarknetConv2D</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    darknet_conv_kwargs = &#123;<span class="string">&#x27;kernel_regularizer&#x27;</span>: l2(<span class="number">5e-4</span>)&#125;</span><br><span class="line">    darknet_conv_kwargs[<span class="string">&#x27;padding&#x27;</span>] = <span class="string">&#x27;valid&#x27;</span> <span class="keyword">if</span> kwargs.get(<span class="string">&#x27;strides&#x27;</span>)==(<span class="number">2</span>,<span class="number">2</span>) <span class="keyword">else</span> <span class="string">&#x27;same&#x27;</span></span><br><span class="line">    darknet_conv_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> Conv2D(*args, **darknet_conv_kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   卷积块</span></span><br><span class="line"><span class="comment">#   DarknetConv2D + BatchNormalization + LeakyReLU</span></span><br><span class="line"><span class="comment">#---------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DarknetConv2D_BN_Leaky</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    no_bias_kwargs = &#123;<span class="string">&#x27;use_bias&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">    no_bias_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> compose( </span><br><span class="line">        DarknetConv2D(*args, **no_bias_kwargs),<span class="comment">#调用单次卷积函数进行正则化</span></span><br><span class="line">        BatchNormalization(),<span class="comment"># 标准化</span></span><br><span class="line">        LeakyReLU(alpha=<span class="number">0.1</span>))<span class="comment"># 激活函数</span></span><br></pre></td></tr></table></figure><details open><summary pointer> python装饰器 </summary>              <div class='content'>              <p><strong>将函数作为参数传给另一个函数</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hi</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi yasoob!&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doSomethingBeforeHi</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing hi()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(func())</span><br><span class="line"> </span><br><span class="line">doSomethingBeforeHi(hi)</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing hi()</span></span><br><span class="line"><span class="comment">#        hi yasoob!</span></span><br></pre></td></tr></table></figure><p>现在你已经具备所有必需知识，来进一步学习装饰器真正是什么了。装饰器让你在一个函数的前后去执行代码。</p><p><strong>你的第一个装饰器</strong></p><p>在上一个例子里，其实我们已经创建了一个装饰器！现在我们修改下上一个装饰器，并编写一个稍微更有用点的程序：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure><p>你看明白了吗？我们刚刚应用了之前学习到的原理。这正是python中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用<code>@</code>符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用<code>@</code>来运行之前的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure>              </div>            </details><p>讲解流程之前的<strong>基本概念</strong>了解一下，后面不记得回来再看看</p><p><strong>x_offset</strong>：表示网格左上角相对x轴的距离（偏移量）<br><strong>y_offset</strong>：表示网格左上角相对y轴的距离（偏移量）</p><p><strong>上采样</strong>：缩小图像（或称为下采样（subsampled），如池化）的主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。放大图像（或称为上采样（upSampling）或图像插值（interpolating））的主要目的是放大原图像,从而可以显示在更高分辨率的显示设备上。</p><p><strong>先验框</strong>（anchor box）：就是帮助我们定好了常见目标的宽和高，在进行预测的时候，我们可以利用这个已经定好的宽和高来进行处理，可以帮助我们进行预测，作用就是辅助处理x_offset、y_offset、h和w。如下图所示，用的是coco数据集，输出是(13,13,(80+5)*3)，乘3表示，有3个先验框，每个先验框都有85个参数，下图就有3个蓝色框，也即先验框，可以理解成给你的建议框，识别的对象可能在这些建议框中，目的是带你得到更高的IOU，即更高置信度、更可能有对象得部分，黄色框为真实最后显示的边界框，红色框表示中心位置。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2kroe0h5ah.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2kroe0h5ah.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>置信度</strong>（confidence）：就是预测的先验框和真实框ground truth box（真实对象的框）的IOU值，即先验框是否有对象的概率Pr(Object)，如进行人脸识别，一张图中有房子，树，车，人等，识别时背景和人的身体都没有脸这个需要识别的对象，那么这些地方的置信度就是0，框中的人脸越多，置信度（有对象概率）就越大，置信度是检测中非常重要的参数</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5tqsao8853.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5tqsao8853.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>IOU表示交并比</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3razmma7pz.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3razmma7pz.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>为什么要使用残差（Residual）神经网络？</strong><br>答：网络越深，梯度消失的现象就越来越明显，网络的训练效果也不会很好。残差神经网络就是为了在加深网络的情况下又解决梯度消失的问题。残差结构可以不通过卷积，直接从前面一个特征层映射到后面的特征层（跳跃连接），有助于训练，也有助于特征的提取，容易优化。</p><h2 id="yolov3检测流程原理"><a href="#yolov3检测流程原理" class="headerlink" title="yolov3检测流程原理"></a>yolov3检测流程原理</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.26l8n5exyl.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.26l8n5exyl.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="第一步：从特征获取预测结果"><a href="#第一步：从特征获取预测结果" class="headerlink" title="第一步：从特征获取预测结果"></a>第一步：从特征获取预测结果</h3><ol><li><p>yolov3提取多特征层进行目标检测，一共提取三个特征层，三个特征层位于主干特征提取网络darknet53的不同位置，分别位于中间层，中下层，底层，三个特征层的shape分别为(52,52,256)、(26,26,512)、(13,13,1024)，这三个特征层后面用于与上采样后的其他特征层堆叠拼接（Concat）</p></li><li><p>第三个特征层(13,13,1024)进行5次卷积处理（为了特征提取），处理完后一部分用于卷积+上采样UpSampling，另一部分用于输出对应的预测结果（13,13,75），Conv2D 3×3和Conv2D1×1两个卷积起通道调整的作用，调整成输出需要的大小。</p></li><li><p>卷积+上采样后得到(26,26,256)的特征层，然后与Darknet53网络中的特征层(26,26,512)进行拼接，得到的shape为(26,26,768)，再进行5次卷积，处理完后一部分用于卷积上采样，另一部分用于输出对应的预测结果(26,26,75)，Conv2D 3×3和Conv2D1×1同上为通道调整</p></li><li><p>之后再将3中卷积+上采样的特征层与shape为(52,52,256)的特征层拼接（Concat）,再进行卷积得到shape为(52,52,128)的特征层，最后再Conv2D 3×3和Conv2D1×1两个卷积，得到(52,52,75)特征层</p></li></ol><p>最后图中有三个红框原因就是有些物体相对在图中较大，就用13×13检测，物体在图中比较小，就会归为52×52来检测</p><h3 id="第二步：预测结果的解码"><a href="#第二步：预测结果的解码" class="headerlink" title="第二步：预测结果的解码"></a>第二步：预测结果的解码</h3><p>预测结果解码原因：预测结果(红框)并不对应着最终的预测框在图片上的位置，还需要解码）</p><p>yolov3的预测原理是分别将整幅图分为13x13、26x26、52x52的网格，每个网络点负责一个区域的检测。解码过程就是计算得出最后显示的边界框的坐标bx,by，以及宽高bw,bh，这样就得出了边界框的位置，计算过程如图（b–为bounding box 缩写）</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1e8d5fao6l.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1e8d5fao6l.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>(cx,cy)：该点所在网格的左上角距离最左上角相差的格子数。<br>(pw,ph)：先验框的边长<br>(tx,ty)：目标中心点相对于该点所在网格左上角的偏移量<br>(tw,th)：预测边框的宽和高<br>σ：激活函数，论文作者用的是sigmoid函数，[0,1]之间概率，之所以用sigmoid取代之前版本的softmax，原因是softmax会扩大最大类别概率值而抑制其他类别概率值 ，图解如下</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9rj5rcytb7.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9rj5rcytb7.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>注：最终得到的边框坐标值是bx,by,bw,bh.而网络学习目标是tx，ty，tw，th。<br>另外cy向下此处为正向</p><h3 id="第三步：对预测出的边界框得分排序与非极大抑制筛选"><a href="#第三步：对预测出的边界框得分排序与非极大抑制筛选" class="headerlink" title="第三步：对预测出的边界框得分排序与非极大抑制筛选"></a>第三步：对预测出的边界框得分排序与非极大抑制筛选</h3><p>这步就是将最大概率的框筛选出来<br>1、取出每一类得分大于一定阈值的框和得分进行排序。<br>2、利用框的位置和得分进行非极大抑制。最后可以得出概率最大的边界框，也就是最后显示出的框<br>如下几幅图，一步步筛选得到最终边界框</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;【yolov3详解】一文让你读懂yolov3目标检测原理&quot; href=&quot;https://blog.csdn.net/weixin_39615182/article/details/1</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="深度学习" scheme="http://tumytime.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="YoloV3" scheme="http://tumytime.github.io/tags/YoloV3/"/>
    
  </entry>
  
  <entry>
    <title>1x1卷积核</title>
    <link href="http://tumytime.github.io/2024/03/21/1x1%E5%8D%B7%E7%A7%AF%E6%A0%B8/"/>
    <id>http://tumytime.github.io/2024/03/21/1x1%E5%8D%B7%E7%A7%AF%E6%A0%B8/</id>
    <published>2024-03-21T09:40:05.000Z</published>
    <updated>2024-03-21T12:15:18.385Z</updated>
    
    <content type="html"><![CDATA[<div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7awxc3fekp.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7awxc3fekp.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p>在卷积神经网络的卷积层中，不同的通道使用的卷积核参数是不一样的。每个通道都有自己对应的卷积核参数，这些参数用于在该通道上对输入数据进行滤波操作，提取特定的特征。<br>通道之间的卷积核参数是不共享的，即每个通道都有自己独特的卷积核参数。这种设计可以让神经网络更加灵活地学习不同通道之间的特征表示，从而提高网络的表征能力。</p></blockquote><h2 id="1×1-卷积核作用"><a href="#1×1-卷积核作用" class="headerlink" title="$1×1$卷积核作用"></a>$1×1$卷积核作用</h2><p><strong>卷积层中的卷积核数量决定了输出的通道数，而每个卷积核的通道数取决于输入数据的通道数</strong></p><ol><li><p><strong>卷积核数决定了输出通道数：</strong> 在卷积神经网络中，每个卷积层包含多个卷积核。每个卷积核在输入数据上进行卷积操作，生成一个对应的输出特征图（通道）。因此，卷积核的数量决定了输出特征图的通道数。如果一个卷积层有n个卷积核，那么输出将包含n个通道。</p></li><li><p><strong>每个卷积核的通道数取决于输入的通道数：</strong> 当卷积核在输入数据上进行卷积操作时，每个卷积核会同时处理输入数据的所有通道。例如，如果输入数据是RGB图像，有3个通道（红色、绿色、蓝色），那么每个卷积核将同时在这3个通道上进行卷积操作。这样，每个卷积核的通道数就等于输入数据的通道数。因此，卷积核的通道数取决于输入数据的通道数。</p></li></ol><h3 id="增加网络深度-增加非线性映射次数"><a href="#增加网络深度-增加非线性映射次数" class="headerlink" title="增加网络深度(增加非线性映射次数)"></a>增加网络深度(增加非线性映射次数)</h3><iframe src="//player.bilibili.com/player.html?aid=696259725&bvid=BV11m4y1r7jK&cid=1062261407&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>首先直接从网络深度来理解，1x1 的卷积核虽小，但也是卷积核，加 1 层卷积，网络深度自然会增加。<br>1x1卷积核，可以在保持feature map尺度不变的（即不损失分辨率）的前提下大幅增加非线性特性（利用后接的非线性激活函数），把网络做的很深。并且1x1卷积核的卷积过程相当于全连接的计算过程，通过<strong>加入非线性激活函数</strong>，可以<strong>增加网络的非线性</strong>，使得网络可以表达更复杂的特征。</p><h4 id="feature-map的含义"><a href="#feature-map的含义" class="headerlink" title="feature map的含义"></a>feature map的含义</h4><p>在每个卷积层，数据都是以三维形式存在的。你可以把它看成许多个二维图片叠在一起，其中每一个称为一个feature map。在输入层，如果是灰度图片，那就只有一个feature map；如果是彩色图片，一般就是3个feature map（红绿蓝）。层与层之间会有若干个卷积核（kernel），上一层和每个feature map跟每个卷积核做卷积，都会产生下一层的一个feature map。</p><p>feature map（下图红线标出） 即：该层卷积核的个数，有多少个卷积核，经过卷积就会产生多少个feature map，也就是下图中 <code>豆腐皮儿</code>的层数、同时也是下图<code>豆腐块</code>的深度（宽度）！！这个宽度可以手动指定，一般网络越深的地方这个值越大，因为随着网络的加深，feature map的长宽尺寸缩小，本卷积层的每个map提取的特征越具有代表性（精华部分），所以后一层卷积层需要增加feature map的数量，才能更充分的提取出前一层的特征，一般是成倍增加（不过具体论文会根据实验情况具体设置）！</p><p>在卷积神经网络中，每个卷积层都包含多个卷积核（也称为滤波器），每个卷积核生成一个特征图。当前一层输出的特征图与后一层卷积核进行卷积操作时，可以看作是在进行矩阵相乘操作。增加后一层的特征图数量实际上意味着增加了后一层卷积核的数量，这可以使网络在进行特征提取时拥有更多的“过滤器”，从而更全面地捕获输入数据中的不同特征和模式。</p><p>卷积特征的可视化，有助于我们更好地理解深度网络。卷积网络在学习过程中保持了图像的空间结构，也就是说最后一层的激活值（feature map）总和原始图像具有空间上的对应关系，具体对应的位置以及大小，可以用感受野来度量。利用这点性质可以做很多事情：</p><ol><li>前向计算。我们直接可视化网络每层的 feature map，然后观察feature map 的数值变化. 一个训练成功的CNN 网络，其feature map 的值伴随网络深度的增加，会越来越稀疏。这可以理解网络取精去燥。 <details open><summary pointer> WHY越来越稀疏 </summary>              <div class='content'>              <p>在一个训练成功的CNN（Convolutional Neural Network）网络中，随着网络深度的增加，feature map 的值会越来越稀疏的现象可以通过以下方面进行详细解释：</p><ol><li><p><strong>特征稀疏性在深层网络中的原因</strong>：</p><ul><li><strong>激活函数的非线性作用</strong>：在卷积神经网络中，通常在每个卷积层之后都会使用非线性激活函数（如ReLU）。这种非线性激活会导致大部分神经元的输出接近于0，只有部分神经元会激活并输出非零值，从而导致 feature map 的稀疏性。</li><li><strong>权重更新和特征选择</strong>：随着网络的训练，CNN 会根据损失函数进行权重更新，通过学习提取对分类任务有用的特征。在网络深度增加的过程中，网络会更加注重对关键特征的提取，而相对不重要的特征很可能被抑制，这也会导致 feature map 的稀疏性。</li></ul></li><li><p><strong>稀疏特征对网络性能的影响</strong>：</p><ul><li><strong>泛化能力提升</strong>：存储较少的激活值可以增加网络的泛化能力，减少过拟合的风险，因为网络更多地关注于对区分性重要的特征进行学习。</li><li><strong>计算效率提高</strong>：稀疏的特征图在后续的层次中减少了计算量，因为对于很多值较小或接近于零的神经元，不必执行额外的乘法运算，从而提高了网络的计算效率。</li></ul></li><li><p><strong>深度增加导致特征复杂性</strong>：</p><ul><li>随着网络深度的增加，特征图表示的特征也会变得越来越复杂和抽象，需要更少的激活来描述一个高级别的特征，这也间接导致 feature map 的稀疏性。</li></ul></li></ol><p>综上所述，随着网络深度的增加，一个训练成功的CNN 网络中的 feature map 的值会变得越来越稀疏，这主要是由于非线性激活函数的作用、权重更新和特征选择机制，以及深层网络中复杂特征的表示所导致的结果。这种稀疏性有助于提升网络的泛化能力、计算效率，并反映了网络对关键特征的学习和抽象能力。</p><details open><summary pointer> 激活一个神经元的过程 </summary>          <div class='content'>          <p>激活一个神经元的过程可以简单描述为以下几个步骤：</p><ol><li><p><strong>加权求和（Weighted Summation）</strong>：神经元接收来自上一层或输入数据的输入信号，每个输入信号都会乘以对应的连接权重（weights），然后将所有加权输入信号求和，得到一个加权和。这个加权和可以表示为：$[ z &#x3D; \sum_{i&#x3D;1}^{n} (w_i \cdot x_i) + b ]$，其中 $(w_i)$ 是第 $(i)$ 个输入信号的权重，$(x_i)$ 是对应的输入值，$(b)$ 是神经元的偏置项（bias）。</p></li><li><p><strong>激活函数（Activation Function）</strong>：将上一步计算得到的加权和$(z)$输入到激活函数中，激活函数会对加权和进行非线性变换，从而输出神经元的激活值（activation value）。常见的激活函数包括ReLU、Sigmoid、Tanh等。激活函数将决定神经元是否被激活，以及激活级别如何。</p></li><li><p><strong>输出值（Output）</strong>：激活函数的输出值即为神经元的最终输出，也可以表示为神经元的激活值。这个输出值将会被传递到下一层神经元或作为最终输出。</p></li></ol><p>总结起来，激活一个神经元的详细过程就是通过加权求和得到输入信号的加权和，然后经过激活函数进行非线性变换得到最终的输出值。这个过程在神经网络的每一层都会被重复执行，用于处理来自前一层神经元的信号并生成新的表示。</p>          </div>        </details>               </div>            </details></li><li>反向计算。根据网络最后一层最强的激活值，利用感受野求出原始输入图像的区域。可以观察输入图像的那些区域激活了网络，利用这个思路可以做一些物体定位。</li></ol><h4 id="1x1卷积核增加网络深度的原因"><a href="#1x1卷积核增加网络深度的原因" class="headerlink" title="1x1卷积核增加网络深度的原因"></a>1x1卷积核增加网络深度的原因</h4><p>在卷积神经网络中，1x1卷积核通过在通道维度上进行卷积操作，可以起到增加网络深度的作用。这是因为1x1卷积核可以在不改变空间尺寸的情况下，增加通道数量，从而增加网络的深度，提供更多的非线性变换和表达能力。以下是1x1卷积核如何增加网络深度的原理：</p><ol><li><p><strong>通道维度的变换：</strong> 1x1卷积核的作用是在每个空间位置对输入数据的通道进行线性变换。通过对输入数据的每个通道分别进行加权求和，可以生成新的特征表示。这样，在1x1卷积层之后，输出将具有更多的通道数，因此网络的深度也会增加。</p></li><li><p><strong>引入非线性变换：</strong> 尽管1x1卷积核是在通道维度上进行卷积操作，但其引入的非线性激活函数（如ReLU）会使输出具有更丰富的特征表示能力。这种非线性变换有助于增加网络的深度，使网络能够学习到更复杂的特征。</p></li><li><p><strong>增加网络的表达能力：</strong> 通过1x1卷积核增加网络的深度，网络可以更好地捕获不同抽象级别的特征。每个1x1卷积层都可以看作是一个含有非线性激活函数的全连接层，因此可以提高网络的表达能力和学习能力。</p></li></ol><h4 id="WHY使用1x1卷积核"><a href="#WHY使用1x1卷积核" class="headerlink" title="WHY使用1x1卷积核"></a>WHY使用1x1卷积核</h4><p><strong>增加网络深度有什么好处？为什么非要用 1x1 来增加深度呢？其它的不可以吗？</strong></p><p>其实，这涉及到<code>感受野</code>(感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上的像素点在输入图片上映射的区域大小)的问题，我们知道<strong>卷积核越大，它生成的 featuremap 上单个节点的感受野就越大</strong>，随着网络深度的增加，<strong>越靠后的 featuremap 上的节点感受野也越大。因此特征也越来越抽象</strong>。</p><p>但有的时候，我们想在不增加感受野的情况下，让网络加深，为的就是引入更多的非线性。</p><p>而 1x1 卷积核，恰巧可以办到。</p><p>我们知道，卷积后生成图片的尺寸受卷积核的大小和跨度影响，但如果卷积核是 1x1 ，跨度也是 1，那么生成后的图像大小就并没有变化。</p><p>但通常一个卷积过程包括一个激活函数，比如 Sigmoid 和 Relu。</p><p>所以，<strong>在输入不发生尺寸的变化下，却引入了更多的非线性</strong>，这将增强神经网络的表达能力</p><h3 id="升维-降维"><a href="#升维-降维" class="headerlink" title="升维&#x2F;降维"></a>升维&#x2F;降维</h3><p>其实这里的升维、降维具体指的是通道数的变化，当我们确定了卷积核尺寸后，我们的height、width都不变，那么这里的维度具体指的就是channels。我们通过改变卷积核的数量来改变卷积后特征图的通道channels来实现升维、降维的效果。这样可以将原本的数据量进行增加或者减少<br>下面分别举两个例子就能明显看到效果</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4ckn8pum0v.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4ckn8pum0v.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="升维"><a href="#升维" class="headerlink" title="升维"></a>升维</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3nrdop8yvr.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3nrdop8yvr.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2ruw98zwjt.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2ruw98zwjt.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1e8d57p5wp.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1e8d57p5wp.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>其实很明显的能看出来，无论是升维还是降维，我们都是通过改变卷积核的数量实现的，卷积后的特征图的通道数channels同卷积核的数量保持一致，这里其实不仅仅是1x1卷积核能实现这个功能，其他尺寸的卷积核也可以，那么我们为什么要选用1x1卷积核呢</p><h4 id="使用1x1卷积核升维-降维的原因"><a href="#使用1x1卷积核升维-降维的原因" class="headerlink" title="使用1x1卷积核升维&#x2F;降维的原因"></a>使用1x1卷积核升维&#x2F;降维的原因</h4><p>当我们仅仅只是想要改变通道数的情况下，1x1卷积核是最小的选择，因为大于1x1的卷积核无疑会增加计算的参数量，内存也会随之增大，所以只想单纯的去提升或者降低特征图的通道，选用1x1卷积核最为合适， 1x1卷积核会使用更少的权重参数数量。</p><h3 id="跨通道的信息交互"><a href="#跨通道的信息交互" class="headerlink" title="跨通道的信息交互"></a>跨通道的信息交互</h3><p>1x1卷积核只有一个参数，当它作用在多通道的feature map上时，相当于不同通道上的一个线性组合，实际上就是乘以一个系数再加起来，但是这样输出的feature map就是多个通道的整合信息了，能够使网络提取的特征更加丰富。</p><p>使用1x1卷积核，实现降维和升维的操作其实就是 channel 间信息的线性组合变化。</p><p>比如：在尺寸 3x3，64通道个数的卷积核后面添加一个尺寸1x1，28通道个数的卷积核，就变成了尺寸3x3，28尺寸的卷积核。 原来的64个通道就可以理解为跨通道线性组合变成了28通道，这就是通道间的信息交互。</p><p>注意：只是在通道维度上做线性组合，W和H上是共享权值的滑动窗口。</p><h3 id="减少卷积核参数（简化模型）"><a href="#减少卷积核参数（简化模型）" class="headerlink" title="减少卷积核参数（简化模型）"></a>减少卷积核参数（简化模型）</h3><p>下面仅以计算权重数为例子进行计算（不添加偏差bias）</p><h4 id="一层卷积添加1x1卷积核，分别计算权重数"><a href="#一层卷积添加1x1卷积核，分别计算权重数" class="headerlink" title="一层卷积添加1x1卷积核，分别计算权重数"></a>一层卷积添加1x1卷积核，分别计算权重数</h4><ul><li><p>不使用1x1卷积核</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.839stz0ial.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.839stz0ial.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li><p>使用1x1卷积核</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.73tpgsyher.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.73tpgsyher.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li></ul><p>可以看到不使用1x1的卷积核是使用卷积核的10倍左右</p><h4 id="GoogLeNet的3a模块"><a href="#GoogLeNet的3a模块" class="headerlink" title="GoogLeNet的3a模块"></a>GoogLeNet的3a模块</h4><ul><li>不使用1x1卷积核  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.58h4o6olfv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.58h4o6olfv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.13ljc2ryvv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.13ljc2ryvv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>权重数：192 × (1×1×64) +192 × (3×3×128) + 192 × (5×5×32) &#x3D; 387072<br>这个网络的说明如下</li></ul><ol><li>采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合；</li><li>之所以卷积核大小采用1、3和5，主要是为了方便对齐。设定卷积步长stride&#x3D;1之后，只要分别设定pad&#x3D;0、1、2，那么卷积之后便可以得到相同维度的特征，然后这些特征就可以直接拼接在一起了；</li><li>文章说很多地方都表明pooling挺有效，所以Inception里面也嵌入了。</li><li>网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。</li></ol><ul><li>使用1x1卷积核  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2a4ukoith5.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2a4ukoith5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7zq6w9eiya.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7zq6w9eiya.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li></ul><p>权重数：192 × (1×1×64) +（192×1×1×96+ 96 × 3×3×128）+（192×1×1×16+16×5×5×32）&#x3D; 157184</p><p>不使用1x1的卷积核是使用1x1卷积核的权重数2倍</p><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>ResNet同样也利用了1×1卷积，并且是在3×3卷积层的前后都使用了，不仅进行了降维，还进行了升维，参数数量进一步减少</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8ojgga406k.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8ojgga406k.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>其中右图又称为<code>bottleneck design</code>，目的一目了然，就是为了降低参数的数目，第一个1x1的卷积把256维channel降到64维，然后在最后通过1x1卷积恢复，<br>当我们的特征图通道数为256时，变得很大，出现的问题是计算复杂度会很高，这里做法是通过1×1卷积投影映射回64维，再做一个3×3通道数不变的卷积，然后再通过1×1卷积投影回去256维，因为输入是256维，输出要匹配上，这样设计之后复杂度就跟左图差不多了。<br>左图参数量：64 x ( 3 x 3 x 64)+64 x ( 3 x 3 x 64 ) &#x3D; 73728<br>当通道数增加到 256时：256 x ( 3 x 3 x 256 ) + 256 x ( 3 x 3 x 256 ) &#x3D; 1179648<br>右图参数量：256 x ( 1 x 1 x 64) + 64 x ( 3 x 3 x 64 ) + 256 x ( 1 x 1 x 64) &#x3D; 69632</p><p>当通道数增加为256时，可以发现添加两层1x1的卷积的参数量和64为原有残差块参数量差不多。</p><p>对于常规ResNet，可以用于34层或者更少的网络中，对于Bottleneck Design的ResNet通常用于更深的网络中，目的是减少计算和参数量（实用目的）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg&quot;&gt;&lt;img class=&quot;img lazyload placeholder&quot; src=&quot;https://tumytime.github.io/picx-images-hosting/image.7a</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="深度学习" scheme="http://tumytime.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>残差网络</title>
    <link href="http://tumytime.github.io/2024/03/21/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    <id>http://tumytime.github.io/2024/03/21/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/</id>
    <published>2024-03-21T08:49:21.000Z</published>
    <updated>2024-03-22T11:59:17.558Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="详解残差网络" href="https://zhuanlan.zhihu.com/p/42706477"><span class="link-card-backdrop" style="background-image: url(https://pic2.zhimg.com/80/v2-bd76d0f10f84d74f90505eababd3d4a1_1440w.webp)"></span><div class="left"><img src="https://pic2.zhimg.com/80/v2-bd76d0f10f84d74f90505eababd3d4a1_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-bd76d0f10f84d74f90505eababd3d4a1_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">详解残差网络</p><p class="url">https://zhuanlan.zhihu.com/p/42706477</p></div></a></div><h2 id="WHY要有残差网络"><a href="#WHY要有残差网络" class="headerlink" title="WHY要有残差网络"></a><strong>WHY要有残差网络</strong></h2><blockquote><ul><li><p>首先，当网络发生退化时，意味着随着网络层数的增加，模型的性能并没有相应地提高，甚至可能变得更差。这通常是由于梯度消失、梯度爆炸或者模型优化难度增加导致的。在这种情况下，浅层的网络由于模型复杂度较低，可能更容易优化，因此能够达到更好的训练效果。</p></li><li><p>接下来，如果我们能够<strong>将低层的特征有效地传递到高层</strong>，那么高层网络就有可能利用这些有用的特征来提高性能。这是因为在深度学习中，<strong>低层网络</strong>通常学习一些<strong>基本的、通用的特征</strong>（如边缘、纹理等），而高层网络则在此基础上学习更复杂的特征。如果<strong>高层网络能够重用这些低层的特征，那么它就有可能达到甚至超过浅层网络的性能</strong>。</p></li><li><p>以VGG-100和VGG-16为例，假设我们在VGG-100的第98层和第14层之间<strong>添加一条直接映射</strong>（Identity Mapping）。这意味着第98层的输出将包含第14层的输出作为其一部分。<strong>如果这条直接映射能够有效地传递有用的特征，并且高层网络能够有效地利用这些特征，那么VGG-100的性能理论上应该至少与VGG-16相当，甚至可能更好。</strong></p></li><li><p>然而，需要注意的是，直接映射并不意味着简单地复制和粘贴特征。它需要以一种有效的方式将低层特征整合到高层网络中，以确保高层网络能够充分利用这些特征。此外，还需要考虑如何平衡新旧特征之间的关系，以及如何处理特征维度不匹配等问题。</p></li><li><p>在实际应用中，直接映射的策略已经在一些深度学习架构中得到了应用，如<strong>残差网络（ResNet）和密集连接网络（DenseNet）</strong>。这些网络通过引入残差块或密集连接来实现直接映射，从而有效地缓解了网络退化的问题，并提高了模型的性能。</p></li></ul></blockquote><details open><summary pointer> 高层网络 </summary>              <div class='content'>              <blockquote><p>在一个神经网络中，离输入层更远的网络层通常被称为“深层网络”或“高层网络”，因为它们在网络中的位置更深或更靠近网络的中间部分，而不是直接与输出层相连。这些深层网络通常包括多个隐藏层，并且在网络的层次结构中扮演重要的角色，用于提取更加抽象和高级的特征信息。<br>一个神经网络的层次结构通常包括输入层、多个隐藏层（包括深层网络）和输出层。深层网络在隐藏层中间位置，远离输入层但不是靠近输出层，因为深层网络通常在多层神经网络的结构中处于中间位置。<br>因此，深层网络位于输入层和输出层之间，通过多个隐藏层处理输入数据，逐步提取和学习特征，最终为输出层提供经过多次非线性变换后的表示以完成具体任务。深度学习模型的深度通常指的是隐藏层的层数，而深层网络则是指包含多个隐藏层的部分。</p></blockquote><blockquote><p>高层网络（即深层网络）在深度学习中具有以下特点：</p><ol><li><p><strong>多层结构</strong>：高层网络由多个隐藏层组成，每一层都包含大量的神经元。通过多层结构，网络可以学习和表示更加复杂和抽象的特征。</p></li><li><p><strong>层间连接</strong>：不同层之间的神经元相互连接，信息逐层传递。每一层的输出作为下一层的输入，通过层间连接实现特征的组合和抽象。</p></li><li><p><strong>特征提取</strong>：高层网络可以通过多个隐藏层逐步提取数据中的特征信息，从低级特征到高级特征的逐渐抽象过程有助于网络学习更深层次的表示。</p></li><li><p><strong>表征学习</strong>：通过深度学习，高层网络可以自动学习表示数据的特征，而无需手工设计特征提取器。这种表征学习的方式能够更好地适应不同类型的数据和任务。</p></li><li><p><strong>非线性变换</strong>：高层网络通过激活函数引入非线性变换，使网络能够学习和表示更加复杂的函数关系。非线性激活函数如ReLU、Sigmoid等有助于网络学习非线性模式。</p></li><li><p><strong>端对端学习</strong>：高层网络支持端对端学习，即从原始输入数据端到最终输出结果端的全过程训练。这种端对端学习能够更好地优化整个模型，提高模型的泛化能力和性能。</p></li></ol><p>总的来说，高层网络的特点包括多层结构、特征提取、表征学习、非线性变换等，使得深度学习模型能够更好地适应和解决复杂的机器学习任务。</p></blockquote><blockquote><p>在深度神经网络中，一旦到达最深层级，通常会对网络进行一些操作，以降低网络的深度或减少参数数量，使接下来的层级逐渐变浅。这些操作包括：</p><ol><li><p><strong>降采样（Downsampling）</strong>：通过池化操作（如最大池化或平均池化）或步长较大的卷积操作来减少特征图的宽度和高度，从而减少下一层的神经元数量。</p></li><li><p><strong>特征合并（Feature Concatenation）</strong>：将前几层提取的高级特征与浅层特征进行连接或拼接，使得网络在接下来层级中不需要再学习这些高级特征，从而减少网络的深度。</p></li><li><p><strong>特征选择（Feature Selection）</strong>：对于某些特征进行筛选或降维，只保留最重要的特征，可以通过降维技术（如主成分分析）来实现。</p></li><li><p><strong>残差连接（Residual Connections）</strong>：在残差网络（ResNet）中使用残差连接，使得深层网络可以通过跳过连接获得浅层网络的信息，从而减少深层网络的堆叠层数。</p></li><li><p><strong>特征映射（Feature Mapping）</strong>：通过对特征图进行逐层映射或抽取表示，可以将原始的深层特征映射到浅层网络中，减少网络的深度。</p></li></ol><p>这些操作旨在提高网络的效率和泛化能力，避免深度过深导致的梯度消失、计算量增加和过拟合等问题。通过适当的操作，可以使深度神经网络在保持良好性能的同时，减少深度或层级，提高网络的训练效率和性能。</p></blockquote>              </div>            </details><details open><summary pointer> CNN中的底层、高层特征、上下文信息、多尺度 </summary>              <div class='content'>              <ol><li><p><strong>CNN中的底层、高层特征:</strong></p><p> 简短总结： 分类要求特征有较多的高级信息，回归（定位）要求特征包含更多的细节信息</p><ul><li><p><strong>图像的低层特征</strong>（对定位任务帮助大，我们可以想想比如轮廓信息都不准那怎么去良好定位）:</p><p>  图像底层特征指的是：轮廓、边缘、颜色、纹理、棱角和形状特征。</p><p>  边缘和轮廓能反映图像内容；如果能对边缘和关键点进行可靠提取的话，很多视觉问题就基本上得到了解决。图像的低层的特征语义信息比较少，但越浅的层特征越细节（低级）且特征图分辨率大，所以位置信息很充足，目标位置准确。再从另一个方面讲，越浅层的特征感受野越小（每个像素点映射回原图的覆盖面积小），故用浅层特征图检测大目标时就有点像瞎子摸象的感觉效果并不好，因为光能看到象腿也不知道这是啥东西。当然对于小目标检测来说如果能利用足够的上下文信息也是有好处的！例如，通过只看图中的一个小目标所在的那个位置，人类甚至很难识别这些物体。然而，通过考虑到它位于天空中的背景，这个物体可以被识别为鸟类。因此，我们认为，解决这个问题的关键取决于我们如何将上下文作为额外信息来帮助检测小目标。</p></li><li><p><strong>图像的高层特征</strong>也叫语义特征（高层特征即CNN中网络越深的层得到的特征，高层的特征包含很丰富的组合信息，象征着人对它的分辨能力，越高层越好分辨出是啥东西，如表征着类别啥的，对识别任务帮助大）:</p></li></ul><p> 图像的高层语义特征值得是我们所能看的东西，比如对一张人脸提取低层特征我们可以提取到连的轮廓、鼻子、眼睛之类的，那么高层的特征就显示为一张人脸。高层的特征语义信息比较丰富，但是目标位置比较粗略。</p><p> 愈深层特征包含的高层语义性愈强、分辨能力也愈强。我们把图像的视觉特征称为视觉空间 (visual space)，把种类的语义信息称为语义空间 (semantic space)</p></li><li><p><strong>上下文信息</strong></p><p> 做图像的，上下文特征是很常见的，其实上下文大概去理解就是图像中的每一个像素点不可能是孤立的，一个像素一定和周围像素是有一定的关系的，大量像素的互相联系才产生了图像中的各种物体，所以上下文特征就指像素以及周边像素的某种联系。</p><p> 具体到图像语义分割，一般论文会说我们的XXX算法充分结合了上下文信息，意思也就是在判断某一个位置上的像素属于哪种类别的时候，不仅考察到该像素的灰度值，还充分考虑和它临近的像素。</p><p> 然后上下文信息还分全局和局部，意思就是考虑全图不同范围内的像素和只考虑邻近的一些像素。</p><p> 全局上下文信息 也可以理解为能够捕捉来自更多的不同尺度的上下文信息，不同尺度就是指不同感受野。</p></li><li><p><strong>多尺度</strong></p><p> 个人感觉，多尺度 就是 你能看到的范围（看到尺度就理解为CNN的感受野就完事了！！！）。</p><p> 图像中一个东西的尺度越大，就指距离越近相当于被放大了，那么给人感觉就越模糊。例如：</p><ul><li><p>训练的时候，把图片缩放到不同大小输入给同一个网络，网络就能看到不一样大小范围的内容，缩放得分辨率越高就指尺度越大，因为对图中的某一个物体来讲就是被放大的感觉。然后就是因为缩放后，比如中间特征图上的某个像素点都只能看到原图3乘3的区域，可随着输入的图片尺度不一样，同样是看到的3乘3区域，但相对于整张图的范围也自然就不一样了，然后就叫做多尺度训练；好处是可以适应不同尺度的输入，泛化性好。</p></li><li><p>把一个特征层用由不同感受野的卷积核组成的网络层（例如SPP）处理，这层网络的同一个像素位置就能看到不同范围的上层特征，就叫做多尺度特征融合；好处是能考虑到不同范围的空间特征上下文（例如头发下面一般会有一张脸）。</p></li><li><p>把一个网络中不同深度的层做融合：浅层感受野小，分辨率大，能够处理并保存小尺度的几何特征；高层感受野大，分辨率小，能够处理并保存大尺度的语义特征。这也叫做多尺度特征融合；好处是能够将语义特征和几何特征进行融合（例如这块区域是头发，低分辨率图上的分界线一般是线状特征和非线状特征的边界）。</p></li></ul></li></ol>              </div>            </details><blockquote><p>从信息论的角度讲，由于DPI(数据处理不等式)的存在，在前向传输的过程中，随着层数的加深，Feature Map包含的图像信息会逐层减少，而ResNet的直接映射的加入，保证了$l+1$层的网络一定比$l$层包含更多的图像信息。</p><details open><summary pointer> 解释 </summary>              <div class='content'>              <p>保证了$l+1$层的网络一定比l层包含更多的图像信息，这是因为直接映射（恒等映射）将前一层的信息无损地传递到了后一层，确保了信息的完整性。同时，由于残差部分的存在，网络可以学习输入和输出之间的差值，即残差。这个残差部分可能会引入一些新的、有用的特征或模式，这些特征或模式在之前的层中可能并不存在。这些新增的特征或模式会与直接映射的信息相结合，导致$l+1$层的信息量实际上比$l$层更多。<br>换句话说，直接映射保证了信息量的下限（即至少与前一层相同），而残差部分则有可能增加额外的信息量。因此，综合这两部分，$l+1$层的网络包含的信息量一定会比$l$层更多。这也是ResNet能够在增加网络深度的同时保持甚至提高性能的关键原因之一。<br>需要注意的是，这里的“更多”并不意味着绝对的信息量一定更大，而是指相对于前一层，后一层有可能包含更多的有用特征或模式。在实际应用中，还需要考虑其他因素，如网络的训练方式、数据集的质量等，来综合评估网络性能。</p>              </div>            </details><p>基于这种使用直接映射来连接网络不同层直接的思想，残差网络应运而生。</p></blockquote><h2 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h2><h3 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h3><p>残差网络是由一系列残差块组成的（图1）。一个残差块可以用表示为：</p><p class='p center'>$x_{l+1}=x_l+F(x_l，W_l)$</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.969i4oz9f9.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.969i4oz9f9.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图1:残差块"/></div><span class="image-caption">图1:残差块</span></div><blockquote><p>图1中的Weight在卷积网络中是指卷积操作，addition指的是单位加操作，即在卷积计算中的相加步骤。<br>卷积计算的4个步骤为反折、平移、相乘、相加。将两组数进行卷积后，变成第三组数，其中相加就是addition。</p></blockquote><p><strong>残差块分成两部分-直接映射部分和残差部分。</strong></p><ul><li>$h(x_l)$是直接映射，反应在图1中是左边的曲线</li><li>$F(x_l，W_l)$是残差部分，一般由两个或者三个卷积操作构成，即图1中右侧包含卷积的部分。</li></ul><p>在卷积网络中,$x_l$可能和$x_{l+1}$的Feature Map的数量不一样，这时候就需要使用$1×1$卷积进行升维或者降维（图2）。</p><div class="tagLink"><a class="link-card" title="$1×1$卷积核" href="https://tumytime.space/2024/03/21/1x1%E5%8D%B7%E7%A7%AF%E6%A0%B8/"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/image.7awxc3fekp.webp)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/image.7awxc3fekp.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7awxc3fekp.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">$1×1$卷积核</p><p class="url">https://tumytime.space/2024/03/21/1x1%E5%8D%B7%E7%A7%AF%E6%A0%B8/</p></div></a></div><p>这时，残差块表示为：</p><p class='p center'>$x_{l+1}=h(x_l)+F(x_l，W_l)$</p><p>其中$h(x_l)&#x3D;W_l^{‘}x$。其中$W_l^{‘}$是$1×1$卷积操作，但是实验结果$1×1$卷积对模型性能提升有限，所以一般是在升维或者降维时才会使用。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.54xiqiz1jd.webp ,alt=$1×1$残差块" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.54xiqiz1jd.webp ,alt=$1×1$残差块" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>一般，这种版本的残差块叫做resnet_v1，keras代码实现如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">res_block_v1</span>(<span class="params">x, input_filter, output_filter</span>):</span><br><span class="line">    res_x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    res_x = BatchNormalization()(res_x)</span><br><span class="line">    res_x = Activation(<span class="string">&#x27;relu&#x27;</span>)(res_x)</span><br><span class="line">    res_x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(res_x)</span><br><span class="line">    res_x = BatchNormalization()(res_x)</span><br><span class="line">    <span class="keyword">if</span> input_filter == output_filter:</span><br><span class="line">        identity = x</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#需要升维或者降维</span></span><br><span class="line">        identity = Conv2D(kernel_size=(<span class="number">1</span>,<span class="number">1</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    x = keras.layers.add([identity, res_x])</span><br><span class="line">    output = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>这段代码定义了一个简单的残差块（residual block），用于构建残差神经网络（ResNet）中的一个基本单元。在这段代码中，<code>res_block_v1</code>函数接受输入特征<code>x</code>，输入的卷积核数量<code>input_filter</code>和输出的卷积核数量<code>output_filter</code>作为参数，然后构建一个残差块，并返回处理后的输出特征。</p><p>具体实现过程如下：</p><ol><li>使用一个3x3大小的卷积核，输出通道数为<code>output_filter</code>，步长为1，填充方式为’same’进行卷积操作，并接上BatchNormalization层和ReLU激活函数。</li><li>再次使用一个3x3大小的卷积核，输出通道数为<code>output_filter</code>，步长为1，填充方式为’same’进行卷积操作，并接上BatchNormalization层。</li><li>根据输入卷积核数量和输出卷积核数量是否相等，判断是否需要进行维度加减变换，如果相等则直接将输入特征作为恒等映射（identity），否则使用1x1的卷积核进行维度变换。</li><li>将恒等映射和经过两次卷积操作的特征相加，得到残差连接。</li><li>对残差连接的结果进行ReLU激活函数操作，最终输出处理后的特征。</li></ol><p>这段代码展示了如何实现一个简单的残差块，用于搭建深度残差神经网络，通过残差连接来解决深度神经网络训练中的梯度消失和梯度爆炸问题，帮助网络更好地训练和优化。</p><h3 id="残差网络的搭建"><a href="#残差网络的搭建" class="headerlink" title="残差网络的搭建"></a>残差网络的搭建</h3><p>残差网络的搭建分为两步：</p><ol><li>使用VGG公式搭建Plain VGG网络</li><li>在Plain VGG的卷积网络之间插入Identity Mapping，注意需要升维或者降维的时候加入$1×1$卷积。<br>在实现过程中，一般是直接stack残差块的方式。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_v1</span>(<span class="params">x</span>):</span><br><span class="line">    x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=<span class="number">16</span>, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    x = res_block_v1(x, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">    x = res_block_v1(x, <span class="number">16</span>, <span class="number">32</span>)</span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    outputs = Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure></li></ol><h3 id="为什么叫残差网络"><a href="#为什么叫残差网络" class="headerlink" title="为什么叫残差网络"></a>为什么叫残差网络</h3><p>在统计学中，残差和误差是非常容易混淆的两个概念。误差是衡量观测值和真实值之间的差距，残差是指预测值和观测值之间的差距。对于残差网络的命名原因，作者给出的解释是，网络的一层通常可以看做$y&#x3D;H(x)$, 而残差网络的一个残差块可以表示为$H(x)&#x3D;F(x)+x$，也就是$F(x)&#x3D;H(x)-x$，在单位映射中，$y&#x3D;x$便是观测值，而$H(x)$是预测值，所以$F(x)$便对应着残差，因此叫做残差网络。</p><h3 id="略"><a href="#略" class="headerlink" title="略"></a>略</h3><h3 id="将激活函数移动到残差部分可以提高模型的精度"><a href="#将激活函数移动到残差部分可以提高模型的精度" class="headerlink" title="将激活函数移动到残差部分可以提高模型的精度"></a>将激活函数移动到残差部分可以提高模型的精度</h3><p>该网络一般就在resnet_v2，keras实现如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">res_block_v2</span>(<span class="params">x, input_filter, output_filter</span>):</span><br><span class="line">    res_x = BatchNormalization()(x)</span><br><span class="line">    res_x = Activation(<span class="string">&#x27;relu&#x27;</span>)(res_x)</span><br><span class="line">    res_x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(res_x)</span><br><span class="line">    res_x = BatchNormalization()(res_x)</span><br><span class="line">    res_x = Activation(<span class="string">&#x27;relu&#x27;</span>)(res_x)</span><br><span class="line">    res_x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(res_x)</span><br><span class="line">    <span class="keyword">if</span> input_filter == output_filter:</span><br><span class="line">        identity = x</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#需要升维或者降维</span></span><br><span class="line">        identity = Conv2D(kernel_size=(<span class="number">1</span>,<span class="number">1</span>), filters=output_filter, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    output= keras.layers.add([identity, res_x])</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_v2</span>(<span class="params">x</span>):</span><br><span class="line">    x = Conv2D(kernel_size=(<span class="number">3</span>,<span class="number">3</span>), filters=<span class="number">16</span> , strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    x = res_block_v2(x, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">    x = res_block_v2(x, <span class="number">16</span>, <span class="number">32</span>)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    y = Flatten()(x)</span><br><span class="line">    outputs = Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(y)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线*******************"></a>分割线*******************</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;详解残差网络&quot; href=&quot;https://zhuanlan.zhihu.com/p/42706477&quot;&gt;&lt;span class=&quot;link-card-backdrop&quot; style</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="深度学习" scheme="http://tumytime.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯stm32学习笔记（八）：模数转换ADC</title>
    <link href="http://tumytime.github.io/2024/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2ADC/"/>
    <id>http://tumytime.github.io/2024/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2ADC/</id>
    <published>2024-03-18T12:27:33.000Z</published>
    <updated>2024-03-19T09:16:54.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><h4 id="配置引脚"><a href="#配置引脚" class="headerlink" title="配置引脚"></a>配置引脚</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2h82d2oxha.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2h82d2oxha.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>我们这里先只用R37</p><p>配置<code>PB15</code>为<code>ADC2_IN15</code></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6t6vkmcqb6.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6t6vkmcqb6.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>选择<code>Single_ended</code></p><h4 id="生成工程"><a href="#生成工程" class="headerlink" title="生成工程"></a>生成工程</h4><p><strong>点击右上角”GENERATE CODE”,生成工程</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="aadc-c"><a href="#aadc-c" class="headerlink" title="aadc.c"></a>aadc.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aadc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">getADC</span><span class="params">(ADC_HandleTypeDef *pin)</span></span><br><span class="line">&#123;</span><br><span class="line">uint adc;</span><br><span class="line">HAL_ADC_Start (pin);</span><br><span class="line">adc = HAL_ADC_GetValue(pin);</span><br><span class="line"><span class="keyword">return</span> adc*<span class="number">3.3</span>/<span class="number">4096</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="aadc-h"><a href="#aadc-h" class="headerlink" title="aadc.h"></a>aadc.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">getADC</span><span class="params">(ADC_HandleTypeDef *pin)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数 <code>getADC</code> 是一个用于从ADC（模拟到数字转换器）读取模拟信号并将其转换为电压值的函数。让我们一步步地分析这个函数：</p><ol><li><strong>函数签名</strong>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getADC</span><span class="params">(ADC_HandleTypeDef *pin)</span></span><br></pre></td></tr></table></figure><ul><li><code>double</code>: 函数的返回类型是<code>double</code>，这意味着它将返回一个浮点数。</li><li><code>ADC_HandleTypeDef *pin</code>: 函数接受一个指向<code>ADC_HandleTypeDef</code>类型的指针，这个指针指向一个ADC句柄，它包含了ADC的配置信息和状态信息。</li></ul><ol start="2"><li><strong>函数体</strong>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> uint adc;</span><br><span class="line"> HAL_ADC_Start (pin);</span><br><span class="line"> adc = HAL_ADC_GetValue(pin);</span><br><span class="line"> <span class="keyword">return</span> adc*<span class="number">3.3</span>/<span class="number">4096</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>uint adc;</code>: 定义了一个无符号整数变量<code>adc</code>，用于存储从ADC读取的原始值。</li><li><code>HAL_ADC_Start (pin);</code>: 调用HAL库（硬件抽象层库）中的<code>HAL_ADC_Start</code>函数来启动指定的ADC。这个函数接受一个ADC句柄（即<code>pin</code>）作为参数。</li><li><code>adc = HAL_ADC_GetValue(pin);</code>: 在ADC转换完成后，调用<code>HAL_ADC_GetValue</code>函数来获取转换后的ADC值，并将其存储在<code>adc</code>变量中。</li><li><code>return adc*3.3/4096;</code>: 返回转换后的电压值。这里假设ADC是一个12位的ADC（因此最大值是4095或4096，取决于具体的实现和计数方式），其参考电压是3.3V。因此，<code>adc*3.3/4096</code>这个公式将ADC的原始读数转换成了相应的电压值。</li></ul><p>总之，这个函数的主要目的是从指定的ADC读取模拟信号，并将其转换为一个表示电压的浮点数。这个电压值是基于ADC的参考电压（在这个例子中是3.3V）和ADC的位数（在这个例子中是12位）来计算的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CubeMX配置&quot;&gt;&lt;a href=&quot;#CubeMX配置&quot; class=&quot;headerlink&quot; title=&quot;CubeMX配置&quot;&gt;&lt;/a&gt;CubeMX配置&lt;/h3&gt;&lt;h4 id=&quot;配置引脚&quot;&gt;&lt;a href=&quot;#配置引脚&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯stm32学习笔记（七）：输入捕获（频率，占空比测量）</title>
    <link href="http://tumytime.github.io/2024/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%EF%BC%88%E9%A2%91%E7%8E%87%EF%BC%8C%E5%8D%A0%E7%A9%BA%E6%AF%94%E6%B5%8B%E9%87%8F%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%EF%BC%88%E9%A2%91%E7%8E%87%EF%BC%8C%E5%8D%A0%E7%A9%BA%E6%AF%94%E6%B5%8B%E9%87%8F%EF%BC%89/</id>
    <published>2024-03-18T09:03:06.000Z</published>
    <updated>2024-03-19T08:58:06.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>跳线帽拔了不能烧工程。。。。(好像可以。。。那天不知道怎么了板子抽风)</p></blockquote><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><h4 id="配置引脚"><a href="#配置引脚" class="headerlink" title="配置引脚"></a>配置引脚</h4><p><strong>我们这里使用<code>PA7</code>进行捕获</strong></p><p><strong>配置<code>PA7</code>为<code>TIM17_CH1</code></strong><br>(只有一个通道没关系，我的题目里不用测占空比，但是我后面会写加上测占空比的引脚和程序的)</p><ul><li>配置一下引脚  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5j3yd4e8d4.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5j3yd4e8d4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li>使能定时器中断  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7awx810hqy.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7awx810hqy.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li></ul><h4 id="生成工程"><a href="#生成工程" class="headerlink" title="生成工程"></a>生成工程</h4><p><strong>点击右上角”GENERATE CODE”,生成工程</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h4><p><strong>interrupt.c中：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint ccrl_val=<span class="number">0</span>;</span><br><span class="line">uint frq=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断回调函数名记不住的话和按键那一章一样，在tim.h文件里找</p><details open><summary pointer> 中断回调函数 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance==TIM17)</span><br><span class="line">&#123;</span><br><span class="line">ccrl_val = HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1);</span><br><span class="line">frq=(<span class="number">80000000</span>/<span class="number">80</span>)/ccrl_val;</span><br><span class="line">__HAL_TIM_SetCounter(htim,<span class="number">0</span>);</span><br><span class="line">HAL_TIM_IC_Start(htim,TIM_CHANNEL_1);<span class="comment">//IC:Input Capture</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><blockquote><p>注意自己写的中断回调函数有什么用，如果不写自己的回调函数，已设置的中断照样正常运行，自己的函数是用来特殊化一些中断流程的，没有特殊化的仍旧按照默认正常运行</p></blockquote><blockquote><p><strong>原理解释:</strong><br>当TIM17的中断触发(因为配置了上升沿触发，即当检测到上升沿时)<br>进入中断回调函数<br>因为最后一行才启动定时器的输入捕获通道1<br>所以第一次触发后，计数器归0(__HAL_TIM_SetCounter(htim,0);)<br>启动定时器的输入捕获通道1,开始计数<br>第二次触发中断(即第二次上升沿)<br>ccrl_val读取到两个上升沿间隔(因为第一个上升沿才开始计数)<br>所以频率等于时钟主频除以分频系数除以周期计数<br>重新启动定时器的输入捕获通道1</p></blockquote><h4 id="main-c中配置"><a href="#main-c中配置" class="headerlink" title="main.c中配置"></a>main.c中配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint frq;</span><br><span class="line">uchar pa1_duty=<span class="number">10</span>;<span class="comment">//初始化占空比</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main函数里的初始化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim4 );<span class="comment">//按键的定时器</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim2,TIM_CHANNEL_2);<span class="comment">//PA1的PWM输出开启</span></span><br><span class="line"></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim17,TIM_CHANNEL_1);<span class="comment">//频率测量捕获定时器开启</span></span><br><span class="line"></span><br><span class="line">__HAL_TIM_SetCompare(&amp;htim2,TIM_CHANNEL_2,pa1_duty);<span class="comment">//设置初始pwm频率</span></span><br></pre></td></tr></table></figure><h3 id="同时测频率和占空比："><a href="#同时测频率和占空比：" class="headerlink" title="同时测频率和占空比："></a>同时测频率和占空比：</h3><h4 id="引脚配置"><a href="#引脚配置" class="headerlink" title="引脚配置"></a>引脚配置</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.41xtci74hr.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.41xtci74hr.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////测量频率+占空比///////////////////</span></span><br><span class="line"><span class="type">double</span> ccr1_val1a=<span class="number">0</span>,ccr1_val2a=<span class="number">0</span>;</span><br><span class="line">uint ccr1_val1b=<span class="number">0</span>,ccr1_val2b=<span class="number">0</span>;</span><br><span class="line">uint frq1=<span class="number">0</span>,frq2=<span class="number">0</span>;<span class="comment">//频率</span></span><br><span class="line"><span class="type">float</span> duty1=<span class="number">0</span>,duty2=<span class="number">0</span>;<span class="comment">//占空比</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance==TIM17)<span class="comment">//PA7</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(htim-&gt;Channel==HAL_TIM_ACTIVE_CHANNEL_1)//中断消息来源 选择直接输入的通道</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">ccr1_val1a=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1);<span class="comment">//直接</span></span><br><span class="line"><span class="comment">//ccr1_val1b=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_2);//间接</span></span><br><span class="line">__HAL_TIM_SetCounter(htim,<span class="number">0</span>);</span><br><span class="line">frq1=(<span class="number">80000000</span>/<span class="number">80</span>)/ccr1_val1a;</span><br><span class="line"><span class="comment">//duty1=(ccr1_val1b/ccr1_val1a)*100;</span></span><br><span class="line">HAL_TIM_IC_Start(htim,TIM_CHANNEL_1);</span><br><span class="line"><span class="comment">//HAL_TIM_IC_Start(htim,TIM_CHANNEL_2);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance==TIM3)<span class="comment">//PB4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Channel==HAL_TIM_ACTIVE_CHANNEL_1)<span class="comment">//中断消息来源 选择直接输入的通道</span></span><br><span class="line">&#123;</span><br><span class="line">ccr1_val2a=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_1);</span><br><span class="line">ccr1_val2b=HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_2);</span><br><span class="line">__HAL_TIM_SetCounter(htim,<span class="number">0</span>);</span><br><span class="line">frq2=(<span class="number">80000000</span>/<span class="number">80</span>)/ccr1_val2a;</span><br><span class="line">duty2=(ccr1_val2b/ccr1_val2a)*<span class="number">100</span>;</span><br><span class="line">HAL_TIM_IC_Start(htim,TIM_CHANNEL_1);</span><br><span class="line">HAL_TIM_IC_Start(htim,TIM_CHANNEL_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;跳线帽拔了不能烧工程。。。。(好像可以。。。那天不知道怎么了板子抽风)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;CubeMX配置&quot;&gt;&lt;a href=&quot;#CubeMX配置&quot; class=&quot;headerlink&quot; title=&quot;CubeMX</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="stm32" scheme="http://tumytime.github.io/tags/stm32/"/>
    
    <category term="蓝桥杯" scheme="http://tumytime.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯stm32学习笔记（六）：PWM输出</title>
    <link href="http://tumytime.github.io/2024/03/17/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9APWM%E8%BE%93%E5%87%BA/"/>
    <id>http://tumytime.github.io/2024/03/17/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9APWM%E8%BE%93%E5%87%BA/</id>
    <published>2024-03-17T11:01:43.000Z</published>
    <updated>2024-03-19T08:39:12.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PWM的占空比改变的是CCR寄存器的值（不同通道对应不同的CCR），频率的改变对应的是ARR寄存器的值</p></blockquote><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><h4 id="配置引脚"><a href="#配置引脚" class="headerlink" title="配置引脚"></a>配置引脚</h4><blockquote><p>频率是指PWM信号的周期性重复频率，即PWM信号在一段时间内完整周期重复的次数。频率与占空比和自动重载值之间存在以下关系：</p><ol><li>PWM信号的频率 &#x3D; 1 &#x2F; PWM信号的周期</li><li>PWM信号的周期 &#x3D; 自动重载值 + 1</li><li>PWM信号的占空比 &#x3D; 高电平时间 &#x2F; PWM信号的周期</li></ol></blockquote><p><strong>我们这里配置PC9输出PWM波</strong><br>配置<code>PC9</code>引脚为<code>TIM3_CH4</code>,选择定时器<code>TIM3</code>的通道4(有哪个用哪个)<br>(后面带<code>N</code>的是互补PWM波)</p><blockquote><p>PWM频率 &#x3D; 1 &#x2F; (周期时间)<br>单个脉冲宽度 &#x3D; (占空比) * (周期时间)</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.ibvk6580f.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.ibvk6580f.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="生成工程"><a href="#生成工程" class="headerlink" title="生成工程"></a>生成工程</h4><p><strong>点击右上角”GENERATE CODE”,生成工程</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="打开定时器"><a href="#打开定时器" class="headerlink" title="打开定时器"></a>打开定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_4);</span><br></pre></td></tr></table></figure><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><details open><summary pointer> while(1) </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">LED_Disp(<span class="number">0x00</span>);<span class="comment">//LED的初始化</span></span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">2</span>].single_flag==<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">w+=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(w&gt;<span class="number">10000</span>)</span><br><span class="line">&#123;</span><br><span class="line">w=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">TIM3-&gt;CCR4 = w;</span><br><span class="line">key[<span class="number">2</span>].single_flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;PWM的占空比改变的是CCR寄存器的值（不同通道对应不同的CCR），频率的改变对应的是ARR寄存器的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;CubeMX配置&quot;&gt;&lt;a href=&quot;#CubeMX配置&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="stm32" scheme="http://tumytime.github.io/tags/stm32/"/>
    
    <category term="蓝桥杯" scheme="http://tumytime.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯stm32学习笔记（五）：按键</title>
    <link href="http://tumytime.github.io/2024/03/16/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8C%89%E9%94%AE/"/>
    <id>http://tumytime.github.io/2024/03/16/%E8%93%9D%E6%A1%A5%E6%9D%AFstm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%8C%89%E9%94%AE/</id>
    <published>2024-03-16T10:24:00.000Z</published>
    <updated>2024-03-17T11:01:12.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="短按键"><a href="#短按键" class="headerlink" title="短按键"></a>短按键</h2><h3 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1lbkuno8bo.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1lbkuno8bo.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>按键按下后接地变为低电平，未按下为高电平；</p><h4 id="不用定时器的简单按键："><a href="#不用定时器的简单按键：" class="headerlink" title="不用定时器的简单按键："></a>不用定时器的简单按键：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_0)==GPIO_PIN_RESET ) &#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_8,GPIO_PIN_RESET );</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_8,GPIO_PIN_SET );</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><h4 id="引脚配置"><a href="#引脚配置" class="headerlink" title="引脚配置"></a>引脚配置</h4><p>配置<code>PB0-2</code>和<code>PA0</code>为<code>GPIO_Input</code><br>并将<code>GPIO Pull-up/Pull-down</code>配置为<code>Pull-up</code></p><h4 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h4><p>选一个定时器（这里选择TIM4）</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7smyutv65f.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7smyutv65f.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>配置时钟源为内部时钟</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.wibapqvqk.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.wibapqvqk.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><details open><summary pointer> 选项解释 </summary>              <div class='content'>              <ol><li><p><strong>Prescaler (PSC-16 bits value)</strong>:</p><ul><li>Prescaler是用于将输入时钟频率进行分频的参数，以降低计数器的工作频率。16位值表示了分频比，用于控制计数器每次计数之前如何分频输入时钟。较大的分频比会使计数器工作在较低的频率下。例如，如果一个系统的输入时钟频率为10 MHz，而计数器需要以1 kHz的频率进行计数，那么可以通过设置适当的预分频器值来实现这一要求。假设我们设置预分频器的16位值为10000，在这种情况下，输入时钟在进入计数器之前会先进行10,000倍的分频。这样，每10,000个输入时钟周期，计数器才会计数一次，从而使得计数器的工作频率为1 kHz。不同的应用场景会有不同的计数需求。例如，某些应用可能需要高速计数，一种计数器的频率可能需要达到几十MHz甚至更高的频率。在这种情况下，计数器需要以更高的速率进行计数，以满足对计数精度和速度的要求。另一方面，一些应用可能只需要低速计数，比如在一些传感器监测系统中，计数器可以以较低的频率进行计数，以实时监测并记录事件发生的次数。</li></ul></li><li><p><strong>Counter Mode</strong>:</p><ul><li>此处设置计数器的工作模式为”Up”，即计数器会从0开始递增计数，计数到最大值后重新从0开始。</li></ul></li><li><p><strong>Dithering</strong>:</p><ul><li>在这里设置了禁用抖动（Dithering），抖动是指通过微小的随机变化来减小量化误差的一种技术。在这种情况下，抖动被禁用，即不会在计数器中引入这种微小的变化。</li></ul></li><li><p><strong>Counter Period (AutoReload Register)</strong>:</p><ul><li>设置计数器的计数周期，通常通过AutoReload Register（自动重装载寄存器）来实现。在这里设置了计数器的周期为0到65535之间的值，当计数器达到最大值时会重新加载初始值。</li></ul></li><li><p><strong>Internal Clock Division (CKD)</strong>:</p><ul><li>设置内部时钟分频（CKD），在这里选择了”No Division”，表示计数器的时钟不会被分频，以确保计数器运行在输入时钟的最高频率下。</li></ul></li><li><p><strong>Auto-reload preload</strong>:</p><ul><li>在这里禁用了自动加载预设值功能，即不会在计数器自动重新加载时预先装载新的值。</li></ul></li></ol><p>这些设置有助于调整计时器&#x2F;计数器的行为和性能，例如调整计数模式、周期以及时钟分频等，以满足特定的应用需求。通过合理设置这些参数，可以有效地控制计时器&#x2F;计数器的功能，确保其在系统中正确、稳定地运行。</p>              </div>            </details><ol><li><p><strong>Prescaler</strong>:分频系数，决定定时器的工作频率<br> 定时器工作频率&#x3D;外部总线频率(80MHz)&#x2F;(PSC+1)<br> 这里设置为80-1,即定时器工作频率&#x3D;80，000，000&#x2F;80&#x3D;1，000，000</p></li><li><p><strong>Counter Period</strong>:<br> 定时频率&#x3D;定时器工作频率&#x2F;counter<br> 这里设置为10000-1,即定时频率&#x3D;1，000，000&#x2F;10，000&#x3D;100Hz，即定时周期10ms;<br> 10ms中断一次；</p></li></ol><p><strong>使能中断</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4n7gvyvfe6.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4n7gvyvfe6.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="生成工程"><a href="#生成工程" class="headerlink" title="生成工程"></a>生成工程</h4><p><strong>点击右上角”GENERATE CODE”,生成工程</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="新建两个文件"><a href="#新建两个文件" class="headerlink" title="新建两个文件"></a>新建两个文件</h4><p>保存<code>interrupt.c</code>和<code>interrupt.h</code>到<code>bsp</code>文件夹<br>然后添加<code>interrupt.c</code>到项目<code>bsp</code>文件夹里</p><h4 id="写中断回调函数"><a href="#写中断回调函数" class="headerlink" title="写中断回调函数"></a>写中断回调函数</h4><p>记不住函数名复制这个:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.wibaqozwy.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.wibaqozwy.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="interrupt-h"><a href="#interrupt-h" class="headerlink" title="interrupt.h"></a>interrupt.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INTERRUPT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERRUPT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uchar judge;</span><br><span class="line"><span class="type">bool</span> status;</span><br><span class="line"><span class="type">bool</span> single_flag;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="interrupt-c"><a href="#interrupt-c" class="headerlink" title="interrupt.c"></a>interrupt.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys</span> <span class="title">key</span>[4]=</span> &#123;&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span> &#123;</span><br><span class="line"></span><br><span class="line">key[<span class="number">0</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_0);</span><br><span class="line">key[<span class="number">1</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_1);</span><br><span class="line">key[<span class="number">2</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_2);</span><br><span class="line">key[<span class="number">3</span>].status=HAL_GPIO_ReadPin (GPIOA,GPIO_PIN_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance==TIM4) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(key[i].judge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">key[i].judge=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">key[i].judge=<span class="number">2</span>;</span><br><span class="line">key[i].single_flag=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;key[i].judge=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key[i].judge=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-c中extern结构体-打开中断"><a href="#main-c中extern结构体-打开中断" class="headerlink" title="main.c中extern结构体&#x2F;打开中断"></a>main.c中extern结构体&#x2F;打开中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">keys</span> <span class="title">key</span>[];</span></span><br></pre></td></tr></table></figure><p><strong>main函数里：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim4 );</span><br></pre></td></tr></table></figure><blockquote><p>一定要放在<code>MX_TIM4_Init();</code>后面！！！！！！！！！！！</p></blockquote><blockquote><p>启动定时器 TIM4 的基本定时器模式并使能定时器中断.</p></blockquote><h2 id="长按键"><a href="#长按键" class="headerlink" title="长按键"></a>长按键</h2><h3 id="interrupt-h-1"><a href="#interrupt-h-1" class="headerlink" title="interrupt.h"></a>interrupt.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INTERRUPT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERRUPT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uchar judge;</span><br><span class="line"><span class="type">bool</span> status;</span><br><span class="line"><span class="type">bool</span> single_flag;</span><br><span class="line"><span class="type">bool</span> long_flag;</span><br><span class="line">uint time;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="interrupt-c-1"><a href="#interrupt-c-1" class="headerlink" title="interrupt.c"></a>interrupt.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys</span> <span class="title">key</span>[4]=</span> &#123;&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span> &#123;</span><br><span class="line"></span><br><span class="line">key[<span class="number">0</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_0);</span><br><span class="line">key[<span class="number">1</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_1);</span><br><span class="line">key[<span class="number">2</span>].status=HAL_GPIO_ReadPin (GPIOB,GPIO_PIN_2);</span><br><span class="line">key[<span class="number">3</span>].status=HAL_GPIO_ReadPin (GPIOA,GPIO_PIN_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance==TIM4) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">switch</span>(key[i].judge) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">0</span>) &#123;</span><br><span class="line">key[i].judge=<span class="number">1</span>;</span><br><span class="line">key[i].time =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">0</span>) &#123;</span><br><span class="line">key[i].judge=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//key[i].single_flag=1;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key[i].judge=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i].status==<span class="number">1</span>) &#123;</span><br><span class="line">key[i].judge=<span class="number">0</span>;</span><br><span class="line">key[i].single_flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(key[i].time&lt;<span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line">key[i].long_flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key[i].time++;</span><br><span class="line"><span class="keyword">if</span>(key[i].time&gt;<span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line">key[i].long_flag=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>key[i].time&gt;200:</strong><br>之前配置的定时器一个周期10ms,<strong>200也就是2s</strong></p><h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span>  view=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_proc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">0</span>].single_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">key[<span class="number">0</span>].single_flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">1</span>].single_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">view++;</span><br><span class="line"><span class="keyword">if</span>(view&gt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">view=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key[<span class="number">1</span>].single_flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">2</span>].single_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">key[<span class="number">2</span>].single_flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">3</span>].single_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">key[<span class="number">3</span>].single_flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(view==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> text[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(text,<span class="string">&quot;  view=0      &quot;</span>);</span><br><span class="line">LCD_DisplayStringLine(Line9, (<span class="type">uint8_t</span> *)text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(view==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> text[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(text,<span class="string">&quot;  view=1      &quot;</span>);</span><br><span class="line">LCD_DisplayStringLine(Line9, (<span class="type">uint8_t</span> *)text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(view==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> text[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(text,<span class="string">&quot;  view=2      &quot;</span>);</span><br><span class="line">LCD_DisplayStringLine(Line9, (<span class="type">uint8_t</span> *)text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;短按键&quot;&gt;&lt;a href=&quot;#短按键&quot; class=&quot;headerlink&quot; title=&quot;短按键&quot;&gt;&lt;/a&gt;短按键&lt;/h2&gt;&lt;h3 id=&quot;电路图&quot;&gt;&lt;a href=&quot;#电路图&quot; class=&quot;headerlink&quot; title=&quot;电路图&quot;&gt;&lt;/a&gt;电路图&lt;/h</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="stm32" scheme="http://tumytime.github.io/tags/stm32/"/>
    
    <category term="蓝桥杯" scheme="http://tumytime.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
</feed>
