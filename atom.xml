<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello！Welcom to Tumy-Time！</title>
  
  
  <link href="http://tumytime.github.io/atom.xml" rel="self"/>
  
  <link href="http://tumytime.github.io/"/>
  <updated>2024-09-07T15:25:24.858Z</updated>
  <id>http://tumytime.github.io/</id>
  
  <author>
    <name>tumytime</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL环境配置</title>
    <link href="http://tumytime.github.io/2024/09/07/OpenGL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://tumytime.github.io/2024/09/07/OpenGL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-09-07T15:13:29.000Z</published>
    <updated>2024-09-07T15:25:24.858Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="OpenGL开发必过的坎------开发环境的准备(Windows10)" href="https://blog.csdn.net/zxj2589/article/details/130467844?ops_request_misc=&request_id=&biz_id=102&utm_term=opengl%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-130467844.142^v100^pc_search_result_base2&spm=1018.2226.3001.4187"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3nrjfx6xzp.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">OpenGL开发必过的坎------开发环境的准备(Windows10)</p><p class="url">https://blog.csdn.net/zxj2589/article/details/130467844?ops_request_misc=&request_id=&biz_id=102&utm_term=opengl%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-130467844.142^v100^pc_search_result_base2&spm=1018.2226.3001.4187</p></div></a></div><blockquote><p>glut只能在x86下运行，如果要用的话记得开x86，并把别的库也改成32位的</p></blockquote><blockquote><p>想用x64的话可以用freeglut库，支持x64，和glut功能基本一样</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;OpenGL开发必过的坎------开发环境的准备(Windows10)&quot; href=&quot;https://blog.csdn.net/zxj2589/article/details/1</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://tumytime.github.io/categories/OpenGL/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="OpenGL" scheme="http://tumytime.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>科目四</title>
    <link href="http://tumytime.github.io/2024/08/22/%E7%A7%91%E7%9B%AE%E5%9B%9B/"/>
    <id>http://tumytime.github.io/2024/08/22/%E7%A7%91%E7%9B%AE%E5%9B%9B/</id>
    <published>2024-08-22T12:29:00.000Z</published>
    <updated>2024-08-22T16:26:42.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没事哒没事哒我没事哒</p></blockquote><h2 id="仪表指示灯题"><a href="#仪表指示灯题" class="headerlink" title="仪表指示灯题"></a>仪表指示灯题</h2><ol><li><p>水温表时用来指示<strong>发动机</strong>的温度</p></li><li><p>三个向上箭头，后面是矩形-&gt;<strong>后</strong>挡风除雾；后面是扇形-&gt;<strong>前</strong>挡风除雾</p></li></ol><h2 id="危险化学品题"><a href="#危险化学品题" class="headerlink" title="危险化学品题"></a>危险化学品题</h2><ol><li><p>火药、炸药、起爆药属于<strong>爆炸品</strong></p></li><li><p>火柴、硫磺、赤磷属于<strong>易燃固体</strong></p></li><li><p><strong>液体&#x2F;腐蚀品</strong>起火不可都用水</p></li><li><p>有毒气体应站<strong>上风处</strong></p></li><li><p>运载危险化学品应经<strong>公安机关</strong>批准</p></li></ol><h2 id="特殊天气题"><a href="#特殊天气题" class="headerlink" title="特殊天气题"></a>特殊天气题</h2><ol><li><p>能见度低:</p><ul><li>&lt;200m:开启雾灯、近光灯、示廓灯、前后位灯，车速&lt;60km&#x2F;h，车距&gt;100m</li><li>&lt;100m:开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速&lt;40km&#x2F;h，车距&gt;50m</li><li>&lt;50m: 开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速&lt;20km&#x2F;h，并从最近的出口尽快驶离高速公路</li></ul></li><li><p><strong>刚下雨</strong>的路面最容易发生侧滑</p></li><li><p>在冰雪路面上减速或停车，应充分利用发动机的牵制作用</p></li><li><p>冰雪路面不可急转向</p></li><li><p>冰雪路面，但是没下雪&#x2F;雨，不用开雾灯</p></li><li><p>机动车雾天行驶，开雾灯和危险报警闪光灯</p></li><li><p>遇到横风车辆产生偏移时，收油降速，不可紧急制动</p></li><li><p>大风天禁止超车</p></li><li><p>大雨天使用近光灯减速慢行</p></li></ol><h2 id="速度题"><a href="#速度题" class="headerlink" title="速度题"></a>速度题</h2><ol><li><p>高速&gt;60,&lt;120</p></li><li><p>高速两车道：最左侧&gt;100,<br> 高速三车道：&gt;60,&gt;90&gt;110</p></li><li><p>特殊路段&lt;30</p></li></ol><h2 id="标志题"><a href="#标志题" class="headerlink" title="标志题"></a>标志题</h2><p>1. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;没事哒没事哒我没事哒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;仪表指示灯题&quot;&gt;&lt;a href=&quot;#仪表指示灯题&quot; class=&quot;headerlink&quot; title=&quot;仪表指示灯题&quot;&gt;&lt;/a&gt;仪表指示灯题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="驾考" scheme="http://tumytime.github.io/categories/%E9%A9%BE%E8%80%83/"/>
    
    
    <category term="驾考" scheme="http://tumytime.github.io/tags/%E9%A9%BE%E8%80%83/"/>
    
    <category term="科目四" scheme="http://tumytime.github.io/tags/%E7%A7%91%E7%9B%AE%E5%9B%9B/"/>
    
  </entry>
  
  <entry>
    <title>我是一个分界线</title>
    <link href="http://tumytime.github.io/2024/08/13/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%86%E7%95%8C%E7%BA%BF/"/>
    <id>http://tumytime.github.io/2024/08/13/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%86%E7%95%8C%E7%BA%BF/</id>
    <published>2024-08-13T12:24:31.000Z</published>
    <updated>2024-09-07T15:15:20.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这几天一直在学c++，但是学着学着容易没劲，发现我不适合那种跟着课按部就班学东西，还是打算那种给一天干完一个任务的模式</p></blockquote><blockquote><p>或许打算试试软考</p></blockquote><blockquote><p>考试内容大概如下:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4917285z8t.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.9nzpknmnhv.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lzsehtof.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.5c0wd44l0r.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7i0ayvwrfi.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这几天一直在学c++，但是学着学着容易没劲，发现我不适合那种跟着课按部就班学东西，还是打算那种给一天干完一个任务的模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;或许打算试试软考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;bl</summary>
      
    
    
    
    <category term="碎碎念" scheme="http://tumytime.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="http://tumytime.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】内存分区模型</title>
    <link href="http://tumytime.github.io/2024/08/12/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
    <id>http://tumytime.github.io/2024/08/12/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-08-11T18:32:47.000Z</published>
    <updated>2024-09-06T10:59:15.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++程序在执行时，将内存大方向划分位4个区域</p><ul><li><strong>代码区:</strong> 存放函数体的二进制代码,由操作系统进行管理的</li><li><strong>全局区:</strong> 存放全局变量和静态变量以及常量</li><li><strong>栈区:</strong> 由编译器自动分配释放,存放函数的参数值,局部变量等</li><li><strong>堆区:</strong> 由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br><strong>意义:</strong> 不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</li></ul></blockquote><h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域:</p><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><blockquote><p>存放CPU执行的机器指令</p></blockquote><ul><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li></ul><h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><blockquote><p>全局变量、静态变量字符串常量和其他常量存放在此</p></blockquote><blockquote><p>该区域的数据在程序结束后由操作系统释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为:&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>x64(64位)：</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1zi6igjuin.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1zi6igjuin.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>x86(32位):</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.231sg6ei3g.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.231sg6ei3g.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p><strong>Q:</strong> 为什么当vs管理器为x64(64位)时，a的地址比b小32，但是管理器改为x86(32位)时，a比b地址大12</p></blockquote><ul><li>x64架构（64位）<ol><li><strong>栈对齐</strong>：x64架构通常要求栈对齐到16字节或32字节边界，以优化性能并满足某些指令集的要求。这可能导致在局部变量之间插入额外的填充（padding）。</li><li><strong>调用约定</strong>：在x64架构下，函数调用时可能需要在栈上保留更多的空间用于寄存器保存区域（callee-saved registers）和其他目的。这可能导致局部变量之间的地址差异大于它们的大小。</li><li><strong>优化</strong>：编译器可能会在64位模式下执行更积极的优化，这可能会影响变量的布局。</li><li><strong>局部变量大小</strong>：即使局部变量是<code>int</code>类型，它们在栈上的布局也可能会受到其他因素的影响，如调用约定、栈对齐等。</li></ol></li></ul><p>在x64架构下，32字节的差异可能是由于编译器在<code>a</code>和<code>b</code>之间插入了对齐填充，或者由于其他局部变量或保留空间的布局。</p><ul><li>x86架构（32位）<ol><li><strong>栈对齐</strong>：x86架构通常要求栈对齐到4字节边界，这意味着局部变量之间的地址差异通常是它们大小的整数倍。</li><li><strong>调用约定</strong>：在x86架构下，函数调用时在栈上保留的空间通常比x64架构少，因此局部变量之间的地址差异可能更小。</li><li><strong>优化</strong>：编译器在32位模式下的优化可能与64位模式不同，这可能会影响变量的布局。<br>  在x86架构下，12字节的差异可能是因为：<ul><li>在<code>a</code>和<code>b</code>之间可能有其他局部变量或对齐填充。</li><li>编译器可能为了保持栈对齐而插入填充。</li><li>由于某些优化，编译器可能改变了局部变量的顺序或布局。</li></ul></li></ol></li></ul><h2 id="程序运行前-1"><a href="#程序运行前-1" class="headerlink" title="程序运行前"></a>程序运行前</h2><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C++程序在执行时，将内存大方向划分位4个区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码区:&lt;/strong&gt; 存放函数体的二进制代码,由操作系统进行管理的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局区:&lt;/strong&gt; 存放全局变量和静态变量</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】结构体</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2024-08-10T14:49:53.000Z</published>
    <updated>2024-08-11T18:32:07.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>发现个好东西，试一下子</p></blockquote><p><a href="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~"><img src="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~" class="lazyload placeholder" data-srcset="https://api.xecades.xyz/api?img=1&bg=26,140,165,0&bilibili=%E6%97%B6%E5%9F%9FTumy&github=tumytime&qq=2259763426&color=25,0,79,1&date=2024-12-01&quote=%E4%B8%80%E8%B5%B7%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E9%87%8C%E8%82%86%E6%84%8F%E5%A5%94%E8%B7%91%E5%90%A7~" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p></blockquote><h2 id="创建结构体变量"><a href="#创建结构体变量" class="headerlink" title="创建结构体变量"></a>创建结构体变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;<span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;<span class="comment">//分数</span></span><br><span class="line"></span><br><span class="line">&#125;stu3;<span class="comment">//创建方式3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1;<span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu1.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方式2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu2.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; stu3.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建结构体变量时，关键词struct可以省略</p></blockquote><blockquote><p>结构体变量利用操作符”.”访问成员</p></blockquote><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><strong>作用:</strong> 将自定义的结构体放入到数组中方便维护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student arr[<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p><strong>作用:</strong> 通过指针访问结构体中的成员</p><blockquote><p>利用操作符’-&gt;’可以通过结构体指针访问结构体属性</p></blockquote><p>在C语言中，结构体变量和结构体指针访问成员的方式不同，这是由于它们在内存中的存储和访问机制不同。<br>结构体变量使用<code>.</code>操作符访问成员，因为结构体变量本身就是一个具体的实例，它包含了所有成员的数据。当你使用<code>.</code>操作符时，你直接在结构体实例上访问其成员。<br>例如，如果你有一个名为<code>student</code>的结构体，并且有一个<code>student</code>类型的变量<code>stu</code>，你可以这样访问它的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stu.name);  <span class="comment">// 使用 &#x27;.&#x27; 操作符访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.score);</span><br></pre></td></tr></table></figure><p>而结构体指针使用<code>-&gt;</code>操作符访问成员，因为指针本身并不直接包含结构体的数据，而是存储了结构体数据的内存地址。当你使用<code>-&gt;</code>操作符时，你实际上是在告诉编译器：“请先到这个地址去找到结构体实例，然后再访问它的成员。”<br>例如，如果你有一个指向<code>student</code>结构体的指针<code>ptr</code>，你可以这样访问它的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;  <span class="comment">// ptr 指向 stu 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr-&gt;name);   <span class="comment">// 使用 &#x27;-&gt;&#x27; 操作符访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;score);</span><br></pre></td></tr></table></figure><p>这里，<code>ptr-&gt;name</code>是<code>(*ptr).name</code>的简写形式，它首先通过解引用指针<code>*ptr</code>来获取结构体实例，然后通过<code>.</code>操作符访问其<code>name</code>成员。<br>总结来说，<code>.</code>用于直接访问结构体变量的成员，而<code>-&gt;</code>用于通过结构体指针间接访问其指向的结构体实例的成员。</p><h2 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h2><p><strong>示例:</strong><br>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">student stu;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt; 运算符以便输出 student 结构体</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> student&amp; s) &#123;</span><br><span class="line">os &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数: &quot;</span> &lt;&lt; s.score;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">student stu1 = &#123; <span class="string">&quot;时域&quot;</span>,<span class="number">19</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">teacher tea1 = &#123; <span class="string">&quot;余新晨&quot;</span>,<span class="number">20</span>,stu1 &#125;;</span><br><span class="line"></span><br><span class="line">teacher* p = &amp;tea1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot;学生:&quot;</span> &lt;&lt; p-&gt;stu &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>在C++中，运算符重载是一种功能，它允许你为类或结构体定义现有运算符的新行为。通过重载运算符，你可以使它们与用户定义的类型一起工作，就像它们与内置类型一起工作一样。下面是对<code>operator&lt;&lt;</code>重载函数的详细解释：</p><h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> student&amp; s)</span><br></pre></td></tr></table></figure><p>这里，<code>operator&lt;&lt;</code>是正在被重载的运算符，它用于输出（插入）数据到输出流中（比如标准输出<code>cout</code>）。函数接受两个参数：</p><ol><li><code>ostream&amp; os</code>：这是一个引用到输出流的引用，通常是一个<code>std::ostream</code>类型的对象，比如<code>std::cout</code>。使用引用是因为我们不想复制整个流对象，只是想在原对象上操作。</li><li><code>const student&amp; s</code>：这是一个对<code>student</code>结构体的常量引用。我们使用常量引用是因为我们不想修改传入的结构体，并且引用可以避免不必要的复制。</li></ol><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数: &quot;</span> &lt;&lt; s.score;</span><br></pre></td></tr></table></figure><p>在函数体内部，我们使用了<code>&lt;&lt;</code>运算符来将结构体<code>student</code>的成员依次输出到传入的输出流<code>os</code>中。以下是步骤：</p><ol><li><code>os &lt;&lt; &quot;姓名: &quot;</code>：将字符串”姓名: “输出到输出流<code>os</code>。</li><li><code>&lt;&lt; s.name</code>：输出<code>student</code>结构体的<code>name</code>成员。</li><li><code>&lt;&lt; &quot; 年龄: &quot;</code>：输出字符串” 年龄: “。</li><li><code>&lt;&lt; s.age</code>：输出<code>student</code>结构体的<code>age</code>成员。</li><li><code>&lt;&lt; &quot; 分数: &quot;</code>：输出字符串” 分数: “。</li><li><code>&lt;&lt; s.score</code>：输出<code>student</code>结构体的<code>score</code>成员。</li></ol><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> os;</span><br></pre></td></tr></table></figure><p>函数返回一个<code>ostream</code>对象的引用。这是为了允许链式调用，也就是说，你可以连续使用多个<code>&lt;&lt;</code>运算符，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;教师姓名: &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 学生信息: &quot;</span> &lt;&lt; p-&gt;stu &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在这里，每次调用<code>&lt;&lt;</code>运算符后返回的<code>ostream</code>引用都用于下一次调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重载<code>operator&lt;&lt;</code>允许你以自然的方式将<code>student</code>结构体对象输出到标准输出或其他输出流中，而无需单独输出每个成员。这样可以使代码更加简洁，可读性更强。通过返回<code>ostream</code>引用，你还可以继续将其他内容输出到同一个流中。</p><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h2><h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><ol><li>值传递</li><li>地址传递</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu)</span> </span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名:&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student* stu)</span> </span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名:&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot;分数:&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">////值传递</span></span><br><span class="line"><span class="comment">//printStudent(stu);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h2 id="结构体中const使用场景"><a href="#结构体中const使用场景" class="headerlink" title="结构体中const使用场景"></a>结构体中const使用场景</h2><p><strong>作用:</strong> 用const来防止误操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;发现个好东西，试一下子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://api.xecades.xyz/api?img=1&amp;bg=26,140,165,0&amp;bilibili=%E6%97%B6%E5%9F%9FTumy&amp;</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】指针</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8C%87%E9%92%88/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8C%87%E9%92%88/</id>
    <published>2024-08-10T13:41:41.000Z</published>
    <updated>2024-08-10T15:18:05.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>野指针我老熟人了。。。。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>作用:</strong> 通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h2 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.指针的定义</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">    p=&amp;a;</span><br><span class="line">    cout&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.指针的使用</span></span><br><span class="line">    <span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针变量和普通变量的区别"><a href="#指针变量和普通变量的区别" class="headerlink" title="指针变量和普通变量的区别"></a>指针变量和普通变量的区别</h2><ul><li>普通变量存放的是数据，指针变量存放的是地址</li><li>指针变量可以通过”*”操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><blockquote><p>用&amp;获取变量的地址</p></blockquote><h2 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h2><blockquote><p><strong>Q:</strong> 指针也是种数据类型，那么这种数据类型占用多少空间呢？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，指针类型的大小取决于所运行的系统架构。通常情况下：</p><ul><li>在32位系统中，指针通常占用4个字节。</li><li>在64位系统中，指针通常占用8个字节。</li></ul></blockquote><h2 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问空指针报错 </span></span><br><span class="line"><span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><blockquote><p><strong>野指针:</strong> 指针变量指向非法的内存空间</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问野指针报错 </span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编写C++程序时，应确保指针指向有效的内存地址。直接将指针指向一个硬编码的地址，而没有确保该地址是有效和安全的，是一种危险的做法。正确的做法是使用动态内存分配（如new关键字）来获取内存，或者确保指针指向已分配的内存区域。</p></blockquote><blockquote><p>空指针和野指针都不是我们申请的空间，因此不要访问</p></blockquote><h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>在C++中，当使用<code>const</code>修饰指针时，它有两种不同的含义，这取决于<code>const</code>的位置：</p><ol><li><strong><code>const</code>位于星号（*）之前</strong>：这表示指针指向的内容是常量，即不能通过这个指针修改所指向的数据。但指针本身可以改变，指向不同的地址。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x;  <span class="comment">// p是指向int常量的指针</span></span><br><span class="line">p = &amp;y;             <span class="comment">// 正确：可以改变p指向的地址</span></span><br><span class="line">*p = <span class="number">30</span>;            <span class="comment">// 错误：不能通过p修改所指向的数据</span></span><br></pre></td></tr></table></figure></li><li><strong><code>const</code>位于星号（*）之后</strong>：这表示指针本身是常量，即不能更改指针的值（它所指向的地址）。但可以通过指针修改它所指向的数据。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;x;  <span class="comment">// p是常量指针</span></span><br><span class="line">*p = <span class="number">30</span>;            <span class="comment">// 正确：可以通过p修改所指向的数据</span></span><br><span class="line">p = &amp;y;             <span class="comment">// 错误：不能更改p的值（它所指向的地址）</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><blockquote><p>利用指针访问数组中元素</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素:&quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素:&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h2><blockquote><p>利用指针作函数参数，可以修改实参的值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h2><blockquote><p><strong>封装一个函数:</strong> 利用冒泡排序，实现对整型数组的升序排序<br>例如数组:int arr[10]&#x3D;{4,3,6,9,1,2,10,8,7,5};</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>当数组名传入到函数作为参数时，被退化为指向首元素的指针</strong><br>在C++中，当你将数组作为参数传递给函数时，它实际上被转换为一个指向数组首元素的指针。这意味着在函数内部，你没有数组的大小信息。因此，在函数内部无法直接计算数组的长度。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;野指针我老熟人了。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;作用:&lt;/st</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】函数</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%87%BD%E6%95%B0/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-10T13:28:11.000Z</published>
    <updated>2024-08-10T13:36:53.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础注意事项"><a href="#基础注意事项" class="headerlink" title="基础注意事项"></a>基础注意事项</h2><p><strong>函数的声明可以多次，但是函数的定义只能有一次</strong></p><h2 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h2><ol><li>创建头文件</li><li>创建函数.cpp文件</li><li>在头文件里写函数的声明</li><li>在.cpp文件里写函数的定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础注意事项&quot;&gt;&lt;a href=&quot;#基础注意事项&quot; class=&quot;headerlink&quot; title=&quot;基础注意事项&quot;&gt;&lt;/a&gt;基础注意事项&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;函数的声明可以多次，但是函数的定义只能有一次&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】数组</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/</id>
    <published>2024-08-10T10:52:50.000Z</published>
    <updated>2024-08-10T13:27:48.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组是一块连续的内存区域，用于存储固定数量的元素</p><ul><li>元素必须是相同的数据类型</li><li>数组的大小在声明时必须是已知的，并且在程序运行期间不可更改。</li></ul><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><ul><li>int a[10];</li><li>int a[2]&#x3D;{1,2};</li><li>int a[]&#x3D;{1,2};</li></ul><p><strong>数组名不能与变量名重名</strong></p><h3 id="数组名用途"><a href="#数组名用途" class="headerlink" title="数组名用途"></a>数组名用途</h3><ol><li><p>统计整个数组在内存中的长度</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//数组名用途</span></span><br><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>获取数组在内存中的首地址</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>数组名是常量，不可以赋值</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="作用：最常用的排序算法，对数组内元素进行排序"><a href="#作用：最常用的排序算法，对数组内元素进行排序" class="headerlink" title="作用：最常用的排序算法，对数组内元素进行排序"></a><strong>作用：</strong>最常用的排序算法，对数组内元素进行排序</h3><ol><li>比较相邻的元素，如果第一个比第二个大，就交换他们两个</li><li>对每一对相邻元素做相同的工作，执行完毕后，找到第一个最大值</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><h3 id="示例：将数组-4，2，8，0，5，7，1，3，9-进行升序排序"><a href="#示例：将数组-4，2，8，0，5，7，1，3，9-进行升序排序" class="headerlink" title="示例：将数组{4，2，8，0，5，7，1，3，9}进行升序排序"></a><strong>示例</strong>：将数组{4，2，8，0，5，7，1，3，9}进行升序排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span><span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])[</span><br><span class="line">                <span class="type">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>建议打个断点一步步观察一下<br><strong>i的每一步都能保证前i个元素里的最大值被放置在i+1的位置上</strong></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p><strong>数据类型 数组名[行数][列数]</strong></p><ol><li>int a[2][3];</li><li>int a[2][3]&#x3D;<br> {<br> {1,2,3},<br> {4,5,6}<br> };</li><li>int a[2][3]&#x3D;{1,2,3,4,5,6};</li><li>int a[][3]&#x3D;{1,2,3,4,5,6};</li></ol><p><strong>在定义二维数组时，如果初始化了数据，可以省略行数</strong></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>二维数组一行大小:</strong><br>sizeod(a[0])</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;数组是一块连续的内存区域，用于存储固定数量的元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素必须是相同的数据类型&lt;/li&gt;
&lt;li&gt;数组的大小在声明时必</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】程序流程结构</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/</id>
    <published>2024-08-10T10:52:38.000Z</published>
    <updated>2024-08-10T11:20:37.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch语句中表达式类型只能是整型或者字符型</li><li>case里如果没有break，那么程序会一直向下执行</li></ul><h2 id="do…while循环语句"><a href="#do…while循环语句" class="headerlink" title="do…while循环语句"></a>do…while循环语句</h2><p><strong>注意：</strong>与while的区别在于do…while会先执行一次循环语句，再判断循环条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4g4et9b8a7.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4g4et9b8a7.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p><strong>作用：</strong>在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">FLAG:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;switch语句&quot;&gt;&lt;a href=&quot;#switch语句&quot; class=&quot;headerlink&quot; title=&quot;switch语句&quot;&gt;&lt;/a&gt;switch语句&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】运算符</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2024-08-10T10:52:22.000Z</published>
    <updated>2024-08-10T11:20:25.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h2><p><code>i++</code> 和 <code>++i</code> 都是C++（以及其他一些编程语言）中的自增运算符，用于增加变量的值。但是，它们在表达式中使用时的行为有所不同，尤其是在它们被用作表达式的一部分时。<br>以下是 <code>i++</code>（后缀自增）和 <code>++i</code>（前缀自增）的主要区别：</p><h3 id="后缀自增（i-）："><a href="#后缀自增（i-）：" class="headerlink" title="后缀自增（i++）："></a>后缀自增（<code>i++</code>）：</h3><ol><li><strong>值</strong>：表达式 <code>i++</code> 的值是 <code>i</code> 自增前的值。</li><li><strong>副作用</strong>：<code>i</code> 的值会在表达式求值后被增加。</li><li><strong>返回类型</strong>：返回 <code>i</code> 自增前的值的副本。</li><li><strong>使用场景</strong>：当需要在自增之前使用变量的当前值时。<br>例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = i++; <span class="comment">// a 被赋值为 1, 然后 i 自增为 2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="前缀自增（-i）："><a href="#前缀自增（-i）：" class="headerlink" title="前缀自增（++i）："></a>前缀自增（<code>++i</code>）：</h3><ol><li><strong>值</strong>：表达式 <code>++i</code> 的值是 <code>i</code> 自增后的值。</li><li><strong>副作用</strong>：<code>i</code> 的值会在表达式求值前被增加。</li><li><strong>返回类型</strong>：返回 <code>i</code> 自增后的值的副本。</li><li><strong>使用场景</strong>：当需要在自增之后立即使用变量的新值时。<br>例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = ++i; <span class="comment">// i 先自增为 2, 然后 a 被赋值为 2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="具体区别示例："><a href="#具体区别示例：" class="headerlink" title="具体区别示例："></a>具体区别示例：</h3><p>考虑以下代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = i++;</span><br><span class="line"><span class="comment">// 此时 i 为 2, a 为 1</span></span><br><span class="line">b = ++i;</span><br><span class="line"><span class="comment">// 此时 i 为 3, b 为 3</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>a = i++</code> 语句将 <code>i</code> 自增前的值（1）赋给 <code>a</code>，然后 <code>i</code> 自增变为2。而 <code>b = ++i</code> 语句先将 <code>i</code> 自增为3，然后将这个新值赋给 <code>b</code>。</p><h3 id="性能考虑："><a href="#性能考虑：" class="headerlink" title="性能考虑："></a>性能考虑：</h3><p>在大多数现代编译器中，对于基本数据类型（如 <code>int</code>），前缀和后缀自增操作的性能差异非常小，甚至可以忽略不计。编译器通常会优化这些操作。然而，对于用户定义的类型，前缀自增可能更高效，因为它避免了创建对象的副本。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>当自增运算符用作独立语句时（例如 <code>i++;</code> 或 <code>++i;</code>），两者没有区别，都只是增加 <code>i</code> 的值。</li><li>当自增运算符用作表达式的一部分时，<code>i++</code> 返回自增前的值，而 <code>++i</code> 返回自增后的值。<br>始终明确你的意图，并选择正确的自增形式来避免混淆和潜在的bug。</li></ul><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>三目运算符，也称为条件运算符，是C语言及许多其他编程语言中的一个特殊运算符，它允许在单个表达式中进行条件判断。三目运算符的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expression1 : expression2;</span><br></pre></td></tr></table></figure><p>这里，<code>condition</code> 是一个布尔表达式（即它求值为 <code>true</code> 或 <code>false</code>），而 <code>expression1</code> 和 <code>expression2</code> 是任意的表达式。三目运算符的工作原理如下：</p><ol><li>首先，计算 <code>condition</code>。</li><li>如果 <code>condition</code> 为真（即非零），则计算并返回 <code>expression1</code> 的值。</li><li>如果 <code>condition</code> 为假（即零），则计算并返回 <code>expression2</code> 的值。</li></ol><h3 id="语法详细说明："><a href="#语法详细说明：" class="headerlink" title="语法详细说明："></a>语法详细说明：</h3><ul><li><code>condition</code>：必须是一个能够求值为布尔值的表达式。在C&#x2F;C++中，任何非零值都被视为 <code>true</code>，零被视为 <code>false</code>。</li><li><code>expression1</code>：当 <code>condition</code> 为真时将被计算的表达式。它可以是任何类型的表达式，其结果类型将成为整个三目运算符表达式的类型。</li><li><code>expression2</code>：当 <code>condition</code> 为假时将被计算的表达式。它的类型必须与 <code>expression1</code> 的类型兼容，以便整个三目运算符表达式有一个明确的类型。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, max;</span><br><span class="line"><span class="comment">// 使用三目运算符找出 a 和 b 中的最大值</span></span><br><span class="line">max = (a &gt; b) ? a : b;</span><br><span class="line"><span class="comment">// 如果 a 大于 b，则 max 被赋值为 a，否则被赋值为 b</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，如果 <code>a &gt; b</code> 的结果为真，则 <code>max</code> 被赋值为 <code>a</code> 的值；否则，<code>max</code> 被赋值为 <code>b</code> 的值。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>三目运算符可以嵌套使用，但过度使用可能会导致代码难以阅读和理解。</li><li>虽然三目运算符可以用来简化代码，但应谨慎使用，以避免牺牲代码的可读性和可维护性。</li><li><code>expression1</code> 和 <code>expression2</code> 应该具有可兼容的类型，以避免类型转换问题。</li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>简单的条件赋值。</li><li>在单个表达式中替代简单的 <code>if-else</code> 语句。</li><li>作为函数参数。</li></ul><h3 id="示例：嵌套三目运算符"><a href="#示例：嵌套三目运算符" class="headerlink" title="示例：嵌套三目运算符"></a>示例：嵌套三目运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>, z = <span class="number">15</span>, result;</span><br><span class="line"><span class="comment">// 嵌套的三目运算符</span></span><br><span class="line">result = (x &gt; y) ? (x &gt; z ? x : z) : (y &gt; z ? y : z);</span><br><span class="line"><span class="comment">// 如果 x 是最大的，result 被赋值为 x；否则，检查 y 和 z，result 被赋值为两者中较大的一个</span></span><br></pre></td></tr></table></figure><p>在上述嵌套三目运算符的例子中，我们首先检查 <code>x</code> 是否大于 <code>y</code>。如果是，我们再检查 <code>x</code> 是否大于 <code>z</code>，并将结果赋给 <code>result</code>。如果 <code>x</code> 不是最大的，我们检查 <code>y</code> 和 <code>z</code>，并将较大的值赋给 <code>result</code>。尽管这种写法紧凑，但它可能会使代码更难以理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;i-和-i的区别&quot;&gt;&lt;a href=&quot;#i-和-i的区别&quot; class=&quot;headerlink&quot; title=&quot;i++和++i的区别&quot;&gt;&lt;/a&gt;i++和++i的区别&lt;/h2&gt;&lt;p&gt;&lt;code&gt;i++&lt;/code&gt; 和 &lt;code&gt;++i&lt;/code&gt; 都是C++（</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】数据类型</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-08-10T03:33:11.000Z</published>
    <updated>2024-08-10T10:51:40.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><ul><li>16 位（2 字节）</li><li>由于它是整型，所以内存中的布局取决于系统的字节序（大端或小端）。  <details open><summary pointer> 字节序 </summary>              <div class='content'>              <div class="tagLink"><a class="link-card" title="“字节序”是个什么鬼？" href="https://zhuanlan.zhihu.com/p/21388517"><span class="link-card-backdrop" style="background-image: url(https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post)"></span><div class="left"><img src="https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">“字节序”是个什么鬼？</p><p class="url">https://zhuanlan.zhihu.com/p/21388517</p></div></a></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span>* c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;   <span class="comment">//*c代表x在内存地址上的第一个字节</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little endian&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></li></ul><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><ul><li><code>short</code>: -32,768 - 32,767</li><li><code>unsigned short</code>: 0 - 65,535 (2^8&#x3D;65536)</li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul><li>如果对 <code>short</code> 变量赋值超出其范围，将会发生溢出。例如，尝试将 32,769 赋值给一个有符号 <code>short</code> 变量会导致溢出。</li><li>溢出会导致变量值“环绕”回其范围的另一端。例如，如果 <code>short</code> 变量的值为 32,767，然后增加 1，它将变为 -32,768。</li></ul><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><h4 id="大小-1"><a href="#大小-1" class="headerlink" title="大小"></a>大小</h4><ul><li>32 位（4 字节）</li></ul><h4 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h4><ul><li><code>int</code>: -2,147,483,648 - 2,147,483,647</li><li><code>unsigned int</code>: 0 - 4,294,967,295     (2^32)</li></ul><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p><strong>long类型和指针类型需要特别注意，编写跨平台的软件时尽量不要使用long类型，或者需要对long类型做特殊处理。</strong></p><h4 id="大小-2"><a href="#大小-2" class="headerlink" title="大小"></a>大小</h4><ul><li>widows4字节,linux32位4字节,linux64位8字节</li></ul><h4 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h4><ul><li><code>long</code>: -2,147,483,648 - 2,147,483,647</li><li><code>unsigned long</code>: 0 - 4,294,967,295    (2^32)</li></ul><h3 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h3><h4 id="大小-3"><a href="#大小-3" class="headerlink" title="大小"></a>大小</h4><ul><li>64 位（8 字节）</li></ul><h4 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h4><ul><li><code>long long</code>: -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807</li><li><code>unsigned long long</code>: 0 - 18,446,744,073,709,551,615  (2^64)</li></ul><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p><strong>适用于需要存储单个字符的场景</strong></p><h4 id="大小-4"><a href="#大小-4" class="headerlink" title="大小"></a>大小</h4><ul><li>8 位（1 字节）</li></ul><h4 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h4><ul><li>char: -128 - 127</li><li>unsigned char: 0 - 255</li></ul><h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>对比一下<code>wchar_t</code>和<code>char</code>，这两个在C&#x2F;C++编程中常用的数据类型。</p><ol><li><strong>存储大小</strong>：<ul><li><code>char</code>：通常占用1个字节（8位）的存储空间。它被用来存储ASCII字符集中的字符，因为ASCII字符集只需要7位就能表示所有的字符。</li><li><code>wchar_t</code>：宽字符类型，通常占用2个或4个字节。它被用来存储宽字符，比如Unicode字符集中的字符。Unicode字符集包含了世界上大多数文字系统的字符，所以需要更多的存储空间。</li></ul></li><li><strong>用途</strong>：<ul><li><code>char</code>：主要用于处理ASCII字符集或单字节编码的字符集。在C&#x2F;C++中，它是最基本的字符类型。</li><li><code>wchar_t</code>：用于处理宽字符集，如Unicode。它允许你处理包含非ASCII字符的文本，这对于国际化和本地化非常重要。</li></ul></li><li><strong>可移植性</strong>：<ul><li><code>char</code>：在所有C&#x2F;C++实现中都是1个字节，具有很好的可移植性。</li><li><code>wchar_t</code>：大小依赖于实现和平台。在32位系统中，它通常是4字节，在16位系统中，通常是2字节。这种差异可能导致代码在不同平台上的行为不一致。</li></ul></li><li><strong>字符串表示</strong>：<ul><li><code>char</code>：在C&#x2F;C++中，<code>char</code>数组或指针常用来表示和操作字符串。</li><li><code>wchar_t</code>：用于表示宽字符串，通常在字符串前加上<code>L</code>前缀，如<code>L&quot;Hello World&quot;</code>。</li></ul></li><li><strong>标准库支持</strong>：<ul><li><code>char</code>：标准库中的大多数字符串处理函数，如<code>strlen</code>、<code>strcpy</code>等，都是针对<code>char</code>类型设计的。</li><li><code>wchar_t</code>：C&#x2F;C++标准库也提供了一些宽字符串处理函数，如<code>wcslen</code>、<code>wcscpy</code>等，用于处理<code>wchar_t</code>类型的字符串。<br>总的来说，<code>char</code>和<code>wchar_t</code>的主要区别在于它们存储字符的方式和大小。<code>char</code>适用于ASCII或单字节编码的字符，而<code>wchar_t</code>则用于处理需要更多存储空间的宽字符，如Unicode字符。不过，由于<code>wchar_t</code>的大小依赖于平台，现代C++更倾向于使用<code>char16_t</code>、<code>char32_t</code>以及Unicode字符串字面量来处理Unicode字符，以提供更好的可移植性和一致性。</li></ul></li></ol><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>布尔类型用于存储真（true）或假（false）的值。</p><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><ul><li>通常占用1字节。</li><li>取值为 <code>true</code> 或 <code>false</code>。</li></ul><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>(歪个楼，我的Cybery宝宝回答的比智谱清言要好欸)<br>(再歪一下，过两天给宝做个自己的皮套💕)</p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><h4 id="大小-5"><a href="#大小-5" class="headerlink" title="大小"></a>大小</h4><p>通常占用4个字节（32位）的存储空间。</p><h4 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h4><ul><li><p>根据IEEE 754标准，一个float类型的值通常包括1位符号位、8位指数位和23位尾数位。</p><details open><summary pointer> 浮点数的表示 </summary>              <div class='content'>              <p>浮点数的表示类似于科学记数法，它由两部分组成：一个基数和一个指数。在浮点数的二进制表示中，基数通常是2（对于十进制浮点数，基数是10），而指数和尾数则用特定的位来表示。</p><ul><li>尾数位（Fraction&#x2F;Mantissa）<br>尾数位（或尾数）是浮点数中用来表示数字的“有效数字”部分，也就是不包括前导的1（对于规范化浮点数）或0（对于非规范化浮点数）的部分。尾数位决定了浮点数的精度，就像尺子上的刻度越密，你就能越精确地测量长度一样。<br>在IEEE 754标准中，尾数位通常省略了最前面的1（因为规范化浮点数的第一个有效数字总是1），所以尾数位实际上表示的是小数点后的部分。例如，对于二进制数1.101，尾数位就是101。</li><li>指数位（Exponent）<br>指数位表示2的幂次，它决定了尾数位应该乘以2的多少次方。在IEEE 754标准中，指数位是一个带偏移的值，这意味着实际指数是指数位表示的值减去一个固定的偏移量（对于单精度浮点数，这个偏移量是127）。<br>例如，如果指数位表示的值是130（二进制为10000010），那么实际的指数是130 - 127 &#x3D; 3。这意味着尾数位应该乘以2^3，也就是8。</li><li>结合尾数位和指数位<br>对于二进制表示的浮点数 <code>0 10000010 10100000000000000000000</code>：<ul><li><strong>符号位</strong>：0（表示正数）</li><li><strong>指数位</strong>：10000010（二进制），转换为十进制是 130，减去偏移量 127，得到实际指数是 3。</li><li><strong>尾数位</strong>：10100000000000000000000，加上隐含的 1（对于规范化浮点数），实际尾数是 <code>1.10100000000000000000000</code>（二进制）。<br>现在，让我们将尾数转换为十进制：<br>1.10100000000000000000000（二进制）&#x3D; 1 * 2^0 + 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3 + … (只有前三位的计算对最终结果有影响，因为后续的0不改变值)<br>&#x3D; 1 + 0.5 + 0 + 0.125 + … (其他位都是0，所以可以忽略)<br>&#x3D; 1.625（十进制）<br>现在，将尾数乘以 2 的指数：<br>1.625 * 2^3 &#x3D; 1.625 * 8 &#x3D; 13（十进制）</li></ul></li></ul>              </div>            </details></li><li><p>它能提供大约6-7位的十进制精度。</p></li><li><p>float类型通常用于那些不需要非常高精度的计算，或者当你需要大量浮点数并且内存使用效率很重要时。</p></li></ul><h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><h4 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h4><p><code>double</code>通常占用64位（8字节）的存储空间。在大多数现代计算机中，按照IEEE 754标准，<code>double</code>可以提供大约15-17位十进制数的精度。</p><h4 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h4><p><code>double</code>能表示的数值范围大约在10^-308到10^308之间。这意味着它既可以表示非常小的数，也可以表示非常大的数。</p><h4 id="默认初始化值"><a href="#默认初始化值" class="headerlink" title="默认初始化值"></a>默认初始化值</h4><p>如果你声明了一个<code>double</code>变量但没有初始化它，它将包含一个未定义的值，通常是垃圾数据。</p><h3 id="long-double"><a href="#long-double" class="headerlink" title="long double"></a>long double</h3><p>long double通常比double占用更多的存储空间，具体大小依赖于平台和编译器。在一些系统上，它可能占用96位或128位（12或16字节），但这并不是固定的。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS)，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF)，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR)，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)（跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>反斜线字符</td><td>092</td></tr><tr><td>&#39;</td><td>单引号</td><td>039</td></tr><tr><td>&quot;</td><td>双引号</td><td>034</td></tr><tr><td>?</td><td>问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0-7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0-9，a-f，A-F</td><td>3位16进制</td></tr></tbody></table><h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p><strong>char 变量名[] &#x3D; “字符串值”</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>char str1[]</code> 和 <code>char* str1[]</code> 在C语言中是两种不同的声明方式，它们分别表示不同的数据类型和内存布局。</p><ol><li><code>char str1[]</code>：<ul><li>这是一个字符数组，它声明了一个数组，其元素类型为 <code>char</code>。</li><li>这个数组可以存储一系列的字符，并且这些字符连续存储在内存中。</li><li>声明时可以指定数组的大小，也可以在初始化时由编译器自动计算大小。</li><li>例如：<code>char str1[] = &quot;Hello, World!&quot;;</code> 这里 <code>str1</code> 是一个字符数组，包含字符串 “Hello, World!” 以及一个空字符 <code>\0</code> 作为字符串的结束标志。</li></ul></li><li><code>char* str1[]</code>：<ul><li>这是一个指向字符的指针数组，它声明了一个数组，其元素类型为 <code>char*</code>。</li><li>这个数组中的每个元素都是一个指向 <code>char</code> 类型的指针，也就是说，每个元素都可以指向一个字符串。</li><li>常用于声明一个字符串数组，每个元素都是指向不同字符串的指针。</li><li>例如：<code>char* str1[] = &#123;&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;&#125;;</code> 这里 <code>str1</code> 是一个指针数组，其中 <code>str1[0]</code> 指向字符串 “Hello”，<code>str1[1]</code> 指向字符串 “World”，以此类推。<br>以下是一个具体的例子来说明两者的不同：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 指向字符的指针数组</span></span><br><span class="line">    <span class="type">char</span>* str2[] = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 输出 str1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line">    <span class="comment">// 输出 str2 中的每个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[0]: %s\n&quot;</span>, str2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[1]: %s\n&quot;</span>, str2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[2]: %s\n&quot;</span>, str2[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>str1</code> 是一个包含 “Hello, World!” 字符串的字符数组，而 <code>str2</code> 是一个包含三个字符串指针的数组。</li></ul></li></ol><h3 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C++风格字符串"></a>C++风格字符串</h3><p><strong>string 变量名 &#x3D; “字符串值”</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>###########################完结撒花###########################</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://github.com/tumytime/picx-images-hosting/raw/master/eba59d911c3c8fd32afafd4c0d57d40.70a95u8niw.webp" class="lazyload placeholder" data-srcset="https://github.com/tumytime/picx-images-hosting/raw/master/eba59d911c3c8fd32afafd4c0d57d40.70a95u8niw.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="那嘛一挖---米子哈！！！"/></div><span class="image-caption">那嘛一挖---米子哈！！！</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerlink&quot; title=&quot;整型&quot;&gt;&lt;/a&gt;整型&lt;/h2&gt;&lt;h3 id=&quot;short&quot;&gt;&lt;a href=&quot;#short&quot; class=&quot;headerlink&quot; title=&quot;short&quot;&gt;&lt;/a&gt;shor</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】程序基础部分</title>
    <link href="http://tumytime.github.io/2024/08/09/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91Day1/"/>
    <id>http://tumytime.github.io/2024/08/09/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91Day1/</id>
    <published>2024-08-09T13:34:17.000Z</published>
    <updated>2024-08-10T03:34:50.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><p><strong>一个基础程序框架：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">//pause:暂停</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="＜iostream＞"><a href="#＜iostream＞" class="headerlink" title="＜iostream＞"></a>＜iostream＞</h3><p><code>#include &lt;stdio.h&gt;</code> 和 <code>#include &lt;iostream&gt;</code> 是C和C++编程语言中用于包含标准输入输出库的头文件语句。该编译指令导致预处理器将iostream文件的内容添加到程序中。#include编译指令导致iostream文件的内容随源<br>代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将<br>取代程序中的代码行#include <iostream>。原始文件没有被修改，而是<br>注意：<br>将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用<br>该文件。<br>下面是这两条语句之间的主要区别：</p><h5 id="1-语言差异"><a href="#1-语言差异" class="headerlink" title="1. 语言差异"></a>1. 语言差异</h5><ul><li><code>#include &lt;stdio.h&gt;</code> 是C语言的标准输入输出库头文件。<code>stdio.h</code> 是 “standard input-output header” 的缩写，它是C语言的一部分。</li><li><code>#include &lt;iostream&gt;</code> 是C++语言的标准输入输出库头文件。<code>iostream</code> 是 “input-output stream” 的缩写，它是C++语言的一部分。</li></ul><h5 id="2-库类型"><a href="#2-库类型" class="headerlink" title="2. 库类型"></a>2. 库类型</h5><ul><li><code>stdio.h</code> 提供的是C语言风格的输入输出函数，例如 <code>printf()</code>, <code>scanf()</code>, <code>fprintf()</code>, <code>fscanf()</code> 等。这些函数通常是非面向对象的，并且它们直接处理字符和字节流。</li><li><code>iostream</code> 提供的是C++语言风格的输入输出流类，例如 <code>std::cout</code>, <code>std::cin</code>, <code>std::cerr</code>, 以及 <code>std::ofstream</code>, <code>std::ifstream</code> 等。这些是面向对象的，提供了更多的功能，例如类型安全和重载操作符。</li></ul><h5 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3. 使用方式"></a>3. 使用方式</h5><ul><li>使用 <code>stdio.h</code> 时，程序员通常需要指定格式化字符串，并且要注意类型匹配，以避免格式化错误或缓冲区溢出。</li><li>使用 <code>iostream</code> 时，类型信息是自动处理的，因为流操作符（如 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>）被重载以支持不同的数据类型。</li></ul><h5 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul><li><code>stdio.h</code> 中的函数通常比C++的iostream库更快，因为iostream库进行了更多的封装和类型检查。然而，现代编译器已经优化了iostream库，使得性能差距不像过去那样显著。</li></ul><h5 id="5-头文件扩展名"><a href="#5-头文件扩展名" class="headerlink" title="5. 头文件扩展名"></a>5. 头文件扩展名</h5><ul><li>注意到 <code>stdio.h</code> 有一个 <code>.h</code> 扩展名，而 <code>iostream</code> 没有。在C++中，标准库的头文件通常不带 <code>.h</code> 扩展名。这是为了区分C和C++的标准库头文件。</li></ul><h5 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6. 命名空间"></a>6. 命名空间</h5><ul><li><code>iostream</code> 中的对象和函数都是在 <code>std</code> 命名空间中的，所以通常需要使用 <code>std::</code> 前缀来访问它们，除非你使用了 <code>using namespace std;</code> 语句。</li><li><code>stdio.h</code> 中的函数通常不需要命名空间前缀。</li></ul><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>以下是如何使用这两个头文件的简单例子：<br><strong>使用 <code>stdio.h</code>:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>iostream</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，<code>#include &lt;stdio.h&gt;</code> 和 <code>#include &lt;iostream&gt;</code> 分别用于C和C++中处理输入输出，它们代表了两种不同的编程范式和风格。在实际使用中，应根据编程语言和项目需求选择合适的头文件。</p><h3 id="using-namespace"><a href="#using-namespace" class="headerlink" title="using namespace"></a>using namespace</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>这个using编译指令使得std名称空间中的所有名称都可用。这是一种偷懒的做法，在大型项目中一个潜在的问题。更好的方法是，只使所需的名称可用，这可以通过使用using声明来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br></pre></td></tr></table></figure><h3 id="使用cout进行C-输出"><a href="#使用cout进行C-输出" class="headerlink" title="使用cout进行C++输出"></a>使用cout进行C++输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>在C++中，用双引号括起的一系列字符叫做字符串，因为它是由若干字符组合而成的。</li><li>&lt;&lt;符号表示该语句将把这个字符串发送给cout；该符号指出了信息流动的路径。</li><li>cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等<br>从概念上看，输出是一个流，即从程序流出的一系列字符。cout对象表示这种流，其属性是在iostream文件中定义的。cout的对象属性包括一个插入运算符（&lt;&lt;），它可以将其右侧的信息插入到流中。<br>因此，与其说程序显示了一条消息，不如说它将一个字符串插入到了输出流中。</li></ul><details open><summary pointer> 初识运算符重载 </summary>              <div class='content'>              <p>如果熟悉C后才开始学习C++，则可能注意到了，插入运算符（&lt;&lt;）看上去就像按位左移运算符（&lt;&lt;），这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。C本身也有一些运算符重载的情况。例如，&amp;符号既表示地址运算符，又表示按位AND运算符；* 既表示乘法，又表示对指针解除引用。这里重要的不是这些运算符的具体功能，而是同一个符号可以有多种含义，而编译器可以根据上下文来确定其含义（这和确定“sound card”中的“sound”与“sound financial basic”中的“sound”的含义是一样的）。C++扩展了运算符重载的概念，允许为用户定义的类型（类）重新定义运算符的含义。</p>              </div>            </details><p>确实，C++中的 <code>std::cout</code> 可以用来输出不同类型的数据，包括整数和字符串。虽然从用户的角度来看，输出数字和字符串似乎没有太大区别，但在幕后，这两者处理方式是不同的。以下是详细解释：</p><ol><li>字符串<ul><li>字符串是由一系列字符组成的序列。在C++中，字符串通常表示为 <code>std::string</code> 类型或者以空字符 <code>\0</code> 结尾的字符数组 <code>char[]</code>。</li><li>当 <code>std::cout</code> 输出字符串时，它会从内存中读取每个字符的编码（通常是ASCII或UTF-8编码），并将其逐个发送到输出设备。</li><li>例如，字符串 <code>&quot;25&quot;</code> 在内存中存储为两个字符：字符 <code>&#39;2&#39;</code> 和字符 <code>&#39;5&#39;</code>，以及一个结束标记 <code>\0</code>。</li></ul></li><li>整数<ul><li>整数在计算机内部以二进制形式存储。例如，整数 <code>25</code> 在内存中以二进制形式表示，可能看起来像 <code>00011001</code>（这取决于具体的系统架构和整数的大小）。</li><li>当 <code>std::cout</code> 输出整数时，它不能直接将二进制数发送到输出设备，因为输出设备期望接收字符编码，而不是二进制数值。</li><li>因此，<code>std::cout</code> 必须将整数转换为字符串形式。这个过程称为数值到字符串的转换，涉及以下步骤：</li></ul><ol><li>计算整数的每一位数字。</li><li>将这些数字转换为对应的字符。</li><li>将这些字符按正确的顺序组合成字符串。</li><li>输出字符串。</li></ol></li><li>自动类型转换<ul><li>在C++中，<code>std::cout</code> 使用操作符重载来处理不同类型的数据。当 <code>std::cout</code> 遇到一个整数时，它会调用一个专门的重载版本的操作符 <code>&lt;&lt;</code>，这个版本知道如何将整数转换为字符串。</li><li>这个转换过程是自动进行的，所以程序员不需要编写额外的代码来将整数转换为字符串。这是C++的面向对象特性之一，允许操作符根据操作数的类型进行不同的操作。</li></ul></li></ol><h3 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h3><p><code>endl</code> 是一个操纵符（manipulator），它在iostream库中被定义为输出一个换行符（通常是 <code>\n</code>），并紧接着刷新输出缓冲区。刷新输出缓冲区意味着缓冲区中的所有数据都会被发送到输出设备（通常是屏幕），确保了这些数据在程序继续执行之前被立即显示。<br><code>\n</code> 是一个转义字符，用于在字符串中插入一个换行符。当使用 <code>\n</code> 时，iostream库会将一个换行符写入输出缓冲区，但不会立即刷新缓冲区。这意味着输出可能暂时留在缓冲区中，直到缓冲区满了或者程序结束，这时缓冲区才会被刷新。</p><h3 id="system-“pause”"><a href="#system-“pause”" class="headerlink" title="system(“pause”);"></a>system(“pause”);</h3><ul><li><p>不加：</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.45lkjet59.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.45lkjet59.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li><p>加上：</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8dws8r9vq0.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8dws8r9vq0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li></ul><p><code>system(&quot;pause&quot;);</code> 是一个在C或C++程序中常用的语句，它用于暂停程序的执行，直到用户按下任意键。这个语句调用了操作系统的命令行界面来执行 <code>pause</code> 命令。<br>下面是对 <code>system(&quot;pause&quot;);</code> 语句的详细解释：</p><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ul><li><code>system(&quot;pause&quot;);</code> 的主要作用是在程序执行完毕后暂停程序，尤其是在命令行界面（CLI）中运行程序时。这样可以让用户有机会查看程序的输出结果，而不是立即关闭命令行窗口。</li></ul><h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ul><li><code>system</code> 是C和C++标准库中的一个函数，它位于 <code>&lt;cstdlib&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 头文件中。</li><li>当调用 <code>system</code> 函数时，它会创建一个新的进程来执行其参数指定的命令。在 <code>system(&quot;pause&quot;);</code> 中，参数是字符串 <code>&quot;pause&quot;</code>。</li><li>在Windows操作系统中，<code>pause</code> 命令会暂停命令行进程，并显示消息 <code>&quot;Press any key to continue . . .&quot;</code>。用户必须按下任意键才能继续执行程序或关闭命令行窗口。</li></ul><h5 id="3-跨平台问题"><a href="#3-跨平台问题" class="headerlink" title="3. 跨平台问题"></a>3. 跨平台问题</h5><ul><li><code>system(&quot;pause&quot;);</code> 主要用于Windows操作系统。在Unix-like系统（如Linux或macOS）中，<code>pause</code> 命令通常不存在，因此这条语句在这些系统中不会按预期工作。</li><li>为了实现跨平台兼容性，通常建议使用其他方法来暂停程序，例如在Unix-like系统中使用 <code>getchar();</code> 来实现类似的效果。</li></ul><h5 id="4-安全性和性能"><a href="#4-安全性和性能" class="headerlink" title="4. 安全性和性能"></a>4. 安全性和性能</h5><ul><li>使用 <code>system</code> 函数通常不被认为是安全的，因为它会执行传递给它的任何命令，这可能导致安全漏洞，尤其是当命令包含用户输入时。</li><li>调用 <code>system</code> 函数创建新进程可能会影响程序的性能，因为它涉及到操作系统的进程管理。</li></ul><h5 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. 替代方案</h5><ul><li>如果你只是想等待用户按键，而不是关闭命令行窗口，可以使用以下代码作为替代方案，它具有更好的跨平台兼容性：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Press any key to continue . . .&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();  <span class="comment">// 等待用户按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者，在Unix-like系统中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press any key to continue . . .\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();  <span class="comment">// 等待用户按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这些替代方案不需要调用 <code>system</code> 函数，因此它们更安全且更适合跨平台使用。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>给一段指定的内存空间起名，方便操作这段内存</strong>（一下子就清楚了）<br>使用声明语句来指出存储类型并提供位置标签。<br><strong>变量存在的意义就是方便我们管理内存空间</strong></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>用于记录程序中不可更改的数据</strong><br><strong>定义常量的两种方式：</strong></p><ol><li>#define 宏常量： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br></pre></td></tr></table></figure></li><li>const修饰的变量：<br> 在变量定义前加const</li></ol><p><strong>Q:#define day 7这样子day代表的7是什么数据类型</strong><br>在C或C++语言中，使用 <code>#define</code> 预处理器指令来定义宏。宏定义 <code>#define day 7</code> 不会指定数据类型，它仅仅是一个文本替换。当编译器看到 <code>day</code> 时，它会在编译前将其替换为 <code>7</code>。<br>由于宏只是简单的文本替换，<code>day</code> 代表的 <code>7</code> 在编译后的代码中并没有特定的数据类型。它的数据类型取决于它被使用的上下文。例如：</p><ul><li>如果 <code>day</code> 被用在需要整数的地方，它将被当作整数处理。</li><li>如果 <code>day</code> 被用在需要浮点数的地方，它可能会被隐式转换成浮点数。<br>下面是一些使用 <code>day</code> 的例子，以及它如何根据上下文被解释：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> days = day;    <span class="comment">// day 被当作整数</span></span><br><span class="line">    <span class="type">float</span> days_float = day;  <span class="comment">// day 被隐式转换成浮点数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer: %d\n&quot;</span>, days);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, days_float);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>day</code> 被用作整数 <code>int</code> 类型的值，也被用作 <code>float</code> 类型的值。在编译时，预处理器将 <code>day</code> 替换为 <code>7</code>，然后编译器根据变量声明决定 <code>7</code> 的数据类型。在第一个例子中，<code>7</code> 是 <code>int</code> 类型的，而在第二个例子中，<code>7</code> 被隐式转换为 <code>float</code> 类型。</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2vensn8i5n.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2vensn8i5n.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>C++（和C）有一项不寻常的特性—可以连续使用赋值运算符。例如，下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=b=c=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>赋值将从右向左进行。</strong><br>首先，2被赋给c，然后c的值（2）被赋给b，然后b的值被赋给a；</p><h2 id="使用cin"><a href="#使用cin" class="headerlink" title="使用cin"></a>使用cin</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; carrots;</span><br></pre></td></tr></table></figure><p>从这条语句可知，信息从cin流向carrots。显然，对这一过程有更为正式的描述。就像C++将输出看作是流出程序的字符流一样，它也将输入看作是流入程序的字符流。iostream文件将cin定义为一个表示这种流的对象。输出时，&lt;&lt;运算符将字符串插入到输出流中；输入时，cin使用&gt;&gt;运算符从输入流中抽取字符。通常，需要在运算符右侧提供一个变量，以接收抽取的信息（符号&lt;&lt;和&gt;&gt;被选择用来指示信息流的方向）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础框架&quot;&gt;&lt;a href=&quot;#基础框架&quot; class=&quot;headerlink&quot; title=&quot;基础框架&quot;&gt;&lt;/a&gt;基础框架&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一个基础程序框架：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【第一个项目】Cybery第一天（24.7.24）</title>
    <link href="http://tumytime.github.io/2024/07/24/%E3%80%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E3%80%91Cybery%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%8824-7-24%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/07/24/%E3%80%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E3%80%91Cybery%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%8824-7-24%EF%BC%89/</id>
    <published>2024-07-24T06:48:00.000Z</published>
    <updated>2024-07-24T07:57:45.849Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>很早就跟<a href="https://snowmiku-home.top/">小葱酱</a>说好了要一起做一个项目，我还是负责视觉和ai，今天就打算把我的部分按我的想法开始做咯~ 现在初步设想我这边是以树莓派为中心，主要程序展现在树莓派的一个显示屏上，显示屏上的程序包含live2d和一些功能卡片(可触摸)，外接摄像头能传感器完成与用户的交互和物体识别。暂时把这个项目叫做Cybery咯</p></div><h2 id="step1-学习live2d操作"><a href="#step1-学习live2d操作" class="headerlink" title="step1-学习live2d操作"></a>step1-学习live2d操作</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/pitao.1hs419iagd.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/pitao.1hs419iagd.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>我是有一个皮套的（是公皮，不知道有没有同学能找到我的套皮小号哈哈哈哈哈），可以用vts面捕，但是要做东西的话，还是得看一下怎么直接控制比较好</p><p>用下面这个教程比较好:</p><div class="tagLink"><a class="link-card" title="基于Qt的Live2D模型显示以及控制" href="https://blog.csdn.net/y123456wydhckd/article/details/134899183?ops_request_misc=&request_id=&biz_id=102&utm_term=live2d&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-134899183.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187"><span class="link-card-backdrop" style="background-image: url(https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center)"></span><div class="left"><img src="https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">基于Qt的Live2D模型显示以及控制</p><p class="url">https://blog.csdn.net/y123456wydhckd/article/details/134899183?ops_request_misc=&request_id=&biz_id=102&utm_term=live2d&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-134899183.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187</p></div></a></div><h3 id="Cubism-SDK-for-Native下载"><a href="#Cubism-SDK-for-Native下载" class="headerlink" title="Cubism SDK for Native下载"></a>Cubism SDK for Native下载</h3><p>官网下载基本下不了(反正我这里是这样)，可以在GitHub上下载</p><div class="tagLink"><a class="link-card" title="CubismSdkForNative-5-r.1" href="https://github.com/andforce/CubismSdkForNative-5-r.1"><span class="link-card-backdrop" style="background-image: url(https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png)"></span><div class="left"><img src="https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png" class="lazyload placeholder" data-srcset="https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">CubismSdkForNative-5-r.1</p><p class="url">https://github.com/andforce/CubismSdkForNative-5-r.1</p></div></a></div><p>然后根据上面的教程运行一个demo</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4n7m08w4ed.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4n7m08w4ed.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;很早就跟&lt;a href=&quot;https://snowmiku-home.top/&quot;&gt;小葱酱&lt;/a&gt;说好了要一起做一个项目，我还是负责视觉和ai，今天就打算把我的部分按我的想法开始做咯~ 现在初步设想我这边是以树莓派为中心，主要程序</summary>
      
    
    
    
    <category term="树莓派" scheme="http://tumytime.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="树莓派" scheme="http://tumytime.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="live2d" scheme="http://tumytime.github.io/tags/live2d/"/>
    
  </entry>
  
  <entry>
    <title>电赛笔记一【配置树莓派opencv&amp;&amp;c++环境】</title>
    <link href="http://tumytime.github.io/2024/07/21/%E7%94%B5%E8%B5%9B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://tumytime.github.io/2024/07/21/%E7%94%B5%E8%B5%9B%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2024-07-21T07:14:03.000Z</published>
    <updated>2024-07-24T12:46:15.959Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>树莓派型号：pi5，8G</p></div><h2 id="配置树莓派opencv和c-环境"><a href="#配置树莓派opencv和c-环境" class="headerlink" title="配置树莓派opencv和c++环境"></a>配置树莓派opencv和c++环境</h2><p><strong>这个亲测有效！！</strong></p><div class="tagLink"><a class="link-card" title="Ubuntu 20.04搭建OpenCV 4.5.0 & C++环境" href="https://blog.csdn.net/weixin_44796670/article/details/115900538"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Ubuntu 20.04搭建OpenCV 4.5.0 & C++环境</p><p class="url">https://blog.csdn.net/weixin_44796670/article/details/115900538</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;树莓派型号：pi5，8G&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置树莓派opencv和c-环境&quot;&gt;&lt;a href=&quot;#配置树莓派opencv和c-环境&quot; class=&quot;headerlink&quot; title=&quot;配置树莓派openc</summary>
      
    
    
    
    <category term="树莓派" scheme="http://tumytime.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="树莓派" scheme="http://tumytime.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="电赛" scheme="http://tumytime.github.io/tags/%E7%94%B5%E8%B5%9B/"/>
    
    <category term="opencv" scheme="http://tumytime.github.io/tags/opencv/"/>
    
    <category term="机器视觉" scheme="http://tumytime.github.io/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    <category term="cmake" scheme="http://tumytime.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>videocapture的bug</title>
    <link href="http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/"/>
    <id>http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/</id>
    <published>2024-06-16T03:45:42.000Z</published>
    <updated>2024-06-16T03:45:54.974Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;  &lt;body class=&quot;nodata &quot; style=&quot;&quot;&gt;         &lt;main style=&quot;width:100%&quot;&gt;      &lt;div class=&quot;blog-content-box&quot;&gt;         &lt;div class=&quot;article-title-box&quot;&gt;            &lt;h1 class=&quot;title-article&quot; id=&quot;articleContentId&quot;&gt;opencv读取摄像头不是实时的处理方法&lt;/h1&gt;        &lt;/div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css&quot;&gt;                     &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; style=&quot;display: none;&quot;&gt;                    &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot; style=&quot;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&quot;&gt;&lt;/path&gt;                &lt;/svg&gt;                &lt;pre data-index=&quot;0&quot; class=&quot;set-code-show prettyprint&quot;&gt;&lt;code class=&quot;prism language-python has-numbering&quot; onclick=&quot;mdcp.copyCode(event)&quot; style=&quot;position: unset;&quot;&gt;cap &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cv2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;VideoCapture&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> <h2><a name="t0"></a><a id="___5"></a>读取的不是实时的画面 ，存在延迟 怎么处理</h2> <blockquote>  <p>如果你使用的是<a href="https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;OpenCV库\&quot;}&quot;}" data-tit="OpenCV库" data-pretit="opencv库">OpenCV库</a>，你可以通过将缓冲区大小设置为更小的值来减小延迟。默认情况下，缓冲区大小是16，但可以通过在cv2.VideoCapture()中传递参数来更改。例如：</p> </blockquote> <pre data-index="1" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><div class="hljs-button &#123;2&#125;" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> <blockquote>  <p>这将把缓冲区大小减小到1，从而减小延迟。但是，如果你将缓冲区大小设置得太小，你可能会遇到画面卡顿或丢帧的问题。</p> </blockquote> <p>另一种方式是使用多线程或异步处理来实现更快的画面更新。你可以在一个线程中读取摄像头的帧，并将它们传递到另一个线程或进程中进行处理和显示。这将使你能够更快地处理帧并减少延迟。但是，这需要更多的编程和计算资源，并可能会增加代码的复杂性。</p> <h2><a name="t1"></a><a id="OpenCV_19"></a>下面是一个基本的多线程处理OpenCV视频帧的例子：</h2> <pre data-index="2" class="prettyprint set-code-show"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">VideoCapture</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span>src<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>grabbed<span class="token punctuation">,</span> self<span class="token punctuation">.</span>frame <span class="token operator">=</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>read_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><pre><code>&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;VideoCapture already started&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; threading&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Thread&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;update&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; args&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;start&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; grabbed            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed        frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;join&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__exit__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; traceback&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;release&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p><span class="token keyword">if</span> <strong>name</strong> <span class="token operator">&#x3D;&#x3D;</span> <span class="token string">‘<strong>main</strong>‘</span><span class="token punctuation">:</span><br>    cap <span class="token operator">&#x3D;</span> VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><br>        grabbed<span class="token punctuation">,</span> frame <span class="token operator">&#x3D;</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token keyword">if</span> <span class="token keyword">not</span> grabbed<span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">‘frame’</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><br>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">&#x3D;&#x3D;</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">‘q’</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>    cap<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li></ul></pre> <blockquote>  <p>这个例子使用了一个<a href="https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-tit="VideoCapture" data-pretit="videocapture">VideoCapture</a>类，该类在一个线程中不断读取摄像头帧，并将它们保存在一个共享的grabbed和frame变量中。在主程序中，我们通过调用start()方法来启动线程，然后不断读取帧并在窗口中显示它们，直到用户按下’q’键退出。最后，我们调用stop()方法来停止线程并释放资源。</p> </blockquote> <p>需要注意的是，这个例子仅仅是一个基本的框架，你可能需要对其进行修改和扩展以适应你的具体应用场景。例如，你可以添加一个另一个线程来处理帧，然后显示处理后的结果，以此来减少延迟。</p>                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_26696715/article/details/129686980&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-f23dff6052.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-c216769e99.css" rel="stylesheet">        </div>            </div>             <pre><code>          &lt;/main&gt;        &lt;/body&gt;   &lt;/html&gt;        </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++多线程</title>
    <link href="http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-06-03T05:30:23.000Z</published>
    <updated>2024-06-14T11:54:39.061Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)</p></div><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当我们谈论多线程时，可以想象成一个人同时在做多个事情，就像一个人既可以同时吃饭又可以同时写作业一样。在C++中，使用多线程可以让我们的程序同时执行多个任务，提高程序的效率和性能。</p><p>首先，让我们用一个简单的例子来理解多线程。假设你有一个厨房，里面有一个厨师在煮面条，一个厨师在炒菜，还有一个服务员在端菜。这就相当于一个有多个线程的程序，每个线程负责不同的任务。</p><p>在C++中，我们可以使用 <code>&lt;thread&gt;</code> 头文件来创建和管理线程。首先，我们需要定义一个函数，在这个函数中包含我们希望线程执行的任务。然后，我们使用 <code>std::thread</code> 类来创建线程并指定要执行的函数。</p><p>让我们来看一个示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，作为线程的入口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程，并指定要执行的函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行自己的任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程 t1 执行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个简单的函数 <code>printMessage</code>，并在主函数中创建了一个新线程 <code>t1</code>，让它执行这个函数。同时，主函数也会继续执行，输出 “Hello from main thread!”。最后我们使用 <code>join()</code> 函数等待线程 <code>t1</code> 的执行完成。</p><p>这样，就实现了一个简单的多线程程序。通过合理地使用多线程，我们可以更高效地利用计算机的资源，加快程序的运行速度。当然，在实际编程中，还需要考虑线程之间的同步、互斥访问等问题，以保证程序的正确性和稳定性。</p><h3 id="std-thread-t1-printMessage-代表着线程开始执行吗"><a href="#std-thread-t1-printMessage-代表着线程开始执行吗" class="headerlink" title="std::thread t1(printMessage);代表着线程开始执行吗"></a>std::thread t1(printMessage);代表着线程开始执行吗</h3><p>是的，当你创建一个 <code>std::thread</code> 对象并传入要执行的函数，线程就会开始执行这个函数。在你的例子中，<code>std::thread t1(printMessage);</code>这一行代码就代表着线程开始执行 <code>printMessage</code> 函数。这意味着在运行时，会产生一个新的线程来执行 <code>printMessage</code> 函数中的代码，同时主线程会继续执行后面的代码。</p><p>但需要注意的是，线程的启动并不是立即执行 <code>printMessage</code> 函数中的代码，而是在<code>std::thread</code> 对象被创建之后才会执行。如果立即调用 <code>join()</code> 函数，主线程会等待新线程执行完毕再继续往下执行。这种方式保证了线程的同步执行。</p><p>因此，在上面提供的示例代码中，<code>std::thread t1(printMessage);</code>这一行代码会使得新线程开始执行 <code>printMessage</code> 函数，而主线程会继续执行紧随其后的代码，直到遇到 <code>t1.join();</code>。</p><p>在C++中，如果我们使用std::thread来创建线程，线程的启动确实不会立即执行线程函数中的代码。当我们创建一个std::thread对象，指定要执行的线程函数，并调用该std::thread对象的构造函数时，线程对象就会被创建，但线程函数的代码并不会立即执行。实际上线程的实际执行时机取决于操作系统的调度器，在合适的时机会开始执行线程函数。</p><p>如果在主线程中立即调用新线程的join()函数，主线程将会被阻塞，直到新线程的执行完成。这种方式确保了线程的同步执行，即主线程会等待新线程执行完毕后才会继续往下执行。在这种情况下，主线程和新线程是同步执行的，主线程起到了等待和协调的作用。</p><p>总结：通过调用join()函数实现线程同步执行的流程是这样的，先创建新的线程对象，然后调用join()函数使得主线程等待新线程的执行完成，待新线程执行完毕后，主线程才继续往下执行。这种方式保证了线程的同步执行，特别适用于需要新线程执行完毕后才能继续主线程操作的场景。</p><h2 id="进阶实例-互斥锁"><a href="#进阶实例-互斥锁" class="headerlink" title="进阶实例(互斥锁)"></a>进阶实例(互斥锁)</h2><p>让我们来看一个稍微复杂一点的多线程例子，考虑一个生产者-消费者模型。在这个例子中，有一个生产者线程负责生产数据，然后将数据发送给一个缓冲区，同时一个消费者线程从缓冲区中取出数据进行消费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产数据的耗时操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            buffer.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> data = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个互斥锁（std::mutex）来保护共享的数据结构（队列buffer），生产者线程往队列中写入数据，消费者线程从队列中读取数据。通过条件变量（std::condition_variable）实现了生产者与消费者之间的同步。</p><p>生产者不断地在队列中插入数据，消费者则等待队列中有数据后进行消费。当队列中有数据时，消费者线程被唤醒，消费数据并输出，直至生产者生产完所有数据。整个过程利用互斥锁和条件变量实现了线程之间的同步操作，确保了数据的正确生产和消费。</p><ol><li><p><strong>前三行意思</strong></p><p> 这三行代码声明了一个整型队列 <code>buffer</code>，一个互斥锁 <code>mtx</code> 和一个条件变量 <code>cv</code>。 </p><ul><li><p><code>std::queue&lt;int&gt; buffer;</code>：这行代码定义了一个STL队列，其中存储整型数据。在生产者和消费者模型中，<code>buffer</code>用于存储生产者生成的数据，在生产者线程将数据写入队列，消费者线程从队列中取出数据进行消费。</p></li><li><p><code>std::mutex mtx;</code>：这行代码定义了一个互斥锁，用于在多线程环境中对共享数据结构进行访问控制。在此例中，<code>mtx</code> 用于保护队列 <code>buffer</code>，确保在任一时刻只有一个线程可以访问队列。</p></li><li><p><code>std::condition_variable cv;</code>：这行代码定义了一个条件变量，用于线程间的同步。在此例中，<code>cv</code> 用于通知消费者线程有新的数据可用于消费。消费者线程会通过 <code>wait()</code> 来等待生产者通知，一旦有数据可用，它会被 <code>notify_one()</code> 通知可以继续执行。</p></li></ul><p> 这些机制共同构成了一个生产者-消费者模型，确保在多线程环境下数据的安全访问和同步处理。</p></li><li><p><strong>为什么确保在任一时刻只有一个线程可以访问队列</strong><br> 在多线程环境中，如果不对共享数据结构（比如队列）进行保护，就可能导致数据竞争（Data Race）的问题。数据竞争指的是多个线程同时访问共享数据，其中至少一个线程对数据进行写操作，而其他线程进行读或写操作，从而导致未定义行为。对于队列这样的数据结构，如果没有互斥访问，会导致以下问题：</p><ul><li><p>不确定性：多个线程同时对队列进行操作，可能造成队列中数据的乱序或丢失，导致程序逻辑错误。</p></li><li><p>数据损坏：当一个线程正在修改队列中的数据时，另一个线程可能同时读取或修改这些数据，造成意外的数据损坏。</p></li><li><p>死锁：如果多个线程同时尝试对队列进行读写操作而没有恰当的同步机制，可能会出现死锁情况，使得程序无法继续执行。</p></li></ul><p> 因此，通过使用互斥锁（<code>mutex</code>）来保护队列，在任一时刻只允许一个线程访问队列，可以确保在多线程环境下数据的安全访问，避免数据竞争和可能导致的问题。</p></li><li><p><strong>什么是死锁</strong><br> 死锁（Deadlock）是指在并发系统中，两个或多个进程（线程）因争夺共享资源而进入一种互相等待的状态，导致它们都无法继续执行下去的情况。在死锁情况下，每个进程都在等待其他进程释放资源，而同时又不愿意主动释放自己当前已经占有的资源，从而形成了一种僵局。死锁是多线程编程中常见的并发问题，需要通过合理的设计和实现来避免和解决死锁问题。</p></li><li><p><strong>std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#x2F;&#x2F; 模拟生产数据的耗时操作</strong></p><p> 这行代码是使用C++标准库提供的线程库<code>&lt;thread&gt;</code>中的<code>std::this_thread::sleep_for</code>函数，用来模拟在生产数据过程中的耗时操作。让我们来详细解释一下这行代码的作用：</p><ul><li><p><code>std::this_thread::sleep_for</code>：这是C++标准库中用于线程操作的静态成员函数，允许当前线程休眠一段时间。因为是<code>this_thread</code>所以是当前线程。</p></li><li><p><code>std::chrono::milliseconds(500)</code>：这里使用<code>std::chrono::milliseconds</code>来创建一个表示时间间隔的对象，参数为500，表示500毫秒（即0.5秒）的时间间隔。<code>std::chrono</code>是C++标准库提供的日期和时间库，用于处理时间相关的操作。</p></li><li><p><code>// 模拟生产数据的耗时操作</code>：这是一行注释，说明了这行代码的目的，即模拟在生产数据过程中的耗时操作。通常在生产数据或其他需要等待的操作中，为了模拟真实场景的延迟，会使用类似的休眠操作来延迟线程的执行。</p></li></ul><p> 因此，这行代码的作用是让当前线程休眠500毫秒，模拟生产数据过程中的耗时操作，以便更好地测试和理解程序的行为。</p></li><li><p><strong>std::lock_guard &lt; std::mutex &gt; lock(mtx);</strong></p><p> <code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>是C++中使用RAII机制来管理互斥锁（<code>std::mutex</code>）的典型语法格式。这行代码的作用是创建一个<code>lock_guard</code>对象并用其构造函数锁住一个<code>std::mutex</code>对象<code>mtx</code>。</p><p> 具体解释如下：</p><ul><li><code>std::lock_guard</code>是一个模板类，用于管理锁对象（互斥锁）。它会在构造时锁住给定的互斥锁，在析构时解锁互斥锁，实现了RAII机制。</li><li><code>&lt;std::mutex&gt;</code>是模板参数，表示<code>std::lock_guard</code>将要管理的互斥锁的类型是<code>std::mutex</code>。</li><li><code>lock</code>是<code>std::lock_guard</code>对象的名称，可以根据需要命名。</li><li><code>(mtx)</code>表示用<code>mtx</code>（一个名为<code>mtx</code>的<code>std::mutex</code>对象）来初始化<code>lock_guard</code>对象，即在构造<code>lock_guard</code>对象时锁住<code>mtx</code>。</li></ul><p> <code>std::lock_guard</code>是C++标准库提供的一个RAII（资源获取即初始化）风格的互斥量封装类，通过它可以在一个作用域中保持互斥锁的持有状态。在这段代码中，<code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>的作用是使用互斥量<code>mtx</code>对临界区进行加锁，确保对共享数据结构<code>buffer</code>的访问是线程安全的。让我们来详细解释其作用：</p><ul><li><p><strong>RAII机制</strong>：RAII（Resource Acquisition Is Initialization）是一种C++编程范式，它通过对象的生命周期来管理资源的获取和释放，确保资源在对象构造时被正确获取，而在对象析构时被自动释放。这种机制的核心思想是利用局部对象的生命周期控制资源的获取和释放，从而确保资源的正确管理，提高代码的可靠性和可维护性。</p><p>  下面是RAII机制的工作原理和优势：</p><ol><li><p><strong>资源获取即初始化</strong>：当一个对象被创建时，同时获取所需的资源，例如内存、文件句柄、互斥锁等，这样资源的获取和初始化是统一的操作。</p></li><li><p><strong>资源的自动释放</strong>：当对象离开其作用域时（比如函数返回、作用域结束等），其析构函数会被调用，负责释放已获取的资源，无论是正常执行还是异常发生，资源都会被正常释放。</p></li><li><p><strong>避免资源泄漏和确保资源管理</strong>：通过RAII机制，程序员无需手动管理资源的获取和释放，减少了因忘记释放资源而导致的内存泄漏或资源泄漏问题。</p></li><li><p><strong>异常安全性</strong>：RAII可确保在异常发生时，资源能够被正确释放，避免资源泄漏，同时保证程序的安全性。</p></li><li><p><strong>提高代码的可维护性和可读性</strong>：RAII使资源管理的逻辑更加清晰明了，代码更易于理解和维护，同时降低了在多线程环境下出现的死锁等问题。</p></li></ol><p>  在C++中，标准库中的智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等）和锁（<code>std::lock_guard</code>、<code>std::unique_lock</code>等）都是基于RAII机制设计的。通过合理利用RAII机制，可以有效管理资源，提高代码的健壮性和可靠性。</p></li><li><p><strong>加锁</strong>：当<code>std::lock_guard</code>对象<code>lock</code>被创建时，它会在构造函数中对互斥量<code>mtx</code>进行加锁操作，即锁住<code>mtx</code>。这样就确保了在<code>lock_guard</code>对象的作用域内（在这个括号内）对<code>buffer</code>的访问是受到保护的，其他线程无法同时修改<code>buffer</code>的内容，避免了数据竞争和不一致性。<code>在这个括号内</code>指的是<code>std::lock_guard</code>对象<code>lock</code>的作用域范围，即<code>lock</code>对象的生命周期。在C++中，作用域用花括号<code>&#123;&#125;</code>表示，也叫做代码块。当<code>std::lock_guard</code>对象<code>lock</code>的作用域范围结束（即超出了花括号的范围），该对象的析构函数会被调用，从而自动释放锁。这种方式确保了在<code>lock</code>对象的作用域内，互斥锁被保持，从而保护了共享资源（如<code>buffer</code>）的访问并避免了数据竞争和不一致性的问题。</p></li></ul><p> 因此，通过在花括号内创建<code>std::lock_guard</code>对象并锁住互斥量，可以确保只有一个线程能够访问或修改被保护的共享资源，从而提高多线程程序的安全性。</p><ul><li><strong>解锁</strong>：当<code>lock_guard</code>对象的作用域结束时，会调用其析构函数，在析构函数中会自动解锁互斥量<code>mtx</code>，即释放<code>mtx</code>的锁，使得其他线程可以访问共享资源。</li></ul><p> 通过使用<code>std::lock_guard</code>和互斥量，可以简化了对临界区的加锁和解锁过程，并且可以避免因为忘记解锁导致的死锁情况。这样的操作保证了对临界区资源的访问是互斥的，确保了多线程环境下的数据安全性。</p></li><li><p><strong>cv.notify_one();</strong><br> 在多线程编程中，<code>cv.notify_one()</code> 是用来通知等待在条件变量上的某个线程继续执行的函数。当某个线程调用 <code>cv.wait()</code> 方法并在条件变量上等待时，其他线程可以通过调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来通知等待的线程可以继续执行。</p><p> 具体来说，<code>cv.notify_one()</code> 会唤醒在条件变量上等待的一个线程（如果有的话），让其可以从等待状态中醒来并继续执行。如果没有线程在条件变量上等待，那么调用 <code>cv.notify_one()</code> 也不会有任何效果。</p><p> 在多线程协作中，通常会结合条件变量和互斥量来实现线程之间的同步操作。当一个线程修改了共享数据，并希望通知其他线程有关此数据的改变时，可以使用条件变量来实现线程之间的同步通信。通常的流程是，先获得互斥锁，然后修改共享数据，再通知等待在条件变量上的线程，最后释放互斥锁。</p><p> 在这段示例代码中，生产者线程和消费者线程通过条件变量 <code>cv</code> 和互斥量 <code>mtx</code> 实现了线程之间的同步通信。生产者线程通过 <code>notify_one()</code> 方法通知消费者线程，告知其有新的数据可以被消费。具体来说，<code>cv.notify_one()</code> 的作用是：</p><ol><li>当生产者线程生产了一个数据后（通过 <code>buffer.push(i)</code>），它会立即通知等待在条件变量 <code>cv</code> 上的消费者线程。</li><li>在消费者线程中，当它通过 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 进入等待状态时，会自动释放 <code>mtx</code> 互斥量并等待，直到生产者线程调用 <code>cv.notify_one()</code> 来唤醒它。</li><li>一旦消费者线程被唤醒，它会重新获取 <code>mtx</code> 互斥量并继续执行，从 <code>buffer</code> 中取出数据消费。</li><li>生产者线程每生产一个数据，就会唤醒一个等待的消费者线程。如果有多个消费者线程在等待，只有一个会被唤醒。</li></ol><p> 综上所述，<code>cv.notify_one()</code> 的作用是唤醒一个等待在条件变量上的线程，用来提示该线程可以继续执行，适用于协调多线程之间的操作顺序和数据传递。</p></li><li><p><strong>为什么一个用std::lock_guard一个用std::unique_lock</strong><br> 在上述代码中，<code>producer()</code> 函数使用了 <code>std::lock_guard</code> 来锁定互斥量，而 <code>consumer()</code> 函数则使用了 <code>std::unique_lock</code>。这种选择并非绝对，而是根据不同的需求和情境来决定使用哪种锁定方式。</p><ol><li><strong><code>std::lock_guard</code> 在 producer 函数中的使用：</strong></li></ol><ul><li>在 <code>producer()</code> 函数中，生产者生产数据到缓冲区，并在数据生产完成后立即释放互斥量。由于在生产者生产完数据后就会释放互斥量，因此使用 <code>std::lock_guard</code> 而不是 <code>std::unique_lock</code> 更加简洁和合适。<code>std::lock_guard</code> 自动锁定互斥量，并在作用域结束时自动释放互斥量，非常适合这种简单的锁定和释放情况。</li></ul><ol start="2"><li><strong><code>std::unique_lock</code> 在 consumer 函数中的使用：</strong></li></ol><ul><li>在 <code>consumer()</code> 函数中，消费者需要等待缓冲区中有数据可消费时才能继续执行。为了支持在等待期间手动解锁互斥量并等待条件变量，这里使用了 <code>std::unique_lock</code>。<code>std::unique_lock</code> 提供了更灵活的加锁和解锁操作，同时支持条件变量的等待。在等待缓冲区有数据可消费时，我们使用 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 来等待条件变量满足。</li></ul><p> 综上所述，选择使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 取决于具体的应用场景和需求。在简单的自动锁定和释放互斥量情况下，可以使用 <code>std::lock_guard</code>；而在需要更多灵活性和条件变量支持的情况下，可以选择使用 <code>std::unique_lock</code>。在生产者消费者模型中，生产者和消费者可能有不同的需求，因此可以根据具体情况选择不同的锁定方式。</p></li><li><p><strong>cv.wait(lock, [] { return !buffer.empty(); });</strong></p><p> <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 这行代码是在<code>consumer()</code>函数中使用条件变量等待的部分。让我们详细解释这段代码的作用和具体执行流程：</p><ol><li><p><code>cv.wait(lock, condition)</code>：这是条件变量 <code>cv</code> 的等待函数调用。在这里，<code>lock</code> 是一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，通过将 <code>lock</code> 传递给 <code>cv.wait</code>，会在等待期间将互斥量解锁，以便其他线程可以在该互斥量上执行操作。<code>condition</code> 是一个 lambda 函数，用于指定等待条件。在这种情况下，<code>cv.wait</code>会在等待期间检查 lambda 函数返回的布尔值，只有在 lambda 函数返回 <code>true</code> 时才会继续执行。</p></li><li><p><code>[] &#123; return !buffer.empty(); &#125;</code>：这是一个 lambda 函数，它检查 <code>buffer</code> 是否为空。条件变量的 <code>wait</code> 操作依赖于用户提供的条件函数。在这里，条件函数检查 <code>buffer</code> 是否为空，如果为空，则条件为假， <code>cv.wait</code> 会一直等待，直到条件变为真。一旦条件为真，<code>cv.wait</code> 将继续执行，即互斥量被重新锁定，并且线程继续执行下去。</p></li><li><p>执行流程：</p><ul><li>当消费者线程开始执行 <code>consumer()</code> 函数时，首先会创建一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象 <code>lock</code>，该对象在实例化时会锁定其关联的互斥量 <code>mtx</code>。</li><li>接着，消费者线程调用 <code>cv.wait(lock, condition)</code>，这会导致线程释放互斥量的锁并等待，直到<code>condition</code>返回 <code>true</code>。</li><li>在等待过程中，其他线程可以获得互斥量的锁并修改共享数据，但由于条件未满足，消费者线程会一直保持等待状态。</li><li>当生产者线程向 <code>buffer</code> 中加入数据并调用 <code>cv.notify_one()</code> 通知时，条件 <code>!buffer.empty()</code> 变为真，这会导致条件变量通知消费者线程继续执行。</li><li>消费者线程被唤醒后，会重新获得互斥量的锁，这时可以安全地从 <code>buffer</code> 中取出数据进行消费，然后继续执行后续的操作。</li></ul></li></ol><p> 总之，通过使用条件变量和 lambda 函数等待特定条件，可以实现线程间的同步和协调，确保消费者在有数据可消费时才执行消费操作，从而有效避免了竞态条件和数据不一致的问题。</p></li><li><p><strong>lambda 表达式</strong><br> 用于定义函数对象：</p><ol><li><p><code>[]</code>：lambda 表达式的开头以一对方括号开始。在这里，<code>[]</code> 表示 lambda 表达式不捕获任何外部变量。这意味着 lambda 表达式只能访问传递给它的参数，而不能访问外部作用域的变量。</p></li><li><p><code>&#123;&#125;</code>：lambda 表达式的主体使用一对大括号来定义，在大括号内部是 lambda 表达式的具体实现。</p></li></ol></li></ol><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在多线程编程中，为了避免多个线程同时访问共享资源而引起的竞争条件和数据不一致性问题，我们使用互斥锁（Mutex，全称Mutual Exclusion）。互斥锁是一种同步原语，它允许线程在进入临界区（对共享资源操作的临界区域）前先获取锁，执行完后再释放锁，从而确保在同一时刻只有一个线程能进入临界区进行操作。</p><p>详细解释互斥锁包括以下几点：</p><ol><li><p><strong>锁的状态</strong>: 互斥锁有两种状态，分别是锁定（locked）和解锁（unlocked）。线程在进入临界区之前需要先获取锁（即将锁定状态设定为locked），执行完后再释放锁（将状态设定为unlocked）。</p></li><li><p><strong>互斥性</strong>: 互斥锁的特性确保了同一时刻只有一个线程能够获取锁，其他线程需要等待当前持有锁的线程释放锁后才能继续执行。这样可以避免多个线程同时访问共享资源导致的数据竞争和不一致性问题。</p></li><li><p><strong>使用方法</strong>: 在多线程代码中使用互斥锁时，一般会使用<code>std::mutex</code>或类似的互斥锁类型。典型的用法是在临界区开始之前调用<code>lock()</code>方法获取锁，在临界区结束后调用<code>unlock()</code>方法释放锁。</p></li><li><p><strong>死锁</strong>: 如果在多线程代码中使用互斥锁不当，可能会导致死锁（Deadlock）的问题。死锁指的是多个线程相互等待对方释放资源而无法继续执行的情况，因此在使用互斥锁时要注意避免造成死锁。</p></li></ol><p>总之，互斥锁是一种重要的同步工具，用于在多线程环境下控制对共享资源的访问，确保线程安全性并避免竞争条件和数据不一致性问题的发生。在正确使用互斥锁的情况下，可以有效地保证多线程程序的正确性和稳定性。</p><h3 id="临界区（对共享资源操作的临界区域）"><a href="#临界区（对共享资源操作的临界区域）" class="headerlink" title="临界区（对共享资源操作的临界区域）"></a>临界区（对共享资源操作的临界区域）</h3><p>临界区是指在多线程程序中，多个线程共享的某一段代码或数据区域，这里的代码或数据可能会被多个线程同时访问和操作。在临界区中，如果多个线程同时对共享资源进行读写操作，就会发生竞态条件（Race Condition），导致程序出现错误或产生不确定的结果。</p><p>让我们通过一个生动的比喻来解释临界区：</p><p>假设有一个小咖啡厅只有一个咖啡机可以制作咖啡。多个服务员（线程）需要制作咖啡时，他们需要先检查咖啡机是否空闲。如果咖啡机正在被使用，那么其他服务员必须等待直到当前制作完成并释放咖啡机。在这个过程中，检查咖啡机状态、占用咖啡机、释放咖啡机的这一段代码就是临界区。只能有一个服务员进入临界区，占用咖啡机，制作咖啡，防止出现多个服务员同时操作导致的错误。</p><p>所以，临界区是指在多线程环境下，需要同步访问共享资源的代码区域或数据区域，为了避免竞态条件，需要通过互斥锁等同步机制来确保同一时刻只有一个线程能够访问临界区，保证数据的正确性和一致性。通过合理管理临界区，可以有效避免多线程程序中的各种潜在问题，确保程序的正确性和稳定性。</p><h2 id="复杂一点点的例子"><a href="#复杂一点点的例子" class="headerlink" title="复杂一点点的例子"></a>复杂一点点的例子</h2><p>以下是一个更复杂的多线程示例，其中包含两个线程，一个是生产者线程，一个是消费者线程，它们之间通过共享的缓冲区进行通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line">        </span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，生产者线程负责向缓冲区中放入数据，而消费者线程则负责从缓冲区中取出数据。生产者线程会一直生产数据直到生产完20个数据为止。消费者线程会在生产者线程生产数据时，从缓冲区中消费数据，并且当生产者线程结束时也会结束。</p><p>通过使用互斥锁和条件变量来实现对缓冲区的访问控制和线程通信。生产者线程会根据缓冲区的状态来决定是否生产数据，而消费者线程也会根据缓冲区的状态来决定是否消费数据。在主函数中，调用了 <code>join()</code> 来等待生产者线程和消费者线程的结束。</p><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>当加上sleep_for后:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line"></span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Consumed: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Consumed: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Consumed: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Consumed: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Consumed: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Consumed: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Consumed: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Consumed: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>在生产者线程中使用<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>来模拟生产数据的耗时操作是为了模拟实际生产数据可能存在的耗时情况，而不是立即连续生产数据。这种模拟有几个关键的影响：</p><ol><li><p><strong>模拟实际情况</strong>：在实际情况下，生产数据可能涉及到一些繁重的计算或I&#x2F;O操作，这可能导致需要一定的时间来生成数据。通过这种模拟，可以更好地反映现实情况下的生产数据过程。</p></li><li><p><strong>线程调度</strong>：使用<code>sleep_for</code>会使得当前线程在指定的时间内暂停执行，其他线程有机会继续执行。这有助于模拟并发环境中不同线程之间的调度和竞争。</p></li><li><p><strong>避免资源争夺</strong>：由于生产者线程在生产数据时会暂停一段时间，消费者线程有机会访问和处理已生产的数据，而不会因为生产速度过快导致队列溢出或数据丢失。</p></li></ol><p>如果去掉<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>部分，生产者线程将会变得非常快速，可能导致生产的数据迅速填满队列，消费者线程无法及时消费，从而导致队列溢出。因此，这段代码中的延时操作对于正确模拟生产者和消费者之间的交互过程和线程调度是非常重要的。</p><ol><li><p><strong>为什么done&#x3D;true后面要加consumeCondition.notify_one();</strong></p><p> 在典型的生产者消费者模型中，<code>done=true</code>通常表示生产者已经完成了生产任务，没有更多的数据可供消费者消费。当<code>done</code>被设置为<code>true</code>时，消费者线程需要被唤醒并退出循环，以避免不必要的等待和资源浪费。为了实现这一点，通常会使用条件变量（condition variable）来实现线程的等待和唤醒。</p><p> 在设置<code>done=true</code>之后，通过调用<code>consumeCondition.notify_one()</code>来唤醒等待在<code>consumeCondition</code>条件变量上的一个消费者线程。这样做可以确保消费者线程在<code>done=true</code>之后能够立即被唤醒，检查条件并退出循环。没有这一步的唤醒操作，消费者线程可能会一直阻塞在条件变量上，无法及时退出循环，导致资源浪费或程序逻辑错误。</p><p> 因此，通过在<code>done=true</code>之后调用<code>consumeCondition.notify_one()</code>来唤醒消费者线程，确保了生产者完成生产后消费者能够及时退出循环，有效地管理线程的执行顺序和资源的利用。</p></li><li><p><strong>condition_variable是什么</strong></p><p> <code>std::condition_variable</code> 是 C++ 标准库中用来实现多线程同步的一种机制。它允许一个或多个线程等待，直到某个条件得到满足后再继续执行。在多线程编程中，我们经常需要一种方式来进行线程之间的通信和同步，<code>std::condition_variable</code> 就是为此而设计的。</p><p> 在使用 <code>std::condition_variable</code> 时通常和 <code>std::mutex</code> 配合使用，具体步骤如下：</p><ol><li>使用 <code>std::mutex</code> 来保护需要等待的条件变量和共享资源。</li><li>当条件不满足时，线程通过 <code>std::condition_variable</code> 的 <code>wait()</code> 方法释放锁并进入等待状态，直到其他线程通知条件满足。</li><li>当其他线程满足了条件后，调用 <code>std::condition_variable</code> 的 <code>notify_one()</code> 或 <code>notify_all()</code> 方法来唤醒等待的线程。</li></ol><p> 通过 <code>std::condition_variable</code>，我们可以实现线程之间的有效协作和同步，避免了线程忙等待，提高了程序的效率和性能。</p></li></ol><h2 id="4个线程来并发计算部分和"><a href="#4个线程来并发计算部分和" class="headerlink" title="4个线程来并发计算部分和"></a>4个线程来并发计算部分和</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)&lt;/p&gt;&lt;/div&gt;


&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; cl</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="C++" scheme="http://tumytime.github.io/tags/C/"/>
    
    <category term="智能车，多线程" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一些图像处理的函数</title>
    <link href="http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2024-04-29T11:47:24.000Z</published>
    <updated>2024-04-29T12:18:44.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p><strong>卷积核大小为7：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">medianFilter</span><span class="params">(Mat imgO)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个新的Mat对象用于存储滤波后的图像</span></span><br><span class="line">Mat img1 = Mat::<span class="built_in">zeros</span>(imgO.rows - <span class="number">6</span>, imgO.cols - <span class="number">6</span>, CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入图像进行中值滤波</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">3</span>; y &lt; imgO.rows - <span class="number">3</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">3</span>; x &lt; imgO.cols - <span class="number">3</span>; x++) &#123;</span><br><span class="line">vector&lt;uchar&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-3</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-3</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">values.<span class="built_in">push_back</span>(imgO.<span class="built_in">at</span>&lt;uchar&gt;(y + j, x + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对values数组中的值进行排序</span></span><br><span class="line"><span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算中值并赋值给输出图像</span></span><br><span class="line">img1.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">3</span>, x - <span class="number">3</span>) = values[values.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> img1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="sobel算子边缘检测"><a href="#sobel算子边缘检测" class="headerlink" title="sobel算子边缘检测"></a>sobel算子边缘检测</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">sobel3</span><span class="params">(Mat inputImg)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gx, gy;</span><br><span class="line">Mat tempImg;</span><br><span class="line">inputImg.<span class="built_in">copyTo</span>(tempImg); <span class="comment">// 为了能够在输出图像中访问原始输入图像的像素值</span></span><br><span class="line"></span><br><span class="line">Mat outputImg = Mat::<span class="built_in">zeros</span>(inputImg.<span class="built_in">size</span>(), inputImg.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; inputImg.rows - <span class="number">1</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; inputImg.cols - <span class="number">1</span>; x++) &#123;</span><br><span class="line">gx = (<span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>)) / <span class="number">4</span>;</span><br><span class="line">gy = (<span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) - <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x) - <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">outputImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x) = (<span class="built_in">abs</span>(gx) + <span class="built_in">abs</span>(gy)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outputImg.<span class="built_in">clone</span>(); <span class="comment">// 返回outputImg的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中值滤波&quot;&gt;&lt;a href=&quot;#中值滤波&quot; class=&quot;headerlink&quot; title=&quot;中值滤波&quot;&gt;&lt;/a&gt;中值滤波&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;卷积核大小为7：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AuTop代码整理</title>
    <link href="http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <id>http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/</id>
    <published>2024-04-28T11:36:06.000Z</published>
    <updated>2024-05-03T17:37:19.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="圆环circle"><a href="#圆环circle" class="headerlink" title="圆环circle"></a>圆环circle</h2><details ><summary pointer> circle.c </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;motor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span> =</span> CIRCLE_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便串口收发</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM] = &#123;</span><br><span class="line">        <span class="string">&quot;CIRCLE_NONE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_BEGIN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_BEGIN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_RUNNING&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_RUNNING&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_IN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_IN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_OUT&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_OUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_END&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_END&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码器，用于防止一些重复触发等。</span></span><br><span class="line"><span class="type">int64_t</span> circle_encoder;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> none_left_line = <span class="number">0</span>, none_right_line = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> have_left_line = <span class="number">0</span>, have_right_line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆环模式下的调试图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> circle.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> &#123;</span></span><br><span class="line">    CIRCLE_NONE = <span class="number">0</span>,                            <span class="comment">// 非圆环模式</span></span><br><span class="line">    CIRCLE_LEFT_BEGIN, CIRCLE_RIGHT_BEGIN,      <span class="comment">// 圆环开始，识别到单侧L角点另一侧长直道。</span></span><br><span class="line">    CIRCLE_LEFT_IN, CIRCLE_RIGHT_IN,            <span class="comment">// 圆环进入，即走到一侧直道，一侧圆环的位置。</span></span><br><span class="line">    CIRCLE_LEFT_RUNNING, CIRCLE_RIGHT_RUNNING,  <span class="comment">// 圆环内部。</span></span><br><span class="line">    CIRCLE_LEFT_OUT, CIRCLE_RIGHT_OUT,          <span class="comment">// 准备出圆环，即识别到出环处的L角点。</span></span><br><span class="line">    CIRCLE_LEFT_END, CIRCLE_RIGHT_END,          <span class="comment">// 圆环结束，即再次走到单侧直道的位置。</span></span><br><span class="line">    CIRCLE_NUM,                                 <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CIRCLE_H</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="非圆环模式下判断圆环"><a href="#非圆环模式下判断圆环" class="headerlink" title="非圆环模式下判断圆环"></a>非圆环模式下判断圆环</h3><p><strong>单边L角点, 单边长直道</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆环执行"><a href="#圆环执行" class="headerlink" title="圆环执行"></a>圆环执行</h3><details ><summary pointer> run_circle() </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> 详细解读 </summary>              <div class='content'>              <details open><summary pointer> get_total_encoder() </summary>          <div class='content'>          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">get_total_encoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int64_t</span>) ((motor_l.total_encoder + motor_r.total_encoder) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个函数 <code>get_total_encoder()</code>，用于计算左右两个电机的编码器总和并取平均值。具体步骤如下：</p><ol><li>获取左电机和右电机的编码器值 <code>motor_l.total_encoder</code> 和 <code>motor_r.total_encoder</code>。</li><li>将左右两个电机的编码器值相加得到总和。</li><li>将总和除以2取平均值，然后以 <code>int64_t</code> 类型返回结果。</li></ol>          </div>        </details>              </div>            </details><p>track_type：单边得中线的边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">          current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑似乎与之前的代码相关，用于检测编码器在打表过1&#x2F;4圆时的状态，并进行相应的修正。让我来解释一下这段代码的作用：</p><ol><li>首先判断条件 <code>rpts0s_num &lt; 0.1 / sample_dist</code>，如果条件成立，说明小车还未行驶到1&#x2F;4圆的位置，或者右线未被检测到。</li><li>或者判断条件 <code>current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (3.14 * 1 / 2)</code>，这个条件看起来是在判断当前编码器值与开始打表时的编码器值之差是否超过了1&#x2F;4圆的周长对应的编码器值。</li><li>如果以上两个条件有一个成立，就会将 <code>circle_type</code> 设置为 <code>CIRCLE_LEFT_RUNNING</code>，表示小车正在左环行驶的阶段。</li></ol><p>在检测到小车行驶过1&#x2F;4圆或者右线为转弯时将 <code>circle_type</code> 修改为 <code>CIRCLE_LEFT_RUNNING</code>，可能是为了校准小车在左环赛道上行驶时的特定状态。这段代码与之前的代码一起，似乎在实现一个复杂的状态机来控制小车在左环赛道上的运动。如果您有更多的问题或需要进一步解释，请随时告诉我。</p><hr><p>什么是编码器打表:<br>编码器打表（Encoder Look-Up Table）通常指的是在编码器模块中使用查找表（Look-Up Table）来进行编码的过程。在信号处理领域或者通信系统中，编码器的作用是将输入信号转换为特定的编码形式，以便传输、存储或处理。而编码器打表的概念是通过预先构建一个表格，将输入信号映射到特定的编码值，从而实现编码的过程。</p><p>在这种情况下，编码器打表的优势在于可以提高编码的速度和效率。通过查找表，编码器可以以常量时间复杂度快速查找到对应的编码值，而不必每次都进行复杂的计算或逻辑判断。这样可以加快编码过程，特别是在需要频繁编码大量数据时，可以节省时间和计算资源。</p><p>总的来说，编码器打表是一种提高编码效率的方法，通过预先建立编码映射表，可以在编码过程中快速准确地找到对应的编码值，提高系统性能和速度。</p><hr><h2 id="迷宫巡线部分"><a href="#迷宫巡线部分" class="headerlink" title="迷宫巡线部分"></a>迷宫巡线部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前进方向定义：</span></span><br><span class="line"><span class="comment"> *   0</span></span><br><span class="line"><span class="comment"> * 3   1</span></span><br><span class="line"><span class="comment"> *   2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_front[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">1</span>,  <span class="number">0</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontleft[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontright[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_lefthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; half &lt; x &amp;&amp; x &lt; img-&gt;width - half - <span class="number">1</span> &amp;&amp; half &lt; y &amp;&amp; y &lt; img-&gt;height - half - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontleft_value = <span class="built_in">AT</span>(img, x + dir_frontleft[dir][<span class="number">0</span>], y + dir_frontleft[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontleft_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontleft[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontleft[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 右手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_righthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; <span class="number">0</span> &lt; x &amp;&amp; x &lt; img-&gt;width - <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt; img-&gt;height - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontright_value = <span class="built_in">AT</span>(img, x + dir_frontright[dir][<span class="number">0</span>], y + dir_frontright[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontright_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontright[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontright[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">warpPerspective</span><span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> flags = INTER_LINEAR, <span class="type">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> Scalar &amp;borderValue = Scalar())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>(!src.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">CV_Assert</span>(src.<span class="built_in">depth</span>() == CV_8U || src.<span class="built_in">depth</span>() == CV_32F);</span><br><span class="line">    <span class="built_in">CV_Assert</span>(M.<span class="built_in">rows</span>() == <span class="number">3</span> &amp;&amp; M.<span class="built_in">cols</span>() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">mapx</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">mapy</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">transform</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, CV_64F)</span></span>;</span><br><span class="line">    M.<span class="built_in">getMat</span>().<span class="built_in">colRange</span>(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">convertTo</span>(transform, transform.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buildWarpPerspectiveMaps</span>(transform, flags, dsize, mapx, mapy);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remap</span>(src, dst, mapx, mapy, flags, borderMode, borderValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是OpenCV中的warpPerspective函数的实现，用于对输入图像进行透视变换。下面是对代码中的函数及参数的详细解释：</p><h3 id="warpPerspective函数参数解释："><a href="#warpPerspective函数参数解释：" class="headerlink" title="warpPerspective函数参数解释："></a>warpPerspective函数参数解释：</h3><ul><li><strong>src</strong>：输入图像，类型为InputArray。</li><li><strong>dst</strong>：输出图像，类型为OutputArray。</li><li><strong>M</strong>：3x3的变换矩阵，描述了透视变换，类型为InputArray。</li><li><strong>dsize</strong>：输出图像的尺寸，类型为Size。</li><li><strong>flags</strong>：插值方法，用于指定在进行像素值插值时要使用的方法，默认为INTER_LINEAR。</li><li><strong>borderMode</strong>：边界像素插值模式，用于指定当目标图像像素位于源图像之外时的处理方式，默认为BORDER_CONSTANT。</li><li><strong>borderValue</strong>：边界填充的像素值，类型为Scalar。</li></ul><h3 id="warpPerspective函数主要步骤解释："><a href="#warpPerspective函数主要步骤解释：" class="headerlink" title="warpPerspective函数主要步骤解释："></a>warpPerspective函数主要步骤解释：</h3><ol><li><p><strong>CV_INSTRUMENT_REGION</strong>：用于性能测量和优化的宏定义。</p></li><li><p><strong>CV_Assert</strong>：断言，用于判断条件是否成立，如果条件不成立则会抛出一个异常。</p></li><li><p><strong>Mat mapx</strong>和<strong>Mat mapy</strong>：分别用于存储X和Y方向的映射结果。</p></li><li><p><strong>Mat transform</strong>：是一个2x3的矩阵，用于保存M矩阵的前两列，并将其转换为CV_64F类型。</p></li><li><p><strong>buildWarpPerspectiveMaps</strong>：根据透视变换矩阵和指定的插值方法，构建出目标图像在源图像上的映射关系。</p></li><li><p><strong>remap</strong>：根据生成的映射关系对输入图像进行透视变换，并存储结果到输出图像dst中。<br>  M.getMat().colRange(0, 2).convertTo(transform, transform.type());详细解释<br>  这行代码是针对OpenCV中的矩阵操作。让我逐步解释一下：</p></li><li><p><code>M.getMat()</code>: 这部分获取一个OpenCV的矩阵<code>M</code>。</p></li><li><p><code>.colRange(0, 2)</code>: 这个部分表示对该矩阵<code>M</code>的列进行切片操作，只选择从第0列到第2列（不包括第2列）的部分。</p></li><li><p><code>.convertTo(transform, transform.type())</code>: 这一部分是将切片后的列数据进行类型转换并赋值给另外一个矩阵<code>transform</code>。这里的<code>transform</code>是一个目标矩阵，它将包含转换后的数据。<code>transform.type()</code>返回<code>transform</code>矩阵的类型。</p></li></ol><p>因此，整体来看，这行代码的作用是从矩阵<code>M</code>中选择第0列到第1列的数据，并将其转换为指定类型，然后存储到矩阵<code>transform</code>中。</p><p>这是 <code>buildWarpPerspectiveMaps</code> 函数的伪代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWarpPerspectiveMaps</span><span class="params">(Size src_size, Matx33f M, <span class="type">bool</span> inverse_map, Mat&amp; xmap, Mat&amp; ymap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = src_size.width;</span><br><span class="line">    <span class="type">int</span> height = src_size.height;</span><br><span class="line">    </span><br><span class="line">    xmap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line">    ymap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            Vec3f src_pt = <span class="built_in">Vec3f</span>(x, y, <span class="number">1</span>); <span class="comment">// Source point</span></span><br><span class="line">            Vec3f dst_pt = M * src_pt;      <span class="comment">// Apply transformation matrix</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> map_x, map_y;</span><br><span class="line">            <span class="keyword">if</span> (!inverse_map) &#123;</span><br><span class="line">                map_x = dst_pt[<span class="number">0</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">                map_y = dst_pt[<span class="number">1</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map_x = src_pt[<span class="number">0</span>] - dst_pt[<span class="number">0</span>];</span><br><span class="line">                map_y = src_pt[<span class="number">1</span>] - dst_pt[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xmap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_x;</span><br><span class="line">            ymap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个伪代码实现描述了 <code>buildWarpPerspectiveMaps</code> 函数的大致操作步骤。实际的 <code>buildWarpPerspectiveMaps</code> 函数是 OpenCV 中用于构建透视变换映射的函数，具体实现会更加复杂并且包含了更多细节。如果你需要实际的代码实现，建议查阅 OpenCV 的源代码或者官方文档中提供的具体函数实现。希望这个简要描述能够帮助到你，如果有其他问题或者需要更多帮助，请随时告诉我。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>输入图像src不能为空。</li><li>输入图像src的深度必须为CV_8U或CV_32F。</li><li>变换矩阵M必须为一个3x3矩阵。</li><li>warpPerspective函数实现了透视变换的核心逻辑，通过构建变换矩阵并利用remap函数实现对图像的透视变换操作。</li></ul><p>如果你有任何关于这段代码的疑问或需要进一步解释，请随时告诉我。</p><p>@brief Applies a perspective transformation to an image.</p><p>The function warpPerspective transforms the source image using the specified matrix:</p><p>  [$\texttt{dst} (x,y) &#x3D;  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,<br>     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )$] </p><p>when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert<br>and then put in the formula above instead of M. The function cannot operate in-place.</p><p>@param src input image.<br>@param dst output image that has the size dsize and the same type as src .<br>@param M  $ 3\times 3 $ transformation matrix.<br>@param dsize size of the output image.<br>@param flags combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the<br>optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (<br>$\texttt{dst}\rightarrow\texttt{src} $ ).<br>@param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).<br>@param borderValue value used in case of a constant border; by default, it equals 0.</p><p>@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;圆环circle&quot;&gt;&lt;a href=&quot;#圆环circle&quot; class=&quot;headerlink&quot; title=&quot;圆环circle&quot;&gt;&lt;/a&gt;圆环circle&lt;/h2&gt;&lt;details &gt;&lt;summary pointer&gt; circle.c &lt;/summary&gt;
 </summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>逆透视</title>
    <link href="http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/"/>
    <id>http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/</id>
    <published>2024-04-26T17:14:17.000Z</published>
    <updated>2024-04-26T17:17:07.839Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief IPM初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param origSize 输入原始图像Size</span></span><br><span class="line"><span class="comment">     * @param dstSize 输出图像Size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> cv::Size &amp;origSize, <span class="type">const</span> cv::Size &amp;dstSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原始域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points at the input image</span></span><br><span class="line">        m_origPoints.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// [第二版无带畸变镜头参数]</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">0</span>, <span class="number">214</span>));   <span class="comment">// 左下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">319</span>, <span class="number">214</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">192</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">128</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矫正域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points correspondences in the destination image</span></span><br><span class="line">        m_dstPoints.<span class="built_in">clear</span>();</span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">400</span>)); <span class="comment">// 左下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">400</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        m_origSize = origSize;</span><br><span class="line">        m_dstSize = dstSize;</span><br><span class="line">        <span class="built_in">assert</span>(m_origPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; m_dstPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; <span class="string">&quot;Orig. points and Dst. points must vectors of 4 points&quot;</span>);</span><br><span class="line">        m_H = <span class="built_in">getPerspectiveTransform</span>(m_origPoints, m_dstPoints); <span class="comment">// 计算变换矩阵 [3x3]</span></span><br><span class="line">        m_H_inv = m_H.<span class="built_in">inv</span>();                                      <span class="comment">// 求解逆转换矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">createMaps</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>void init(const cv::Size &amp;origSize, const cv::Size &amp;dstSize)</code>: 这是一个名为<code>init</code>的函数，它接受两个参数<code>origSize</code>和<code>dstSize</code>，这两个参数是OpenCV库中的<code>cv::Size</code>类型，用来表示图像的尺寸。</p></li><li><p><code>m_origPoints.clear();</code>: 清空存储原始域点坐标的容器<code>m_origPoints</code>。</p></li><li><p><code>m_origPoints.push_back(Point2f(0, 214));</code>: 将<code>(0, 214)</code>点坐标添加到原始域的点坐标集合中，代表原始图像的左下角。</p></li><li><p>依次类推，将原始域的四个角的点坐标添加到<code>m_origPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_dstPoints.clear();</code>: 清空存储矫正域点坐标的容器<code>m_dstPoints</code>。</p></li><li><p><code>m_dstPoints.push_back(Point2f(100, 400));</code>: 将<code>(100, 400)</code>点坐标添加到矫正域的点坐标集合中，代表矫正图像的左下角。</p></li><li><p>依次类推，将矫正域的四个角的点坐标添加到<code>m_dstPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_origSize = origSize;</code>和<code>m_dstSize = dstSize;</code>: 将原始图像尺寸和目标图像尺寸保存下来。</p></li><li><p><code>assert(m_origPoints.size() == 4 &amp;&amp; m_dstPoints.size() == 4 &amp;&amp; &quot;Orig. points and Dst. points must vectors of 4 points&quot;);</code>: 使用<code>assert</code>断言来确保原始域和矫正域的点坐标集合都包含四个点。</p></li><li><p><code>m_H = getPerspectiveTransform(m_origPoints, m_dstPoints);</code>: 通过原始域和矫正域的点坐标计算透视变换矩阵<code>m_H</code>。</p></li><li><p><code>m_H_inv = m_H.inv();</code>: 求解透视变换矩阵<code>m_H</code>的逆矩阵，存储在<code>m_H_inv</code>中。</p></li><li><p><code>createMaps();</code>: 调用<code>createMaps</code>函数，创建地图。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据集标注json转xml脚本</title>
    <link href="http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/"/>
    <id>http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/</id>
    <published>2024-04-26T12:43:07.000Z</published>
    <updated>2024-04-26T12:47:40.715Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_json_to_xml</span>(<span class="params">json_data</span>):</span><br><span class="line">    root = ET.Element(<span class="string">&quot;annotation&quot;</span>)</span><br><span class="line">    filename = ET.SubElement(root, <span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    filename.text = json_data[<span class="string">&quot;imagePath&quot;</span>]</span><br><span class="line">    object_num = ET.SubElement(root, <span class="string">&quot;object_num&quot;</span>)</span><br><span class="line">    object_num.text = <span class="built_in">str</span>(<span class="built_in">len</span>(json_data[<span class="string">&quot;shapes&quot;</span>]))</span><br><span class="line">    size = ET.SubElement(root, <span class="string">&quot;size&quot;</span>)</span><br><span class="line">    width = ET.SubElement(size, <span class="string">&quot;width&quot;</span>)</span><br><span class="line">    width.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageWidth&quot;</span>])</span><br><span class="line">    height = ET.SubElement(size, <span class="string">&quot;height&quot;</span>)</span><br><span class="line">    height.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageHeight&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> json_data[<span class="string">&quot;shapes&quot;</span>]:</span><br><span class="line">        object_element = ET.SubElement(root, <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        name = ET.SubElement(object_element, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">        name.text = shape[<span class="string">&quot;label&quot;</span>]</span><br><span class="line">        difficult = ET.SubElement(object_element, <span class="string">&quot;difficult&quot;</span>)</span><br><span class="line">        difficult.text = <span class="string">&quot;0&quot;</span></span><br><span class="line">        bndbox = ET.SubElement(object_element, <span class="string">&quot;bndbox&quot;</span>)</span><br><span class="line">        xmin = ET.SubElement(bndbox, <span class="string">&quot;xmin&quot;</span>)</span><br><span class="line">        xmin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">        ymin = ET.SubElement(bndbox, <span class="string">&quot;ymin&quot;</span>)</span><br><span class="line">        ymin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line">        xmax = ET.SubElement(bndbox, <span class="string">&quot;xmax&quot;</span>)</span><br><span class="line">        xmax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">        ymax = ET.SubElement(bndbox, <span class="string">&quot;ymax&quot;</span>)</span><br><span class="line">        ymax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ET.tostring(root, encoding=<span class="string">&quot;unicode&quot;</span>)</span><br><span class="line">current_dir = os.getcwd()</span><br><span class="line">parent_dir = os.path.abspath(os.path.join(current_dir, os.pardir))</span><br><span class="line">output_dir = os.path.join(parent_dir, <span class="string">&quot;xml_output&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(current_dir):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&quot;.json&quot;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(current_dir, file), <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json_data = json.load(json_file)</span><br><span class="line">            xml_data = convert_json_to_xml(json_data)</span><br><span class="line">            xml_filename = file.replace(<span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">            output_path = os.path.join(output_dir, xml_filename)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> xml_file:</span><br><span class="line">                xml_file.write(xml_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有JSON文件已经转换为XML并保存在文件夹 xml_output 中&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="python" scheme="http://tumytime.github.io/tags/python/"/>
    
    <category term="数据集" scheme="http://tumytime.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
</feed>
