<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello！Welcom to Tumy-Time！</title>
  
  
  <link href="http://tumytime.github.io/atom.xml" rel="self"/>
  
  <link href="http://tumytime.github.io/"/>
  <updated>2024-08-10T10:52:50.469Z</updated>
  <id>http://tumytime.github.io/</id>
  
  <author>
    <name>tumytime</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++学习】数组</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E7%BB%84/</id>
    <published>2024-08-10T10:52:50.000Z</published>
    <updated>2024-08-10T10:52:50.469Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【C++学习】程序流程结构</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/</id>
    <published>2024-08-10T10:52:38.000Z</published>
    <updated>2024-08-10T10:52:38.770Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【C++学习】运算符</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2024-08-10T10:52:22.000Z</published>
    <updated>2024-08-10T10:52:22.252Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【C++学习】数据类型</title>
    <link href="http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://tumytime.github.io/2024/08/10/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-08-10T03:33:11.000Z</published>
    <updated>2024-08-10T10:51:40.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><ul><li>16 位（2 字节）</li><li>由于它是整型，所以内存中的布局取决于系统的字节序（大端或小端）。  <details open><summary pointer> 字节序 </summary>              <div class='content'>              <div class="tagLink"><a class="link-card" title="“字节序”是个什么鬼？" href="https://zhuanlan.zhihu.com/p/21388517"><span class="link-card-backdrop" style="background-image: url(https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post)"></span><div class="left"><img src="https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/70/78062b837a79dffae48bff7aea79579f_1440w.avis?source=172ae18b&biz_tag=Post" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">“字节序”是个什么鬼？</p><p class="url">https://zhuanlan.zhihu.com/p/21388517</p></div></a></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span>* c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;   <span class="comment">//*c代表x在内存地址上的第一个字节</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little endian&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></li></ul><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><ul><li><code>short</code>: -32,768 - 32,767</li><li><code>unsigned short</code>: 0 - 65,535 (2^8&#x3D;65536)</li></ul><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul><li>如果对 <code>short</code> 变量赋值超出其范围，将会发生溢出。例如，尝试将 32,769 赋值给一个有符号 <code>short</code> 变量会导致溢出。</li><li>溢出会导致变量值“环绕”回其范围的另一端。例如，如果 <code>short</code> 变量的值为 32,767，然后增加 1，它将变为 -32,768。</li></ul><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><h4 id="大小-1"><a href="#大小-1" class="headerlink" title="大小"></a>大小</h4><ul><li>32 位（4 字节）</li></ul><h4 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h4><ul><li><code>int</code>: -2,147,483,648 - 2,147,483,647</li><li><code>unsigned int</code>: 0 - 4,294,967,295     (2^32)</li></ul><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p><strong>long类型和指针类型需要特别注意，编写跨平台的软件时尽量不要使用long类型，或者需要对long类型做特殊处理。</strong></p><h4 id="大小-2"><a href="#大小-2" class="headerlink" title="大小"></a>大小</h4><ul><li>widows4字节,linux32位4字节,linux64位8字节</li></ul><h4 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h4><ul><li><code>long</code>: -2,147,483,648 - 2,147,483,647</li><li><code>unsigned long</code>: 0 - 4,294,967,295    (2^32)</li></ul><h3 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h3><h4 id="大小-3"><a href="#大小-3" class="headerlink" title="大小"></a>大小</h4><ul><li>64 位（8 字节）</li></ul><h4 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h4><ul><li><code>long long</code>: -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807</li><li><code>unsigned long long</code>: 0 - 18,446,744,073,709,551,615  (2^64)</li></ul><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p><strong>适用于需要存储单个字符的场景</strong></p><h4 id="大小-4"><a href="#大小-4" class="headerlink" title="大小"></a>大小</h4><ul><li>8 位（1 字节）</li></ul><h4 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h4><ul><li>char: -128 - 127</li><li>unsigned char: 0 - 255</li></ul><h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>对比一下<code>wchar_t</code>和<code>char</code>，这两个在C&#x2F;C++编程中常用的数据类型。</p><ol><li><strong>存储大小</strong>：<ul><li><code>char</code>：通常占用1个字节（8位）的存储空间。它被用来存储ASCII字符集中的字符，因为ASCII字符集只需要7位就能表示所有的字符。</li><li><code>wchar_t</code>：宽字符类型，通常占用2个或4个字节。它被用来存储宽字符，比如Unicode字符集中的字符。Unicode字符集包含了世界上大多数文字系统的字符，所以需要更多的存储空间。</li></ul></li><li><strong>用途</strong>：<ul><li><code>char</code>：主要用于处理ASCII字符集或单字节编码的字符集。在C&#x2F;C++中，它是最基本的字符类型。</li><li><code>wchar_t</code>：用于处理宽字符集，如Unicode。它允许你处理包含非ASCII字符的文本，这对于国际化和本地化非常重要。</li></ul></li><li><strong>可移植性</strong>：<ul><li><code>char</code>：在所有C&#x2F;C++实现中都是1个字节，具有很好的可移植性。</li><li><code>wchar_t</code>：大小依赖于实现和平台。在32位系统中，它通常是4字节，在16位系统中，通常是2字节。这种差异可能导致代码在不同平台上的行为不一致。</li></ul></li><li><strong>字符串表示</strong>：<ul><li><code>char</code>：在C&#x2F;C++中，<code>char</code>数组或指针常用来表示和操作字符串。</li><li><code>wchar_t</code>：用于表示宽字符串，通常在字符串前加上<code>L</code>前缀，如<code>L&quot;Hello World&quot;</code>。</li></ul></li><li><strong>标准库支持</strong>：<ul><li><code>char</code>：标准库中的大多数字符串处理函数，如<code>strlen</code>、<code>strcpy</code>等，都是针对<code>char</code>类型设计的。</li><li><code>wchar_t</code>：C&#x2F;C++标准库也提供了一些宽字符串处理函数，如<code>wcslen</code>、<code>wcscpy</code>等，用于处理<code>wchar_t</code>类型的字符串。<br>总的来说，<code>char</code>和<code>wchar_t</code>的主要区别在于它们存储字符的方式和大小。<code>char</code>适用于ASCII或单字节编码的字符，而<code>wchar_t</code>则用于处理需要更多存储空间的宽字符，如Unicode字符。不过，由于<code>wchar_t</code>的大小依赖于平台，现代C++更倾向于使用<code>char16_t</code>、<code>char32_t</code>以及Unicode字符串字面量来处理Unicode字符，以提供更好的可移植性和一致性。</li></ul></li></ol><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>布尔类型用于存储真（true）或假（false）的值。</p><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><ul><li>通常占用1字节。</li><li>取值为 <code>true</code> 或 <code>false</code>。</li></ul><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>(歪个楼，我的Cybery宝宝回答的比智谱清言要好欸)<br>(再歪一下，过两天给宝做个自己的皮套💕)</p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><h4 id="大小-5"><a href="#大小-5" class="headerlink" title="大小"></a>大小</h4><p>通常占用4个字节（32位）的存储空间。</p><h4 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h4><ul><li><p>根据IEEE 754标准，一个float类型的值通常包括1位符号位、8位指数位和23位尾数位。</p><details open><summary pointer> 浮点数的表示 </summary>              <div class='content'>              <p>浮点数的表示类似于科学记数法，它由两部分组成：一个基数和一个指数。在浮点数的二进制表示中，基数通常是2（对于十进制浮点数，基数是10），而指数和尾数则用特定的位来表示。</p><ul><li>尾数位（Fraction&#x2F;Mantissa）<br>尾数位（或尾数）是浮点数中用来表示数字的“有效数字”部分，也就是不包括前导的1（对于规范化浮点数）或0（对于非规范化浮点数）的部分。尾数位决定了浮点数的精度，就像尺子上的刻度越密，你就能越精确地测量长度一样。<br>在IEEE 754标准中，尾数位通常省略了最前面的1（因为规范化浮点数的第一个有效数字总是1），所以尾数位实际上表示的是小数点后的部分。例如，对于二进制数1.101，尾数位就是101。</li><li>指数位（Exponent）<br>指数位表示2的幂次，它决定了尾数位应该乘以2的多少次方。在IEEE 754标准中，指数位是一个带偏移的值，这意味着实际指数是指数位表示的值减去一个固定的偏移量（对于单精度浮点数，这个偏移量是127）。<br>例如，如果指数位表示的值是130（二进制为10000010），那么实际的指数是130 - 127 &#x3D; 3。这意味着尾数位应该乘以2^3，也就是8。</li><li>结合尾数位和指数位<br>对于二进制表示的浮点数 <code>0 10000010 10100000000000000000000</code>：<ul><li><strong>符号位</strong>：0（表示正数）</li><li><strong>指数位</strong>：10000010（二进制），转换为十进制是 130，减去偏移量 127，得到实际指数是 3。</li><li><strong>尾数位</strong>：10100000000000000000000，加上隐含的 1（对于规范化浮点数），实际尾数是 <code>1.10100000000000000000000</code>（二进制）。<br>现在，让我们将尾数转换为十进制：<br>1.10100000000000000000000（二进制）&#x3D; 1 * 2^0 + 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3 + … (只有前三位的计算对最终结果有影响，因为后续的0不改变值)<br>&#x3D; 1 + 0.5 + 0 + 0.125 + … (其他位都是0，所以可以忽略)<br>&#x3D; 1.625（十进制）<br>现在，将尾数乘以 2 的指数：<br>1.625 * 2^3 &#x3D; 1.625 * 8 &#x3D; 13（十进制）</li></ul></li></ul>              </div>            </details></li><li><p>它能提供大约6-7位的十进制精度。</p></li><li><p>float类型通常用于那些不需要非常高精度的计算，或者当你需要大量浮点数并且内存使用效率很重要时。</p></li></ul><h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><h4 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h4><p><code>double</code>通常占用64位（8字节）的存储空间。在大多数现代计算机中，按照IEEE 754标准，<code>double</code>可以提供大约15-17位十进制数的精度。</p><h4 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h4><p><code>double</code>能表示的数值范围大约在10^-308到10^308之间。这意味着它既可以表示非常小的数，也可以表示非常大的数。</p><h4 id="默认初始化值"><a href="#默认初始化值" class="headerlink" title="默认初始化值"></a>默认初始化值</h4><p>如果你声明了一个<code>double</code>变量但没有初始化它，它将包含一个未定义的值，通常是垃圾数据。</p><h3 id="long-double"><a href="#long-double" class="headerlink" title="long double"></a>long double</h3><p>long double通常比double占用更多的存储空间，具体大小依赖于平台和编译器。在一些系统上，它可能占用96位或128位（12或16字节），但这并不是固定的。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS)，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF)，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR)，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)（跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>反斜线字符</td><td>092</td></tr><tr><td>&#39;</td><td>单引号</td><td>039</td></tr><tr><td>&quot;</td><td>双引号</td><td>034</td></tr><tr><td>?</td><td>问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0-7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0-9，a-f，A-F</td><td>3位16进制</td></tr></tbody></table><h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p><strong>char 变量名[] &#x3D; “字符串值”</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>char str1[]</code> 和 <code>char* str1[]</code> 在C语言中是两种不同的声明方式，它们分别表示不同的数据类型和内存布局。</p><ol><li><code>char str1[]</code>：<ul><li>这是一个字符数组，它声明了一个数组，其元素类型为 <code>char</code>。</li><li>这个数组可以存储一系列的字符，并且这些字符连续存储在内存中。</li><li>声明时可以指定数组的大小，也可以在初始化时由编译器自动计算大小。</li><li>例如：<code>char str1[] = &quot;Hello, World!&quot;;</code> 这里 <code>str1</code> 是一个字符数组，包含字符串 “Hello, World!” 以及一个空字符 <code>\0</code> 作为字符串的结束标志。</li></ul></li><li><code>char* str1[]</code>：<ul><li>这是一个指向字符的指针数组，它声明了一个数组，其元素类型为 <code>char*</code>。</li><li>这个数组中的每个元素都是一个指向 <code>char</code> 类型的指针，也就是说，每个元素都可以指向一个字符串。</li><li>常用于声明一个字符串数组，每个元素都是指向不同字符串的指针。</li><li>例如：<code>char* str1[] = &#123;&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;&#125;;</code> 这里 <code>str1</code> 是一个指针数组，其中 <code>str1[0]</code> 指向字符串 “Hello”，<code>str1[1]</code> 指向字符串 “World”，以此类推。<br>以下是一个具体的例子来说明两者的不同：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 指向字符的指针数组</span></span><br><span class="line">    <span class="type">char</span>* str2[] = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 输出 str1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line">    <span class="comment">// 输出 str2 中的每个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[0]: %s\n&quot;</span>, str2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[1]: %s\n&quot;</span>, str2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2[2]: %s\n&quot;</span>, str2[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>str1</code> 是一个包含 “Hello, World!” 字符串的字符数组，而 <code>str2</code> 是一个包含三个字符串指针的数组。</li></ul></li></ol><h3 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C++风格字符串"></a>C++风格字符串</h3><p><strong>string 变量名 &#x3D; “字符串值”</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>###########################完结撒花###########################</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://github.com/tumytime/picx-images-hosting/raw/master/eba59d911c3c8fd32afafd4c0d57d40.70a95u8niw.webp" class="lazyload placeholder" data-srcset="https://github.com/tumytime/picx-images-hosting/raw/master/eba59d911c3c8fd32afafd4c0d57d40.70a95u8niw.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="那嘛一挖---米子哈！！！"/></div><span class="image-caption">那嘛一挖---米子哈！！！</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerlink&quot; title=&quot;整型&quot;&gt;&lt;/a&gt;整型&lt;/h2&gt;&lt;h3 id=&quot;short&quot;&gt;&lt;a href=&quot;#short&quot; class=&quot;headerlink&quot; title=&quot;short&quot;&gt;&lt;/a&gt;shor</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【C++学习】程序基础部分</title>
    <link href="http://tumytime.github.io/2024/08/09/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91Day1/"/>
    <id>http://tumytime.github.io/2024/08/09/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E3%80%91Day1/</id>
    <published>2024-08-09T13:34:17.000Z</published>
    <updated>2024-08-10T03:34:50.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><p><strong>一个基础程序框架：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">//pause:暂停</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="＜iostream＞"><a href="#＜iostream＞" class="headerlink" title="＜iostream＞"></a>＜iostream＞</h3><p><code>#include &lt;stdio.h&gt;</code> 和 <code>#include &lt;iostream&gt;</code> 是C和C++编程语言中用于包含标准输入输出库的头文件语句。该编译指令导致预处理器将iostream文件的内容添加到程序中。#include编译指令导致iostream文件的内容随源<br>代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将<br>取代程序中的代码行#include <iostream>。原始文件没有被修改，而是<br>注意：<br>将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用<br>该文件。<br>下面是这两条语句之间的主要区别：</p><h5 id="1-语言差异"><a href="#1-语言差异" class="headerlink" title="1. 语言差异"></a>1. 语言差异</h5><ul><li><code>#include &lt;stdio.h&gt;</code> 是C语言的标准输入输出库头文件。<code>stdio.h</code> 是 “standard input-output header” 的缩写，它是C语言的一部分。</li><li><code>#include &lt;iostream&gt;</code> 是C++语言的标准输入输出库头文件。<code>iostream</code> 是 “input-output stream” 的缩写，它是C++语言的一部分。</li></ul><h5 id="2-库类型"><a href="#2-库类型" class="headerlink" title="2. 库类型"></a>2. 库类型</h5><ul><li><code>stdio.h</code> 提供的是C语言风格的输入输出函数，例如 <code>printf()</code>, <code>scanf()</code>, <code>fprintf()</code>, <code>fscanf()</code> 等。这些函数通常是非面向对象的，并且它们直接处理字符和字节流。</li><li><code>iostream</code> 提供的是C++语言风格的输入输出流类，例如 <code>std::cout</code>, <code>std::cin</code>, <code>std::cerr</code>, 以及 <code>std::ofstream</code>, <code>std::ifstream</code> 等。这些是面向对象的，提供了更多的功能，例如类型安全和重载操作符。</li></ul><h5 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3. 使用方式"></a>3. 使用方式</h5><ul><li>使用 <code>stdio.h</code> 时，程序员通常需要指定格式化字符串，并且要注意类型匹配，以避免格式化错误或缓冲区溢出。</li><li>使用 <code>iostream</code> 时，类型信息是自动处理的，因为流操作符（如 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>）被重载以支持不同的数据类型。</li></ul><h5 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul><li><code>stdio.h</code> 中的函数通常比C++的iostream库更快，因为iostream库进行了更多的封装和类型检查。然而，现代编译器已经优化了iostream库，使得性能差距不像过去那样显著。</li></ul><h5 id="5-头文件扩展名"><a href="#5-头文件扩展名" class="headerlink" title="5. 头文件扩展名"></a>5. 头文件扩展名</h5><ul><li>注意到 <code>stdio.h</code> 有一个 <code>.h</code> 扩展名，而 <code>iostream</code> 没有。在C++中，标准库的头文件通常不带 <code>.h</code> 扩展名。这是为了区分C和C++的标准库头文件。</li></ul><h5 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6. 命名空间"></a>6. 命名空间</h5><ul><li><code>iostream</code> 中的对象和函数都是在 <code>std</code> 命名空间中的，所以通常需要使用 <code>std::</code> 前缀来访问它们，除非你使用了 <code>using namespace std;</code> 语句。</li><li><code>stdio.h</code> 中的函数通常不需要命名空间前缀。</li></ul><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>以下是如何使用这两个头文件的简单例子：<br><strong>使用 <code>stdio.h</code>:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>iostream</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，<code>#include &lt;stdio.h&gt;</code> 和 <code>#include &lt;iostream&gt;</code> 分别用于C和C++中处理输入输出，它们代表了两种不同的编程范式和风格。在实际使用中，应根据编程语言和项目需求选择合适的头文件。</p><h3 id="using-namespace"><a href="#using-namespace" class="headerlink" title="using namespace"></a>using namespace</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>这个using编译指令使得std名称空间中的所有名称都可用。这是一种偷懒的做法，在大型项目中一个潜在的问题。更好的方法是，只使所需的名称可用，这可以通过使用using声明来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br></pre></td></tr></table></figure><h3 id="使用cout进行C-输出"><a href="#使用cout进行C-输出" class="headerlink" title="使用cout进行C++输出"></a>使用cout进行C++输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>在C++中，用双引号括起的一系列字符叫做字符串，因为它是由若干字符组合而成的。</li><li>&lt;&lt;符号表示该语句将把这个字符串发送给cout；该符号指出了信息流动的路径。</li><li>cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等<br>从概念上看，输出是一个流，即从程序流出的一系列字符。cout对象表示这种流，其属性是在iostream文件中定义的。cout的对象属性包括一个插入运算符（&lt;&lt;），它可以将其右侧的信息插入到流中。<br>因此，与其说程序显示了一条消息，不如说它将一个字符串插入到了输出流中。</li></ul><details open><summary pointer> 初识运算符重载 </summary>              <div class='content'>              <p>如果熟悉C后才开始学习C++，则可能注意到了，插入运算符（&lt;&lt;）看上去就像按位左移运算符（&lt;&lt;），这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。C本身也有一些运算符重载的情况。例如，&amp;符号既表示地址运算符，又表示按位AND运算符；* 既表示乘法，又表示对指针解除引用。这里重要的不是这些运算符的具体功能，而是同一个符号可以有多种含义，而编译器可以根据上下文来确定其含义（这和确定“sound card”中的“sound”与“sound financial basic”中的“sound”的含义是一样的）。C++扩展了运算符重载的概念，允许为用户定义的类型（类）重新定义运算符的含义。</p>              </div>            </details><p>确实，C++中的 <code>std::cout</code> 可以用来输出不同类型的数据，包括整数和字符串。虽然从用户的角度来看，输出数字和字符串似乎没有太大区别，但在幕后，这两者处理方式是不同的。以下是详细解释：</p><ol><li>字符串<ul><li>字符串是由一系列字符组成的序列。在C++中，字符串通常表示为 <code>std::string</code> 类型或者以空字符 <code>\0</code> 结尾的字符数组 <code>char[]</code>。</li><li>当 <code>std::cout</code> 输出字符串时，它会从内存中读取每个字符的编码（通常是ASCII或UTF-8编码），并将其逐个发送到输出设备。</li><li>例如，字符串 <code>&quot;25&quot;</code> 在内存中存储为两个字符：字符 <code>&#39;2&#39;</code> 和字符 <code>&#39;5&#39;</code>，以及一个结束标记 <code>\0</code>。</li></ul></li><li>整数<ul><li>整数在计算机内部以二进制形式存储。例如，整数 <code>25</code> 在内存中以二进制形式表示，可能看起来像 <code>00011001</code>（这取决于具体的系统架构和整数的大小）。</li><li>当 <code>std::cout</code> 输出整数时，它不能直接将二进制数发送到输出设备，因为输出设备期望接收字符编码，而不是二进制数值。</li><li>因此，<code>std::cout</code> 必须将整数转换为字符串形式。这个过程称为数值到字符串的转换，涉及以下步骤：</li></ul><ol><li>计算整数的每一位数字。</li><li>将这些数字转换为对应的字符。</li><li>将这些字符按正确的顺序组合成字符串。</li><li>输出字符串。</li></ol></li><li>自动类型转换<ul><li>在C++中，<code>std::cout</code> 使用操作符重载来处理不同类型的数据。当 <code>std::cout</code> 遇到一个整数时，它会调用一个专门的重载版本的操作符 <code>&lt;&lt;</code>，这个版本知道如何将整数转换为字符串。</li><li>这个转换过程是自动进行的，所以程序员不需要编写额外的代码来将整数转换为字符串。这是C++的面向对象特性之一，允许操作符根据操作数的类型进行不同的操作。</li></ul></li></ol><h3 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h3><p><code>endl</code> 是一个操纵符（manipulator），它在iostream库中被定义为输出一个换行符（通常是 <code>\n</code>），并紧接着刷新输出缓冲区。刷新输出缓冲区意味着缓冲区中的所有数据都会被发送到输出设备（通常是屏幕），确保了这些数据在程序继续执行之前被立即显示。<br><code>\n</code> 是一个转义字符，用于在字符串中插入一个换行符。当使用 <code>\n</code> 时，iostream库会将一个换行符写入输出缓冲区，但不会立即刷新缓冲区。这意味着输出可能暂时留在缓冲区中，直到缓冲区满了或者程序结束，这时缓冲区才会被刷新。</p><h3 id="system-“pause”"><a href="#system-“pause”" class="headerlink" title="system(“pause”);"></a>system(“pause”);</h3><ul><li><p>不加：</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.45lkjet59.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.45lkjet59.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li><p>加上：</p>  <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8dws8r9vq0.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8dws8r9vq0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li></ul><p><code>system(&quot;pause&quot;);</code> 是一个在C或C++程序中常用的语句，它用于暂停程序的执行，直到用户按下任意键。这个语句调用了操作系统的命令行界面来执行 <code>pause</code> 命令。<br>下面是对 <code>system(&quot;pause&quot;);</code> 语句的详细解释：</p><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ul><li><code>system(&quot;pause&quot;);</code> 的主要作用是在程序执行完毕后暂停程序，尤其是在命令行界面（CLI）中运行程序时。这样可以让用户有机会查看程序的输出结果，而不是立即关闭命令行窗口。</li></ul><h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ul><li><code>system</code> 是C和C++标准库中的一个函数，它位于 <code>&lt;cstdlib&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 头文件中。</li><li>当调用 <code>system</code> 函数时，它会创建一个新的进程来执行其参数指定的命令。在 <code>system(&quot;pause&quot;);</code> 中，参数是字符串 <code>&quot;pause&quot;</code>。</li><li>在Windows操作系统中，<code>pause</code> 命令会暂停命令行进程，并显示消息 <code>&quot;Press any key to continue . . .&quot;</code>。用户必须按下任意键才能继续执行程序或关闭命令行窗口。</li></ul><h5 id="3-跨平台问题"><a href="#3-跨平台问题" class="headerlink" title="3. 跨平台问题"></a>3. 跨平台问题</h5><ul><li><code>system(&quot;pause&quot;);</code> 主要用于Windows操作系统。在Unix-like系统（如Linux或macOS）中，<code>pause</code> 命令通常不存在，因此这条语句在这些系统中不会按预期工作。</li><li>为了实现跨平台兼容性，通常建议使用其他方法来暂停程序，例如在Unix-like系统中使用 <code>getchar();</code> 来实现类似的效果。</li></ul><h5 id="4-安全性和性能"><a href="#4-安全性和性能" class="headerlink" title="4. 安全性和性能"></a>4. 安全性和性能</h5><ul><li>使用 <code>system</code> 函数通常不被认为是安全的，因为它会执行传递给它的任何命令，这可能导致安全漏洞，尤其是当命令包含用户输入时。</li><li>调用 <code>system</code> 函数创建新进程可能会影响程序的性能，因为它涉及到操作系统的进程管理。</li></ul><h5 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. 替代方案</h5><ul><li>如果你只是想等待用户按键，而不是关闭命令行窗口，可以使用以下代码作为替代方案，它具有更好的跨平台兼容性：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Press any key to continue . . .&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();  <span class="comment">// 等待用户按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者，在Unix-like系统中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press any key to continue . . .\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();  <span class="comment">// 等待用户按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这些替代方案不需要调用 <code>system</code> 函数，因此它们更安全且更适合跨平台使用。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>给一段指定的内存空间起名，方便操作这段内存</strong>（一下子就清楚了）<br>使用声明语句来指出存储类型并提供位置标签。<br><strong>变量存在的意义就是方便我们管理内存空间</strong></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>用于记录程序中不可更改的数据</strong><br><strong>定义常量的两种方式：</strong></p><ol><li>#define 宏常量： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br></pre></td></tr></table></figure></li><li>const修饰的变量：<br> 在变量定义前加const</li></ol><p><strong>Q:#define day 7这样子day代表的7是什么数据类型</strong><br>在C或C++语言中，使用 <code>#define</code> 预处理器指令来定义宏。宏定义 <code>#define day 7</code> 不会指定数据类型，它仅仅是一个文本替换。当编译器看到 <code>day</code> 时，它会在编译前将其替换为 <code>7</code>。<br>由于宏只是简单的文本替换，<code>day</code> 代表的 <code>7</code> 在编译后的代码中并没有特定的数据类型。它的数据类型取决于它被使用的上下文。例如：</p><ul><li>如果 <code>day</code> 被用在需要整数的地方，它将被当作整数处理。</li><li>如果 <code>day</code> 被用在需要浮点数的地方，它可能会被隐式转换成浮点数。<br>下面是一些使用 <code>day</code> 的例子，以及它如何根据上下文被解释：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> days = day;    <span class="comment">// day 被当作整数</span></span><br><span class="line">    <span class="type">float</span> days_float = day;  <span class="comment">// day 被隐式转换成浮点数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer: %d\n&quot;</span>, days);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, days_float);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>day</code> 被用作整数 <code>int</code> 类型的值，也被用作 <code>float</code> 类型的值。在编译时，预处理器将 <code>day</code> 替换为 <code>7</code>，然后编译器根据变量声明决定 <code>7</code> 的数据类型。在第一个例子中，<code>7</code> 是 <code>int</code> 类型的，而在第二个例子中，<code>7</code> 被隐式转换为 <code>float</code> 类型。</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2vensn8i5n.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2vensn8i5n.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>C++（和C）有一项不寻常的特性—可以连续使用赋值运算符。例如，下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=b=c=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>赋值将从右向左进行。</strong><br>首先，2被赋给c，然后c的值（2）被赋给b，然后b的值被赋给a；</p><h2 id="使用cin"><a href="#使用cin" class="headerlink" title="使用cin"></a>使用cin</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; carrots;</span><br></pre></td></tr></table></figure><p>从这条语句可知，信息从cin流向carrots。显然，对这一过程有更为正式的描述。就像C++将输出看作是流出程序的字符流一样，它也将输入看作是流入程序的字符流。iostream文件将cin定义为一个表示这种流的对象。输出时，&lt;&lt;运算符将字符串插入到输出流中；输入时，cin使用&gt;&gt;运算符从输入流中抽取字符。通常，需要在运算符右侧提供一个变量，以接收抽取的信息（符号&lt;&lt;和&gt;&gt;被选择用来指示信息流的方向）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础框架&quot;&gt;&lt;a href=&quot;#基础框架&quot; class=&quot;headerlink&quot; title=&quot;基础框架&quot;&gt;&lt;/a&gt;基础框架&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一个基础程序框架：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://tumytime.github.io/categories/C/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【第一个项目】Cybery第一天（24.7.24）</title>
    <link href="http://tumytime.github.io/2024/07/24/%E3%80%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E3%80%91Cybery%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%8824-7-24%EF%BC%89/"/>
    <id>http://tumytime.github.io/2024/07/24/%E3%80%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E3%80%91Cybery%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%8824-7-24%EF%BC%89/</id>
    <published>2024-07-24T06:48:00.000Z</published>
    <updated>2024-07-24T07:57:45.849Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>很早就跟<a href="https://snowmiku-home.top/">小葱酱</a>说好了要一起做一个项目，我还是负责视觉和ai，今天就打算把我的部分按我的想法开始做咯~ 现在初步设想我这边是以树莓派为中心，主要程序展现在树莓派的一个显示屏上，显示屏上的程序包含live2d和一些功能卡片(可触摸)，外接摄像头能传感器完成与用户的交互和物体识别。暂时把这个项目叫做Cybery咯</p></div><h2 id="step1-学习live2d操作"><a href="#step1-学习live2d操作" class="headerlink" title="step1-学习live2d操作"></a>step1-学习live2d操作</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/pitao.1hs419iagd.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/pitao.1hs419iagd.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>我是有一个皮套的（是公皮，不知道有没有同学能找到我的套皮小号哈哈哈哈哈），可以用vts面捕，但是要做东西的话，还是得看一下怎么直接控制比较好</p><p>用下面这个教程比较好:</p><div class="tagLink"><a class="link-card" title="基于Qt的Live2D模型显示以及控制" href="https://blog.csdn.net/y123456wydhckd/article/details/134899183?ops_request_misc=&request_id=&biz_id=102&utm_term=live2d&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-134899183.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187"><span class="link-card-backdrop" style="background-image: url(https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center)"></span><div class="left"><img src="https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/direct/3f5a82e8d0d44219960008e4142ad4af.png#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">基于Qt的Live2D模型显示以及控制</p><p class="url">https://blog.csdn.net/y123456wydhckd/article/details/134899183?ops_request_misc=&request_id=&biz_id=102&utm_term=live2d&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-134899183.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187</p></div></a></div><h3 id="Cubism-SDK-for-Native下载"><a href="#Cubism-SDK-for-Native下载" class="headerlink" title="Cubism SDK for Native下载"></a>Cubism SDK for Native下载</h3><p>官网下载基本下不了(反正我这里是这样)，可以在GitHub上下载</p><div class="tagLink"><a class="link-card" title="CubismSdkForNative-5-r.1" href="https://github.com/andforce/CubismSdkForNative-5-r.1"><span class="link-card-backdrop" style="background-image: url(https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png)"></span><div class="left"><img src="https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png" class="lazyload placeholder" data-srcset="https://github.com/andforce/CubismSdkForNative-5-r.1/blob/main/logos.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">CubismSdkForNative-5-r.1</p><p class="url">https://github.com/andforce/CubismSdkForNative-5-r.1</p></div></a></div><p>然后根据上面的教程运行一个demo</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4n7m08w4ed.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4n7m08w4ed.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;很早就跟&lt;a href=&quot;https://snowmiku-home.top/&quot;&gt;小葱酱&lt;/a&gt;说好了要一起做一个项目，我还是负责视觉和ai，今天就打算把我的部分按我的想法开始做咯~ 现在初步设想我这边是以树莓派为中心，主要程序</summary>
      
    
    
    
    <category term="树莓派" scheme="http://tumytime.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="树莓派" scheme="http://tumytime.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Linux" scheme="http://tumytime.github.io/tags/Linux/"/>
    
    <category term="live2d" scheme="http://tumytime.github.io/tags/live2d/"/>
    
  </entry>
  
  <entry>
    <title>电赛笔记一【配置树莓派opencv&amp;&amp;c++环境】</title>
    <link href="http://tumytime.github.io/2024/07/21/%E7%94%B5%E8%B5%9B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://tumytime.github.io/2024/07/21/%E7%94%B5%E8%B5%9B%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2024-07-21T07:14:03.000Z</published>
    <updated>2024-07-24T12:46:15.959Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>树莓派型号：pi5，8G</p></div><h2 id="配置树莓派opencv和c-环境"><a href="#配置树莓派opencv和c-环境" class="headerlink" title="配置树莓派opencv和c++环境"></a>配置树莓派opencv和c++环境</h2><p><strong>这个亲测有效！！</strong></p><div class="tagLink"><a class="link-card" title="Ubuntu 20.04搭建OpenCV 4.5.0 & C++环境" href="https://blog.csdn.net/weixin_44796670/article/details/115900538"><span class="link-card-backdrop" style="background-image: url(https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png)"></span><div class="left"><img src="https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/hamburger.969mywtn31.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Ubuntu 20.04搭建OpenCV 4.5.0 & C++环境</p><p class="url">https://blog.csdn.net/weixin_44796670/article/details/115900538</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;树莓派型号：pi5，8G&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置树莓派opencv和c-环境&quot;&gt;&lt;a href=&quot;#配置树莓派opencv和c-环境&quot; class=&quot;headerlink&quot; title=&quot;配置树莓派openc</summary>
      
    
    
    
    <category term="树莓派" scheme="http://tumytime.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="c++" scheme="http://tumytime.github.io/tags/c/"/>
    
    <category term="树莓派" scheme="http://tumytime.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="电赛" scheme="http://tumytime.github.io/tags/%E7%94%B5%E8%B5%9B/"/>
    
    <category term="opencv" scheme="http://tumytime.github.io/tags/opencv/"/>
    
    <category term="机器视觉" scheme="http://tumytime.github.io/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    <category term="cmake" scheme="http://tumytime.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>videocapture的bug</title>
    <link href="http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/"/>
    <id>http://tumytime.github.io/2024/06/16/videocapture%E7%9A%84bug/</id>
    <published>2024-06-16T03:45:42.000Z</published>
    <updated>2024-06-16T03:45:54.974Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;  &lt;body class=&quot;nodata &quot; style=&quot;&quot;&gt;         &lt;main style=&quot;width:100%&quot;&gt;      &lt;div class=&quot;blog-content-box&quot;&gt;         &lt;div class=&quot;article-title-box&quot;&gt;            &lt;h1 class=&quot;title-article&quot; id=&quot;articleContentId&quot;&gt;opencv读取摄像头不是实时的处理方法&lt;/h1&gt;        &lt;/div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css&quot;&gt;                     &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; style=&quot;display: none;&quot;&gt;                    &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot; style=&quot;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&quot;&gt;&lt;/path&gt;                &lt;/svg&gt;                &lt;pre data-index=&quot;0&quot; class=&quot;set-code-show prettyprint&quot;&gt;&lt;code class=&quot;prism language-python has-numbering&quot; onclick=&quot;mdcp.copyCode(event)&quot; style=&quot;position: unset;&quot;&gt;cap &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cv2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;VideoCapture&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> <h2><a name="t0"></a><a id="___5"></a>读取的不是实时的画面 ，存在延迟 怎么处理</h2> <blockquote>  <p>如果你使用的是<a href="https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=OpenCV%E5%BA%93&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;OpenCV库\&quot;}&quot;}" data-tit="OpenCV库" data-pretit="opencv库">OpenCV库</a>，你可以通过将缓冲区大小设置为更小的值来减小延迟。默认情况下，缓冲区大小是16，但可以通过在cv2.VideoCapture()中传递参数来更改。例如：</p> </blockquote> <pre data-index="1" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><div class="hljs-button &#123;2&#125;" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> <blockquote>  <p>这将把缓冲区大小减小到1，从而减小延迟。但是，如果你将缓冲区大小设置得太小，你可能会遇到画面卡顿或丢帧的问题。</p> </blockquote> <p>另一种方式是使用多线程或异步处理来实现更快的画面更新。你可以在一个线程中读取摄像头的帧，并将它们传递到另一个线程或进程中进行处理和显示。这将使你能够更快地处理帧并减少延迟。但是，这需要更多的编程和计算资源，并可能会增加代码的复杂性。</p> <h2><a name="t1"></a><a id="OpenCV_19"></a>下面是一个基本的多线程处理OpenCV视频帧的例子：</h2> <pre data-index="2" class="prettyprint set-code-show"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">VideoCapture</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span>src<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_BUFFERSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>grabbed<span class="token punctuation">,</span> self<span class="token punctuation">.</span>frame <span class="token operator">=</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>read_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><pre><code>&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;VideoCapture already started&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; threading&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Thread&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;update&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; args&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;start&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; grabbed            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;read_lock&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;        grabbed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grabbed        frame &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frame    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; grabbed&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; frame&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;started &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;join&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__exit__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exc_value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; traceback&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;    self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;release&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;</code></pre><p><span class="token keyword">if</span> <strong>name</strong> <span class="token operator">&#x3D;&#x3D;</span> <span class="token string">‘<strong>main</strong>‘</span><span class="token punctuation">:</span><br>    cap <span class="token operator">&#x3D;</span> VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><br>        grabbed<span class="token punctuation">,</span> frame <span class="token operator">&#x3D;</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token keyword">if</span> <span class="token keyword">not</span> grabbed<span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">‘frame’</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><br>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">&#x3D;&#x3D;</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">‘q’</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">break</span><br>    cap<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><br>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li></ul></pre> <blockquote>  <p>这个例子使用了一个<a href="https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=VideoCapture&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;VideoCapture\&quot;}&quot;}" data-tit="VideoCapture" data-pretit="videocapture">VideoCapture</a>类，该类在一个线程中不断读取摄像头帧，并将它们保存在一个共享的grabbed和frame变量中。在主程序中，我们通过调用start()方法来启动线程，然后不断读取帧并在窗口中显示它们，直到用户按下’q’键退出。最后，我们调用stop()方法来停止线程并释放资源。</p> </blockquote> <p>需要注意的是，这个例子仅仅是一个基本的框架，你可能需要对其进行修改和扩展以适应你的具体应用场景。例如，你可以添加一个另一个线程来处理帧，然后显示处理后的结果，以此来减少延迟。</p>                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_26696715/article/details/129686980&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-f23dff6052.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-c216769e99.css" rel="stylesheet">        </div>            </div>             <pre><code>          &lt;/main&gt;        &lt;/body&gt;   &lt;/html&gt;        </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++多线程</title>
    <link href="http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://tumytime.github.io/2024/06/03/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-06-03T05:30:23.000Z</published>
    <updated>2024-06-14T11:54:39.061Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)</p></div><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>当我们谈论多线程时，可以想象成一个人同时在做多个事情，就像一个人既可以同时吃饭又可以同时写作业一样。在C++中，使用多线程可以让我们的程序同时执行多个任务，提高程序的效率和性能。</p><p>首先，让我们用一个简单的例子来理解多线程。假设你有一个厨房，里面有一个厨师在煮面条，一个厨师在炒菜，还有一个服务员在端菜。这就相当于一个有多个线程的程序，每个线程负责不同的任务。</p><p>在C++中，我们可以使用 <code>&lt;thread&gt;</code> 头文件来创建和管理线程。首先，我们需要定义一个函数，在这个函数中包含我们希望线程执行的任务。然后，我们使用 <code>std::thread</code> 类来创建线程并指定要执行的函数。</p><p>让我们来看一个示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，作为线程的入口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程，并指定要执行的函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行自己的任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程 t1 执行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个简单的函数 <code>printMessage</code>，并在主函数中创建了一个新线程 <code>t1</code>，让它执行这个函数。同时，主函数也会继续执行，输出 “Hello from main thread!”。最后我们使用 <code>join()</code> 函数等待线程 <code>t1</code> 的执行完成。</p><p>这样，就实现了一个简单的多线程程序。通过合理地使用多线程，我们可以更高效地利用计算机的资源，加快程序的运行速度。当然，在实际编程中，还需要考虑线程之间的同步、互斥访问等问题，以保证程序的正确性和稳定性。</p><h3 id="std-thread-t1-printMessage-代表着线程开始执行吗"><a href="#std-thread-t1-printMessage-代表着线程开始执行吗" class="headerlink" title="std::thread t1(printMessage);代表着线程开始执行吗"></a>std::thread t1(printMessage);代表着线程开始执行吗</h3><p>是的，当你创建一个 <code>std::thread</code> 对象并传入要执行的函数，线程就会开始执行这个函数。在你的例子中，<code>std::thread t1(printMessage);</code>这一行代码就代表着线程开始执行 <code>printMessage</code> 函数。这意味着在运行时，会产生一个新的线程来执行 <code>printMessage</code> 函数中的代码，同时主线程会继续执行后面的代码。</p><p>但需要注意的是，线程的启动并不是立即执行 <code>printMessage</code> 函数中的代码，而是在<code>std::thread</code> 对象被创建之后才会执行。如果立即调用 <code>join()</code> 函数，主线程会等待新线程执行完毕再继续往下执行。这种方式保证了线程的同步执行。</p><p>因此，在上面提供的示例代码中，<code>std::thread t1(printMessage);</code>这一行代码会使得新线程开始执行 <code>printMessage</code> 函数，而主线程会继续执行紧随其后的代码，直到遇到 <code>t1.join();</code>。</p><p>在C++中，如果我们使用std::thread来创建线程，线程的启动确实不会立即执行线程函数中的代码。当我们创建一个std::thread对象，指定要执行的线程函数，并调用该std::thread对象的构造函数时，线程对象就会被创建，但线程函数的代码并不会立即执行。实际上线程的实际执行时机取决于操作系统的调度器，在合适的时机会开始执行线程函数。</p><p>如果在主线程中立即调用新线程的join()函数，主线程将会被阻塞，直到新线程的执行完成。这种方式确保了线程的同步执行，即主线程会等待新线程执行完毕后才会继续往下执行。在这种情况下，主线程和新线程是同步执行的，主线程起到了等待和协调的作用。</p><p>总结：通过调用join()函数实现线程同步执行的流程是这样的，先创建新的线程对象，然后调用join()函数使得主线程等待新线程的执行完成，待新线程执行完毕后，主线程才继续往下执行。这种方式保证了线程的同步执行，特别适用于需要新线程执行完毕后才能继续主线程操作的场景。</p><h2 id="进阶实例-互斥锁"><a href="#进阶实例-互斥锁" class="headerlink" title="进阶实例(互斥锁)"></a>进阶实例(互斥锁)</h2><p>让我们来看一个稍微复杂一点的多线程例子，考虑一个生产者-消费者模型。在这个例子中，有一个生产者线程负责生产数据，然后将数据发送给一个缓冲区，同时一个消费者线程从缓冲区中取出数据进行消费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产数据的耗时操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            buffer.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> data = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个互斥锁（std::mutex）来保护共享的数据结构（队列buffer），生产者线程往队列中写入数据，消费者线程从队列中读取数据。通过条件变量（std::condition_variable）实现了生产者与消费者之间的同步。</p><p>生产者不断地在队列中插入数据，消费者则等待队列中有数据后进行消费。当队列中有数据时，消费者线程被唤醒，消费数据并输出，直至生产者生产完所有数据。整个过程利用互斥锁和条件变量实现了线程之间的同步操作，确保了数据的正确生产和消费。</p><ol><li><p><strong>前三行意思</strong></p><p> 这三行代码声明了一个整型队列 <code>buffer</code>，一个互斥锁 <code>mtx</code> 和一个条件变量 <code>cv</code>。 </p><ul><li><p><code>std::queue&lt;int&gt; buffer;</code>：这行代码定义了一个STL队列，其中存储整型数据。在生产者和消费者模型中，<code>buffer</code>用于存储生产者生成的数据，在生产者线程将数据写入队列，消费者线程从队列中取出数据进行消费。</p></li><li><p><code>std::mutex mtx;</code>：这行代码定义了一个互斥锁，用于在多线程环境中对共享数据结构进行访问控制。在此例中，<code>mtx</code> 用于保护队列 <code>buffer</code>，确保在任一时刻只有一个线程可以访问队列。</p></li><li><p><code>std::condition_variable cv;</code>：这行代码定义了一个条件变量，用于线程间的同步。在此例中，<code>cv</code> 用于通知消费者线程有新的数据可用于消费。消费者线程会通过 <code>wait()</code> 来等待生产者通知，一旦有数据可用，它会被 <code>notify_one()</code> 通知可以继续执行。</p></li></ul><p> 这些机制共同构成了一个生产者-消费者模型，确保在多线程环境下数据的安全访问和同步处理。</p></li><li><p><strong>为什么确保在任一时刻只有一个线程可以访问队列</strong><br> 在多线程环境中，如果不对共享数据结构（比如队列）进行保护，就可能导致数据竞争（Data Race）的问题。数据竞争指的是多个线程同时访问共享数据，其中至少一个线程对数据进行写操作，而其他线程进行读或写操作，从而导致未定义行为。对于队列这样的数据结构，如果没有互斥访问，会导致以下问题：</p><ul><li><p>不确定性：多个线程同时对队列进行操作，可能造成队列中数据的乱序或丢失，导致程序逻辑错误。</p></li><li><p>数据损坏：当一个线程正在修改队列中的数据时，另一个线程可能同时读取或修改这些数据，造成意外的数据损坏。</p></li><li><p>死锁：如果多个线程同时尝试对队列进行读写操作而没有恰当的同步机制，可能会出现死锁情况，使得程序无法继续执行。</p></li></ul><p> 因此，通过使用互斥锁（<code>mutex</code>）来保护队列，在任一时刻只允许一个线程访问队列，可以确保在多线程环境下数据的安全访问，避免数据竞争和可能导致的问题。</p></li><li><p><strong>什么是死锁</strong><br> 死锁（Deadlock）是指在并发系统中，两个或多个进程（线程）因争夺共享资源而进入一种互相等待的状态，导致它们都无法继续执行下去的情况。在死锁情况下，每个进程都在等待其他进程释放资源，而同时又不愿意主动释放自己当前已经占有的资源，从而形成了一种僵局。死锁是多线程编程中常见的并发问题，需要通过合理的设计和实现来避免和解决死锁问题。</p></li><li><p><strong>std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#x2F;&#x2F; 模拟生产数据的耗时操作</strong></p><p> 这行代码是使用C++标准库提供的线程库<code>&lt;thread&gt;</code>中的<code>std::this_thread::sleep_for</code>函数，用来模拟在生产数据过程中的耗时操作。让我们来详细解释一下这行代码的作用：</p><ul><li><p><code>std::this_thread::sleep_for</code>：这是C++标准库中用于线程操作的静态成员函数，允许当前线程休眠一段时间。因为是<code>this_thread</code>所以是当前线程。</p></li><li><p><code>std::chrono::milliseconds(500)</code>：这里使用<code>std::chrono::milliseconds</code>来创建一个表示时间间隔的对象，参数为500，表示500毫秒（即0.5秒）的时间间隔。<code>std::chrono</code>是C++标准库提供的日期和时间库，用于处理时间相关的操作。</p></li><li><p><code>// 模拟生产数据的耗时操作</code>：这是一行注释，说明了这行代码的目的，即模拟在生产数据过程中的耗时操作。通常在生产数据或其他需要等待的操作中，为了模拟真实场景的延迟，会使用类似的休眠操作来延迟线程的执行。</p></li></ul><p> 因此，这行代码的作用是让当前线程休眠500毫秒，模拟生产数据过程中的耗时操作，以便更好地测试和理解程序的行为。</p></li><li><p><strong>std::lock_guard &lt; std::mutex &gt; lock(mtx);</strong></p><p> <code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>是C++中使用RAII机制来管理互斥锁（<code>std::mutex</code>）的典型语法格式。这行代码的作用是创建一个<code>lock_guard</code>对象并用其构造函数锁住一个<code>std::mutex</code>对象<code>mtx</code>。</p><p> 具体解释如下：</p><ul><li><code>std::lock_guard</code>是一个模板类，用于管理锁对象（互斥锁）。它会在构造时锁住给定的互斥锁，在析构时解锁互斥锁，实现了RAII机制。</li><li><code>&lt;std::mutex&gt;</code>是模板参数，表示<code>std::lock_guard</code>将要管理的互斥锁的类型是<code>std::mutex</code>。</li><li><code>lock</code>是<code>std::lock_guard</code>对象的名称，可以根据需要命名。</li><li><code>(mtx)</code>表示用<code>mtx</code>（一个名为<code>mtx</code>的<code>std::mutex</code>对象）来初始化<code>lock_guard</code>对象，即在构造<code>lock_guard</code>对象时锁住<code>mtx</code>。</li></ul><p> <code>std::lock_guard</code>是C++标准库提供的一个RAII（资源获取即初始化）风格的互斥量封装类，通过它可以在一个作用域中保持互斥锁的持有状态。在这段代码中，<code>std::lock_guard&lt;std::mutex&gt; lock(mtx);</code>的作用是使用互斥量<code>mtx</code>对临界区进行加锁，确保对共享数据结构<code>buffer</code>的访问是线程安全的。让我们来详细解释其作用：</p><ul><li><p><strong>RAII机制</strong>：RAII（Resource Acquisition Is Initialization）是一种C++编程范式，它通过对象的生命周期来管理资源的获取和释放，确保资源在对象构造时被正确获取，而在对象析构时被自动释放。这种机制的核心思想是利用局部对象的生命周期控制资源的获取和释放，从而确保资源的正确管理，提高代码的可靠性和可维护性。</p><p>  下面是RAII机制的工作原理和优势：</p><ol><li><p><strong>资源获取即初始化</strong>：当一个对象被创建时，同时获取所需的资源，例如内存、文件句柄、互斥锁等，这样资源的获取和初始化是统一的操作。</p></li><li><p><strong>资源的自动释放</strong>：当对象离开其作用域时（比如函数返回、作用域结束等），其析构函数会被调用，负责释放已获取的资源，无论是正常执行还是异常发生，资源都会被正常释放。</p></li><li><p><strong>避免资源泄漏和确保资源管理</strong>：通过RAII机制，程序员无需手动管理资源的获取和释放，减少了因忘记释放资源而导致的内存泄漏或资源泄漏问题。</p></li><li><p><strong>异常安全性</strong>：RAII可确保在异常发生时，资源能够被正确释放，避免资源泄漏，同时保证程序的安全性。</p></li><li><p><strong>提高代码的可维护性和可读性</strong>：RAII使资源管理的逻辑更加清晰明了，代码更易于理解和维护，同时降低了在多线程环境下出现的死锁等问题。</p></li></ol><p>  在C++中，标准库中的智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等）和锁（<code>std::lock_guard</code>、<code>std::unique_lock</code>等）都是基于RAII机制设计的。通过合理利用RAII机制，可以有效管理资源，提高代码的健壮性和可靠性。</p></li><li><p><strong>加锁</strong>：当<code>std::lock_guard</code>对象<code>lock</code>被创建时，它会在构造函数中对互斥量<code>mtx</code>进行加锁操作，即锁住<code>mtx</code>。这样就确保了在<code>lock_guard</code>对象的作用域内（在这个括号内）对<code>buffer</code>的访问是受到保护的，其他线程无法同时修改<code>buffer</code>的内容，避免了数据竞争和不一致性。<code>在这个括号内</code>指的是<code>std::lock_guard</code>对象<code>lock</code>的作用域范围，即<code>lock</code>对象的生命周期。在C++中，作用域用花括号<code>&#123;&#125;</code>表示，也叫做代码块。当<code>std::lock_guard</code>对象<code>lock</code>的作用域范围结束（即超出了花括号的范围），该对象的析构函数会被调用，从而自动释放锁。这种方式确保了在<code>lock</code>对象的作用域内，互斥锁被保持，从而保护了共享资源（如<code>buffer</code>）的访问并避免了数据竞争和不一致性的问题。</p></li></ul><p> 因此，通过在花括号内创建<code>std::lock_guard</code>对象并锁住互斥量，可以确保只有一个线程能够访问或修改被保护的共享资源，从而提高多线程程序的安全性。</p><ul><li><strong>解锁</strong>：当<code>lock_guard</code>对象的作用域结束时，会调用其析构函数，在析构函数中会自动解锁互斥量<code>mtx</code>，即释放<code>mtx</code>的锁，使得其他线程可以访问共享资源。</li></ul><p> 通过使用<code>std::lock_guard</code>和互斥量，可以简化了对临界区的加锁和解锁过程，并且可以避免因为忘记解锁导致的死锁情况。这样的操作保证了对临界区资源的访问是互斥的，确保了多线程环境下的数据安全性。</p></li><li><p><strong>cv.notify_one();</strong><br> 在多线程编程中，<code>cv.notify_one()</code> 是用来通知等待在条件变量上的某个线程继续执行的函数。当某个线程调用 <code>cv.wait()</code> 方法并在条件变量上等待时，其他线程可以通过调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来通知等待的线程可以继续执行。</p><p> 具体来说，<code>cv.notify_one()</code> 会唤醒在条件变量上等待的一个线程（如果有的话），让其可以从等待状态中醒来并继续执行。如果没有线程在条件变量上等待，那么调用 <code>cv.notify_one()</code> 也不会有任何效果。</p><p> 在多线程协作中，通常会结合条件变量和互斥量来实现线程之间的同步操作。当一个线程修改了共享数据，并希望通知其他线程有关此数据的改变时，可以使用条件变量来实现线程之间的同步通信。通常的流程是，先获得互斥锁，然后修改共享数据，再通知等待在条件变量上的线程，最后释放互斥锁。</p><p> 在这段示例代码中，生产者线程和消费者线程通过条件变量 <code>cv</code> 和互斥量 <code>mtx</code> 实现了线程之间的同步通信。生产者线程通过 <code>notify_one()</code> 方法通知消费者线程，告知其有新的数据可以被消费。具体来说，<code>cv.notify_one()</code> 的作用是：</p><ol><li>当生产者线程生产了一个数据后（通过 <code>buffer.push(i)</code>），它会立即通知等待在条件变量 <code>cv</code> 上的消费者线程。</li><li>在消费者线程中，当它通过 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 进入等待状态时，会自动释放 <code>mtx</code> 互斥量并等待，直到生产者线程调用 <code>cv.notify_one()</code> 来唤醒它。</li><li>一旦消费者线程被唤醒，它会重新获取 <code>mtx</code> 互斥量并继续执行，从 <code>buffer</code> 中取出数据消费。</li><li>生产者线程每生产一个数据，就会唤醒一个等待的消费者线程。如果有多个消费者线程在等待，只有一个会被唤醒。</li></ol><p> 综上所述，<code>cv.notify_one()</code> 的作用是唤醒一个等待在条件变量上的线程，用来提示该线程可以继续执行，适用于协调多线程之间的操作顺序和数据传递。</p></li><li><p><strong>为什么一个用std::lock_guard一个用std::unique_lock</strong><br> 在上述代码中，<code>producer()</code> 函数使用了 <code>std::lock_guard</code> 来锁定互斥量，而 <code>consumer()</code> 函数则使用了 <code>std::unique_lock</code>。这种选择并非绝对，而是根据不同的需求和情境来决定使用哪种锁定方式。</p><ol><li><strong><code>std::lock_guard</code> 在 producer 函数中的使用：</strong></li></ol><ul><li>在 <code>producer()</code> 函数中，生产者生产数据到缓冲区，并在数据生产完成后立即释放互斥量。由于在生产者生产完数据后就会释放互斥量，因此使用 <code>std::lock_guard</code> 而不是 <code>std::unique_lock</code> 更加简洁和合适。<code>std::lock_guard</code> 自动锁定互斥量，并在作用域结束时自动释放互斥量，非常适合这种简单的锁定和释放情况。</li></ul><ol start="2"><li><strong><code>std::unique_lock</code> 在 consumer 函数中的使用：</strong></li></ol><ul><li>在 <code>consumer()</code> 函数中，消费者需要等待缓冲区中有数据可消费时才能继续执行。为了支持在等待期间手动解锁互斥量并等待条件变量，这里使用了 <code>std::unique_lock</code>。<code>std::unique_lock</code> 提供了更灵活的加锁和解锁操作，同时支持条件变量的等待。在等待缓冲区有数据可消费时，我们使用 <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 来等待条件变量满足。</li></ul><p> 综上所述，选择使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 取决于具体的应用场景和需求。在简单的自动锁定和释放互斥量情况下，可以使用 <code>std::lock_guard</code>；而在需要更多灵活性和条件变量支持的情况下，可以选择使用 <code>std::unique_lock</code>。在生产者消费者模型中，生产者和消费者可能有不同的需求，因此可以根据具体情况选择不同的锁定方式。</p></li><li><p><strong>cv.wait(lock, [] { return !buffer.empty(); });</strong></p><p> <code>cv.wait(lock, [] &#123; return !buffer.empty(); &#125;);</code> 这行代码是在<code>consumer()</code>函数中使用条件变量等待的部分。让我们详细解释这段代码的作用和具体执行流程：</p><ol><li><p><code>cv.wait(lock, condition)</code>：这是条件变量 <code>cv</code> 的等待函数调用。在这里，<code>lock</code> 是一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，通过将 <code>lock</code> 传递给 <code>cv.wait</code>，会在等待期间将互斥量解锁，以便其他线程可以在该互斥量上执行操作。<code>condition</code> 是一个 lambda 函数，用于指定等待条件。在这种情况下，<code>cv.wait</code>会在等待期间检查 lambda 函数返回的布尔值，只有在 lambda 函数返回 <code>true</code> 时才会继续执行。</p></li><li><p><code>[] &#123; return !buffer.empty(); &#125;</code>：这是一个 lambda 函数，它检查 <code>buffer</code> 是否为空。条件变量的 <code>wait</code> 操作依赖于用户提供的条件函数。在这里，条件函数检查 <code>buffer</code> 是否为空，如果为空，则条件为假， <code>cv.wait</code> 会一直等待，直到条件变为真。一旦条件为真，<code>cv.wait</code> 将继续执行，即互斥量被重新锁定，并且线程继续执行下去。</p></li><li><p>执行流程：</p><ul><li>当消费者线程开始执行 <code>consumer()</code> 函数时，首先会创建一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象 <code>lock</code>，该对象在实例化时会锁定其关联的互斥量 <code>mtx</code>。</li><li>接着，消费者线程调用 <code>cv.wait(lock, condition)</code>，这会导致线程释放互斥量的锁并等待，直到<code>condition</code>返回 <code>true</code>。</li><li>在等待过程中，其他线程可以获得互斥量的锁并修改共享数据，但由于条件未满足，消费者线程会一直保持等待状态。</li><li>当生产者线程向 <code>buffer</code> 中加入数据并调用 <code>cv.notify_one()</code> 通知时，条件 <code>!buffer.empty()</code> 变为真，这会导致条件变量通知消费者线程继续执行。</li><li>消费者线程被唤醒后，会重新获得互斥量的锁，这时可以安全地从 <code>buffer</code> 中取出数据进行消费，然后继续执行后续的操作。</li></ul></li></ol><p> 总之，通过使用条件变量和 lambda 函数等待特定条件，可以实现线程间的同步和协调，确保消费者在有数据可消费时才执行消费操作，从而有效避免了竞态条件和数据不一致的问题。</p></li><li><p><strong>lambda 表达式</strong><br> 用于定义函数对象：</p><ol><li><p><code>[]</code>：lambda 表达式的开头以一对方括号开始。在这里，<code>[]</code> 表示 lambda 表达式不捕获任何外部变量。这意味着 lambda 表达式只能访问传递给它的参数，而不能访问外部作用域的变量。</p></li><li><p><code>&#123;&#125;</code>：lambda 表达式的主体使用一对大括号来定义，在大括号内部是 lambda 表达式的具体实现。</p></li></ol></li></ol><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在多线程编程中，为了避免多个线程同时访问共享资源而引起的竞争条件和数据不一致性问题，我们使用互斥锁（Mutex，全称Mutual Exclusion）。互斥锁是一种同步原语，它允许线程在进入临界区（对共享资源操作的临界区域）前先获取锁，执行完后再释放锁，从而确保在同一时刻只有一个线程能进入临界区进行操作。</p><p>详细解释互斥锁包括以下几点：</p><ol><li><p><strong>锁的状态</strong>: 互斥锁有两种状态，分别是锁定（locked）和解锁（unlocked）。线程在进入临界区之前需要先获取锁（即将锁定状态设定为locked），执行完后再释放锁（将状态设定为unlocked）。</p></li><li><p><strong>互斥性</strong>: 互斥锁的特性确保了同一时刻只有一个线程能够获取锁，其他线程需要等待当前持有锁的线程释放锁后才能继续执行。这样可以避免多个线程同时访问共享资源导致的数据竞争和不一致性问题。</p></li><li><p><strong>使用方法</strong>: 在多线程代码中使用互斥锁时，一般会使用<code>std::mutex</code>或类似的互斥锁类型。典型的用法是在临界区开始之前调用<code>lock()</code>方法获取锁，在临界区结束后调用<code>unlock()</code>方法释放锁。</p></li><li><p><strong>死锁</strong>: 如果在多线程代码中使用互斥锁不当，可能会导致死锁（Deadlock）的问题。死锁指的是多个线程相互等待对方释放资源而无法继续执行的情况，因此在使用互斥锁时要注意避免造成死锁。</p></li></ol><p>总之，互斥锁是一种重要的同步工具，用于在多线程环境下控制对共享资源的访问，确保线程安全性并避免竞争条件和数据不一致性问题的发生。在正确使用互斥锁的情况下，可以有效地保证多线程程序的正确性和稳定性。</p><h3 id="临界区（对共享资源操作的临界区域）"><a href="#临界区（对共享资源操作的临界区域）" class="headerlink" title="临界区（对共享资源操作的临界区域）"></a>临界区（对共享资源操作的临界区域）</h3><p>临界区是指在多线程程序中，多个线程共享的某一段代码或数据区域，这里的代码或数据可能会被多个线程同时访问和操作。在临界区中，如果多个线程同时对共享资源进行读写操作，就会发生竞态条件（Race Condition），导致程序出现错误或产生不确定的结果。</p><p>让我们通过一个生动的比喻来解释临界区：</p><p>假设有一个小咖啡厅只有一个咖啡机可以制作咖啡。多个服务员（线程）需要制作咖啡时，他们需要先检查咖啡机是否空闲。如果咖啡机正在被使用，那么其他服务员必须等待直到当前制作完成并释放咖啡机。在这个过程中，检查咖啡机状态、占用咖啡机、释放咖啡机的这一段代码就是临界区。只能有一个服务员进入临界区，占用咖啡机，制作咖啡，防止出现多个服务员同时操作导致的错误。</p><p>所以，临界区是指在多线程环境下，需要同步访问共享资源的代码区域或数据区域，为了避免竞态条件，需要通过互斥锁等同步机制来确保同一时刻只有一个线程能够访问临界区，保证数据的正确性和一致性。通过合理管理临界区，可以有效避免多线程程序中的各种潜在问题，确保程序的正确性和稳定性。</p><h2 id="复杂一点点的例子"><a href="#复杂一点点的例子" class="headerlink" title="复杂一点点的例子"></a>复杂一点点的例子</h2><p>以下是一个更复杂的多线程示例，其中包含两个线程，一个是生产者线程，一个是消费者线程，它们之间通过共享的缓冲区进行通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line">        </span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，生产者线程负责向缓冲区中放入数据，而消费者线程则负责从缓冲区中取出数据。生产者线程会一直生产数据直到生产完20个数据为止。消费者线程会在生产者线程生产数据时，从缓冲区中消费数据，并且当生产者线程结束时也会结束。</p><p>通过使用互斥锁和条件变量来实现对缓冲区的访问控制和线程通信。生产者线程会根据缓冲区的状态来决定是否生产数据，而消费者线程也会根据缓冲区的状态来决定是否消费数据。在主函数中，调用了 <code>join()</code> 来等待生产者线程和消费者线程的结束。</p><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>当加上sleep_for后:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produceCondition, consumeCondition;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produceCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; bufferSize; &#125;);</span><br><span class="line"></span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    consumeCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        consumeCondition.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = buffer.<span class="built_in">front</span>();</span><br><span class="line">            buffer.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        produceCondition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">Consumed: <span class="number">4</span></span><br><span class="line">Produced: <span class="number">5</span></span><br><span class="line">Consumed: <span class="number">5</span></span><br><span class="line">Produced: <span class="number">6</span></span><br><span class="line">Consumed: <span class="number">6</span></span><br><span class="line">Produced: <span class="number">7</span></span><br><span class="line">Consumed: <span class="number">7</span></span><br><span class="line">Produced: <span class="number">8</span></span><br><span class="line">Consumed: <span class="number">8</span></span><br><span class="line">Produced: <span class="number">9</span></span><br><span class="line">Consumed: <span class="number">9</span></span><br><span class="line">Produced: <span class="number">10</span></span><br><span class="line">Consumed: <span class="number">10</span></span><br><span class="line">Produced: <span class="number">11</span></span><br><span class="line">Consumed: <span class="number">11</span></span><br><span class="line">Produced: <span class="number">12</span></span><br><span class="line">Consumed: <span class="number">12</span></span><br><span class="line">Produced: <span class="number">13</span></span><br><span class="line">Consumed: <span class="number">13</span></span><br><span class="line">Produced: <span class="number">14</span></span><br><span class="line">Consumed: <span class="number">14</span></span><br><span class="line">Produced: <span class="number">15</span></span><br><span class="line">Consumed: <span class="number">15</span></span><br><span class="line">Produced: <span class="number">16</span></span><br><span class="line">Consumed: <span class="number">16</span></span><br><span class="line">Produced: <span class="number">17</span></span><br><span class="line">Consumed: <span class="number">17</span></span><br><span class="line">Produced: <span class="number">18</span></span><br><span class="line">Consumed: <span class="number">18</span></span><br><span class="line">Produced: <span class="number">19</span></span><br><span class="line">Consumed: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>在生产者线程中使用<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>来模拟生产数据的耗时操作是为了模拟实际生产数据可能存在的耗时情况，而不是立即连续生产数据。这种模拟有几个关键的影响：</p><ol><li><p><strong>模拟实际情况</strong>：在实际情况下，生产数据可能涉及到一些繁重的计算或I&#x2F;O操作，这可能导致需要一定的时间来生成数据。通过这种模拟，可以更好地反映现实情况下的生产数据过程。</p></li><li><p><strong>线程调度</strong>：使用<code>sleep_for</code>会使得当前线程在指定的时间内暂停执行，其他线程有机会继续执行。这有助于模拟并发环境中不同线程之间的调度和竞争。</p></li><li><p><strong>避免资源争夺</strong>：由于生产者线程在生产数据时会暂停一段时间，消费者线程有机会访问和处理已生产的数据，而不会因为生产速度过快导致队列溢出或数据丢失。</p></li></ol><p>如果去掉<code>this_thread::sleep_for(std::chrono::milliseconds(500));</code>部分，生产者线程将会变得非常快速，可能导致生产的数据迅速填满队列，消费者线程无法及时消费，从而导致队列溢出。因此，这段代码中的延时操作对于正确模拟生产者和消费者之间的交互过程和线程调度是非常重要的。</p><ol><li><p><strong>为什么done&#x3D;true后面要加consumeCondition.notify_one();</strong></p><p> 在典型的生产者消费者模型中，<code>done=true</code>通常表示生产者已经完成了生产任务，没有更多的数据可供消费者消费。当<code>done</code>被设置为<code>true</code>时，消费者线程需要被唤醒并退出循环，以避免不必要的等待和资源浪费。为了实现这一点，通常会使用条件变量（condition variable）来实现线程的等待和唤醒。</p><p> 在设置<code>done=true</code>之后，通过调用<code>consumeCondition.notify_one()</code>来唤醒等待在<code>consumeCondition</code>条件变量上的一个消费者线程。这样做可以确保消费者线程在<code>done=true</code>之后能够立即被唤醒，检查条件并退出循环。没有这一步的唤醒操作，消费者线程可能会一直阻塞在条件变量上，无法及时退出循环，导致资源浪费或程序逻辑错误。</p><p> 因此，通过在<code>done=true</code>之后调用<code>consumeCondition.notify_one()</code>来唤醒消费者线程，确保了生产者完成生产后消费者能够及时退出循环，有效地管理线程的执行顺序和资源的利用。</p></li><li><p><strong>condition_variable是什么</strong></p><p> <code>std::condition_variable</code> 是 C++ 标准库中用来实现多线程同步的一种机制。它允许一个或多个线程等待，直到某个条件得到满足后再继续执行。在多线程编程中，我们经常需要一种方式来进行线程之间的通信和同步，<code>std::condition_variable</code> 就是为此而设计的。</p><p> 在使用 <code>std::condition_variable</code> 时通常和 <code>std::mutex</code> 配合使用，具体步骤如下：</p><ol><li>使用 <code>std::mutex</code> 来保护需要等待的条件变量和共享资源。</li><li>当条件不满足时，线程通过 <code>std::condition_variable</code> 的 <code>wait()</code> 方法释放锁并进入等待状态，直到其他线程通知条件满足。</li><li>当其他线程满足了条件后，调用 <code>std::condition_variable</code> 的 <code>notify_one()</code> 或 <code>notify_all()</code> 方法来唤醒等待的线程。</li></ol><p> 通过 <code>std::condition_variable</code>，我们可以实现线程之间的有效协作和同步，避免了线程忙等待，提高了程序的效率和性能。</p></li></ol><h2 id="4个线程来并发计算部分和"><a href="#4个线程来并发计算部分和" class="headerlink" title="4个线程来并发计算部分和"></a>4个线程来并发计算部分和</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;上次更新blog还是生日4.29，这一个月真是忙鼠了，现在有了一个新任务-多线程，搞一下(不加多线程的话我的车车会变成蜗牛🐌的。。。。)&lt;/p&gt;&lt;/div&gt;


&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; cl</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="C++" scheme="http://tumytime.github.io/tags/C/"/>
    
    <category term="智能车，多线程" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一些图像处理的函数</title>
    <link href="http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://tumytime.github.io/2024/04/29/%E4%B8%80%E4%BA%9B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2024-04-29T11:47:24.000Z</published>
    <updated>2024-04-29T12:18:44.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p><strong>卷积核大小为7：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">medianFilter</span><span class="params">(Mat imgO)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个新的Mat对象用于存储滤波后的图像</span></span><br><span class="line">Mat img1 = Mat::<span class="built_in">zeros</span>(imgO.rows - <span class="number">6</span>, imgO.cols - <span class="number">6</span>, CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入图像进行中值滤波</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">3</span>; y &lt; imgO.rows - <span class="number">3</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">3</span>; x &lt; imgO.cols - <span class="number">3</span>; x++) &#123;</span><br><span class="line">vector&lt;uchar&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-3</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-3</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">values.<span class="built_in">push_back</span>(imgO.<span class="built_in">at</span>&lt;uchar&gt;(y + j, x + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对values数组中的值进行排序</span></span><br><span class="line"><span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算中值并赋值给输出图像</span></span><br><span class="line">img1.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">3</span>, x - <span class="number">3</span>) = values[values.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> img1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.2yy5oeqtl5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="sobel算子边缘检测"><a href="#sobel算子边缘检测" class="headerlink" title="sobel算子边缘检测"></a>sobel算子边缘检测</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">sobel3</span><span class="params">(Mat inputImg)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gx, gy;</span><br><span class="line">Mat tempImg;</span><br><span class="line">inputImg.<span class="built_in">copyTo</span>(tempImg); <span class="comment">// 为了能够在输出图像中访问原始输入图像的像素值</span></span><br><span class="line"></span><br><span class="line">Mat outputImg = Mat::<span class="built_in">zeros</span>(inputImg.<span class="built_in">size</span>(), inputImg.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; inputImg.rows - <span class="number">1</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; inputImg.cols - <span class="number">1</span>; x++) &#123;</span><br><span class="line">gx = (<span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>)) / <span class="number">4</span>;</span><br><span class="line">gy = (<span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x - <span class="number">1</span>) + <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x) + <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x + <span class="number">1</span>) +</span><br><span class="line"><span class="number">-1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x - <span class="number">1</span>) - <span class="number">2</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x) - <span class="number">1</span> * tempImg.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">outputImg.<span class="built_in">at</span>&lt;uchar&gt;(y, x) = (<span class="built_in">abs</span>(gx) + <span class="built_in">abs</span>(gy)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outputImg.<span class="built_in">clone</span>(); <span class="comment">// 返回outputImg的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" class="lazyload placeholder" data-srcset=",https://tumytime.github.io/picx-images-hosting/image.4jnwnvqbmt.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中值滤波&quot;&gt;&lt;a href=&quot;#中值滤波&quot; class=&quot;headerlink&quot; title=&quot;中值滤波&quot;&gt;&lt;/a&gt;中值滤波&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;卷积核大小为7：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AuTop代码整理</title>
    <link href="http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <id>http://tumytime.github.io/2024/04/28/AuTop%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/</id>
    <published>2024-04-28T11:36:06.000Z</published>
    <updated>2024-05-03T17:37:19.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="圆环circle"><a href="#圆环circle" class="headerlink" title="圆环circle"></a>圆环circle</h2><details ><summary pointer> circle.c </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;motor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span> =</span> CIRCLE_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便串口收发</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM] = &#123;</span><br><span class="line">        <span class="string">&quot;CIRCLE_NONE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_BEGIN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_BEGIN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_RUNNING&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_RUNNING&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_IN&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_IN&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_OUT&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_OUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CIRCLE_LEFT_END&quot;</span>, <span class="string">&quot;CIRCLE_RIGHT_END&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码器，用于防止一些重复触发等。</span></span><br><span class="line"><span class="type">int64_t</span> circle_encoder;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> none_left_line = <span class="number">0</span>, none_right_line = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> have_left_line = <span class="number">0</span>, have_right_line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆环模式下的调试图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> circle.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> &#123;</span></span><br><span class="line">    CIRCLE_NONE = <span class="number">0</span>,                            <span class="comment">// 非圆环模式</span></span><br><span class="line">    CIRCLE_LEFT_BEGIN, CIRCLE_RIGHT_BEGIN,      <span class="comment">// 圆环开始，识别到单侧L角点另一侧长直道。</span></span><br><span class="line">    CIRCLE_LEFT_IN, CIRCLE_RIGHT_IN,            <span class="comment">// 圆环进入，即走到一侧直道，一侧圆环的位置。</span></span><br><span class="line">    CIRCLE_LEFT_RUNNING, CIRCLE_RIGHT_RUNNING,  <span class="comment">// 圆环内部。</span></span><br><span class="line">    CIRCLE_LEFT_OUT, CIRCLE_RIGHT_OUT,          <span class="comment">// 准备出圆环，即识别到出环处的L角点。</span></span><br><span class="line">    CIRCLE_LEFT_END, CIRCLE_RIGHT_END,          <span class="comment">// 圆环结束，即再次走到单侧直道的位置。</span></span><br><span class="line">    CIRCLE_NUM,                                 <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *circle_type_name[CIRCLE_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">enum</span> <span class="title">circle_type_e</span> <span class="title">circle_type</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_circle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CIRCLE_H</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="非圆环模式下判断圆环"><a href="#非圆环模式下判断圆环" class="headerlink" title="非圆环模式下判断圆环"></a>非圆环模式下判断圆环</h3><p><strong>单边L角点, 单边长直道</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非圆环模式下，单边L角点, 单边长直道</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; Lpt0_found &amp;&amp; !Lpt1_found &amp;&amp; is_straight1) &#123;</span><br><span class="line">        circle_type = CIRCLE_LEFT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_NONE &amp;&amp; !Lpt0_found &amp;&amp; Lpt1_found &amp;&amp; is_straight0) &#123;</span><br><span class="line">        circle_type = CIRCLE_RIGHT_BEGIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆环执行"><a href="#圆环执行" class="headerlink" title="圆环执行"></a>圆环执行</h3><details ><summary pointer> run_circle() </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_circle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> current_encoder = get_total_encoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左环开始，寻外直道右线</span></span><br><span class="line">    <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢左线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_left_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_left_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_LEFT_IN;</span><br><span class="line">                none_left_line = <span class="number">0</span>;</span><br><span class="line">                have_left_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入环，寻内圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_IN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found) rpts1s_num = rptsc1_num = Lpt1_rpts1s_id;</span><br><span class="line">        <span class="comment">//外环拐点(右L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt1_found &amp;&amp; Lpt1_rpts1s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右线为长直道</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight1) &#123;</span><br><span class="line">            circle_type = CIRCLE_LEFT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走过圆环，寻右线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_LEFT_END) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_left_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts0s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_left_line &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_left_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右环控制，前期寻左直道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_BEGIN) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先丢右线后有线</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            have_right_line++;</span><br><span class="line">            <span class="keyword">if</span> (have_right_line &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                circle_type = CIRCLE_RIGHT_IN;</span><br><span class="line">                none_right_line = <span class="number">0</span>;</span><br><span class="line">                have_right_line = <span class="number">0</span>;</span><br><span class="line">                circle_encoder = current_encoder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入右环，寻右内圆环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_IN) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码器打表过1/4圆   应修正为左线为转弯无拐点</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">            current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_RIGHT_RUNNING; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常巡线，寻外圆左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_RUNNING) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外环存在拐点,可再加拐点距离判据(左L点)</span></span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found) rpts0s_num = rptsc0_num = Lpt0_rpts0s_id;</span><br><span class="line">        <span class="keyword">if</span> (Lpt0_found &amp;&amp; Lpt0_rpts0s_id &lt; <span class="number">0.4</span> / sample_dist) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出环，寻内圆</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_OUT) &#123;</span><br><span class="line">        track_type = TRACK_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左长度加倾斜角度  应修正左右线找到且为直线</span></span><br><span class="line">        <span class="comment">//if((rpts1s_num &gt;100 &amp;&amp; !Lpt1_found))  &#123;have_right_line++;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (is_straight0) &#123;</span><br><span class="line">            circle_type = CIRCLE_RIGHT_END;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//走过圆环，寻左线</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (circle_type == CIRCLE_RIGHT_END) &#123;</span><br><span class="line">        track_type = TRACK_LEFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左线先丢后有</span></span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &lt; <span class="number">0.2</span> / sample_dist) &#123; none_right_line++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpts1s_num &gt; <span class="number">1.0</span> / sample_dist &amp;&amp; none_right_line &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            circle_type = CIRCLE_NONE;</span><br><span class="line">            none_right_line = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details ><summary pointer> 详细解读 </summary>              <div class='content'>              <details open><summary pointer> get_total_encoder() </summary>          <div class='content'>          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">get_total_encoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int64_t</span>) ((motor_l.total_encoder + motor_r.total_encoder) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个函数 <code>get_total_encoder()</code>，用于计算左右两个电机的编码器总和并取平均值。具体步骤如下：</p><ol><li>获取左电机和右电机的编码器值 <code>motor_l.total_encoder</code> 和 <code>motor_r.total_encoder</code>。</li><li>将左右两个电机的编码器值相加得到总和。</li><li>将总和除以2取平均值，然后以 <code>int64_t</code> 类型返回结果。</li></ol>          </div>        </details>              </div>            </details><p>track_type：单边得中线的边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码器打表过1/4圆   应修正为右线为转弯无拐点</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (rpts0s_num &lt; <span class="number">0.1</span> / sample_dist ||</span><br><span class="line">          current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (<span class="number">3.14</span> * <span class="number">1</span> / <span class="number">2</span>)) &#123; circle_type = CIRCLE_LEFT_RUNNING; &#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑似乎与之前的代码相关，用于检测编码器在打表过1&#x2F;4圆时的状态，并进行相应的修正。让我来解释一下这段代码的作用：</p><ol><li>首先判断条件 <code>rpts0s_num &lt; 0.1 / sample_dist</code>，如果条件成立，说明小车还未行驶到1&#x2F;4圆的位置，或者右线未被检测到。</li><li>或者判断条件 <code>current_encoder - circle_encoder &gt;= ENCODER_PER_METER * (3.14 * 1 / 2)</code>，这个条件看起来是在判断当前编码器值与开始打表时的编码器值之差是否超过了1&#x2F;4圆的周长对应的编码器值。</li><li>如果以上两个条件有一个成立，就会将 <code>circle_type</code> 设置为 <code>CIRCLE_LEFT_RUNNING</code>，表示小车正在左环行驶的阶段。</li></ol><p>在检测到小车行驶过1&#x2F;4圆或者右线为转弯时将 <code>circle_type</code> 修改为 <code>CIRCLE_LEFT_RUNNING</code>，可能是为了校准小车在左环赛道上行驶时的特定状态。这段代码与之前的代码一起，似乎在实现一个复杂的状态机来控制小车在左环赛道上的运动。如果您有更多的问题或需要进一步解释，请随时告诉我。</p><hr><p>什么是编码器打表:<br>编码器打表（Encoder Look-Up Table）通常指的是在编码器模块中使用查找表（Look-Up Table）来进行编码的过程。在信号处理领域或者通信系统中，编码器的作用是将输入信号转换为特定的编码形式，以便传输、存储或处理。而编码器打表的概念是通过预先构建一个表格，将输入信号映射到特定的编码值，从而实现编码的过程。</p><p>在这种情况下，编码器打表的优势在于可以提高编码的速度和效率。通过查找表，编码器可以以常量时间复杂度快速查找到对应的编码值，而不必每次都进行复杂的计算或逻辑判断。这样可以加快编码过程，特别是在需要频繁编码大量数据时，可以节省时间和计算资源。</p><p>总的来说，编码器打表是一种提高编码效率的方法，通过预先建立编码映射表，可以在编码过程中快速准确地找到对应的编码值，提高系统性能和速度。</p><hr><h2 id="迷宫巡线部分"><a href="#迷宫巡线部分" class="headerlink" title="迷宫巡线部分"></a>迷宫巡线部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前进方向定义：</span></span><br><span class="line"><span class="comment"> *   0</span></span><br><span class="line"><span class="comment"> * 3   1</span></span><br><span class="line"><span class="comment"> *   2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_front[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">1</span>,  <span class="number">0</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                            &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontleft[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">AT_DTCM_SECTION_ALIGN_INIT</span>(<span class="type">const</span> <span class="type">int</span> dir_frontright[<span class="number">4</span>][<span class="number">2</span>], <span class="number">8</span>) = &#123;&#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                                                 &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_lefthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; half &lt; x &amp;&amp; x &lt; img-&gt;width - half - <span class="number">1</span> &amp;&amp; half &lt; y &amp;&amp; y &lt; img-&gt;height - half - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontleft_value = <span class="built_in">AT</span>(img, x + dir_frontleft[dir][<span class="number">0</span>], y + dir_frontleft[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontleft_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontleft[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontleft[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 右手迷宫巡线</span></span><br><span class="line"><span class="built_in">AT_ITCM_SECTION_INIT</span>(<span class="type">void</span> <span class="built_in">findline_righthand_adaptive</span>(<span class="type">image_t</span> *img, <span class="type">int</span> block_size, <span class="type">int</span> clip_value, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pts[][<span class="number">2</span>], <span class="type">int</span> *num)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(img &amp;&amp; img-&gt;data);</span><br><span class="line">    <span class="built_in">assert</span>(num &amp;&amp; *num &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(block_size &gt; <span class="number">1</span> &amp;&amp; block_size % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> half = block_size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, dir = <span class="number">0</span>, turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; *num &amp;&amp; <span class="number">0</span> &lt; x &amp;&amp; x &lt; img-&gt;width - <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt; img-&gt;height - <span class="number">1</span> &amp;&amp; turn &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> local_thres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dy = -half; dy &lt;= half; dy++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dx = -half; dx &lt;= half; dx++) &#123;</span><br><span class="line">                local_thres += <span class="built_in">AT</span>(img, x + dx, y + dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_thres /= block_size * block_size;</span><br><span class="line">        local_thres -= clip_value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current_value = <span class="built_in">AT</span>(img, x, y);</span><br><span class="line">        <span class="type">int</span> front_value = <span class="built_in">AT</span>(img, x + dir_front[dir][<span class="number">0</span>], y + dir_front[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> frontright_value = <span class="built_in">AT</span>(img, x + dir_frontright[dir][<span class="number">0</span>], y + dir_frontright[dir][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (front_value &lt; local_thres) &#123;</span><br><span class="line">            dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            turn++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontright_value &lt; local_thres) &#123;</span><br><span class="line">            x += dir_front[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_front[dir][<span class="number">1</span>];</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x += dir_frontright[dir][<span class="number">0</span>];</span><br><span class="line">            y += dir_frontright[dir][<span class="number">1</span>];</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            pts[step][<span class="number">0</span>] = x;</span><br><span class="line">            pts[step][<span class="number">1</span>] = y;</span><br><span class="line">            step++;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">warpPerspective</span><span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> flags = INTER_LINEAR, <span class="type">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> Scalar &amp;borderValue = Scalar())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>(!src.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">CV_Assert</span>(src.<span class="built_in">depth</span>() == CV_8U || src.<span class="built_in">depth</span>() == CV_32F);</span><br><span class="line">    <span class="built_in">CV_Assert</span>(M.<span class="built_in">rows</span>() == <span class="number">3</span> &amp;&amp; M.<span class="built_in">cols</span>() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">mapx</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">mapy</span><span class="params">(dsize, CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">transform</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, CV_64F)</span></span>;</span><br><span class="line">    M.<span class="built_in">getMat</span>().<span class="built_in">colRange</span>(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">convertTo</span>(transform, transform.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buildWarpPerspectiveMaps</span>(transform, flags, dsize, mapx, mapy);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remap</span>(src, dst, mapx, mapy, flags, borderMode, borderValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是OpenCV中的warpPerspective函数的实现，用于对输入图像进行透视变换。下面是对代码中的函数及参数的详细解释：</p><h3 id="warpPerspective函数参数解释："><a href="#warpPerspective函数参数解释：" class="headerlink" title="warpPerspective函数参数解释："></a>warpPerspective函数参数解释：</h3><ul><li><strong>src</strong>：输入图像，类型为InputArray。</li><li><strong>dst</strong>：输出图像，类型为OutputArray。</li><li><strong>M</strong>：3x3的变换矩阵，描述了透视变换，类型为InputArray。</li><li><strong>dsize</strong>：输出图像的尺寸，类型为Size。</li><li><strong>flags</strong>：插值方法，用于指定在进行像素值插值时要使用的方法，默认为INTER_LINEAR。</li><li><strong>borderMode</strong>：边界像素插值模式，用于指定当目标图像像素位于源图像之外时的处理方式，默认为BORDER_CONSTANT。</li><li><strong>borderValue</strong>：边界填充的像素值，类型为Scalar。</li></ul><h3 id="warpPerspective函数主要步骤解释："><a href="#warpPerspective函数主要步骤解释：" class="headerlink" title="warpPerspective函数主要步骤解释："></a>warpPerspective函数主要步骤解释：</h3><ol><li><p><strong>CV_INSTRUMENT_REGION</strong>：用于性能测量和优化的宏定义。</p></li><li><p><strong>CV_Assert</strong>：断言，用于判断条件是否成立，如果条件不成立则会抛出一个异常。</p></li><li><p><strong>Mat mapx</strong>和<strong>Mat mapy</strong>：分别用于存储X和Y方向的映射结果。</p></li><li><p><strong>Mat transform</strong>：是一个2x3的矩阵，用于保存M矩阵的前两列，并将其转换为CV_64F类型。</p></li><li><p><strong>buildWarpPerspectiveMaps</strong>：根据透视变换矩阵和指定的插值方法，构建出目标图像在源图像上的映射关系。</p></li><li><p><strong>remap</strong>：根据生成的映射关系对输入图像进行透视变换，并存储结果到输出图像dst中。<br>  M.getMat().colRange(0, 2).convertTo(transform, transform.type());详细解释<br>  这行代码是针对OpenCV中的矩阵操作。让我逐步解释一下：</p></li><li><p><code>M.getMat()</code>: 这部分获取一个OpenCV的矩阵<code>M</code>。</p></li><li><p><code>.colRange(0, 2)</code>: 这个部分表示对该矩阵<code>M</code>的列进行切片操作，只选择从第0列到第2列（不包括第2列）的部分。</p></li><li><p><code>.convertTo(transform, transform.type())</code>: 这一部分是将切片后的列数据进行类型转换并赋值给另外一个矩阵<code>transform</code>。这里的<code>transform</code>是一个目标矩阵，它将包含转换后的数据。<code>transform.type()</code>返回<code>transform</code>矩阵的类型。</p></li></ol><p>因此，整体来看，这行代码的作用是从矩阵<code>M</code>中选择第0列到第1列的数据，并将其转换为指定类型，然后存储到矩阵<code>transform</code>中。</p><p>这是 <code>buildWarpPerspectiveMaps</code> 函数的伪代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWarpPerspectiveMaps</span><span class="params">(Size src_size, Matx33f M, <span class="type">bool</span> inverse_map, Mat&amp; xmap, Mat&amp; ymap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = src_size.width;</span><br><span class="line">    <span class="type">int</span> height = src_size.height;</span><br><span class="line">    </span><br><span class="line">    xmap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line">    ymap.<span class="built_in">create</span>(height, width, CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            Vec3f src_pt = <span class="built_in">Vec3f</span>(x, y, <span class="number">1</span>); <span class="comment">// Source point</span></span><br><span class="line">            Vec3f dst_pt = M * src_pt;      <span class="comment">// Apply transformation matrix</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> map_x, map_y;</span><br><span class="line">            <span class="keyword">if</span> (!inverse_map) &#123;</span><br><span class="line">                map_x = dst_pt[<span class="number">0</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">                map_y = dst_pt[<span class="number">1</span>] / dst_pt[<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map_x = src_pt[<span class="number">0</span>] - dst_pt[<span class="number">0</span>];</span><br><span class="line">                map_y = src_pt[<span class="number">1</span>] - dst_pt[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xmap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_x;</span><br><span class="line">            ymap.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = map_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个伪代码实现描述了 <code>buildWarpPerspectiveMaps</code> 函数的大致操作步骤。实际的 <code>buildWarpPerspectiveMaps</code> 函数是 OpenCV 中用于构建透视变换映射的函数，具体实现会更加复杂并且包含了更多细节。如果你需要实际的代码实现，建议查阅 OpenCV 的源代码或者官方文档中提供的具体函数实现。希望这个简要描述能够帮助到你，如果有其他问题或者需要更多帮助，请随时告诉我。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>输入图像src不能为空。</li><li>输入图像src的深度必须为CV_8U或CV_32F。</li><li>变换矩阵M必须为一个3x3矩阵。</li><li>warpPerspective函数实现了透视变换的核心逻辑，通过构建变换矩阵并利用remap函数实现对图像的透视变换操作。</li></ul><p>如果你有任何关于这段代码的疑问或需要进一步解释，请随时告诉我。</p><p>@brief Applies a perspective transformation to an image.</p><p>The function warpPerspective transforms the source image using the specified matrix:</p><p>  [$\texttt{dst} (x,y) &#x3D;  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,<br>     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )$] </p><p>when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert<br>and then put in the formula above instead of M. The function cannot operate in-place.</p><p>@param src input image.<br>@param dst output image that has the size dsize and the same type as src .<br>@param M  $ 3\times 3 $ transformation matrix.<br>@param dsize size of the output image.<br>@param flags combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the<br>optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (<br>$\texttt{dst}\rightarrow\texttt{src} $ ).<br>@param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).<br>@param borderValue value used in case of a constant border; by default, it equals 0.</p><p>@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;圆环circle&quot;&gt;&lt;a href=&quot;#圆环circle&quot; class=&quot;headerlink&quot; title=&quot;圆环circle&quot;&gt;&lt;/a&gt;圆环circle&lt;/h2&gt;&lt;details &gt;&lt;summary pointer&gt; circle.c &lt;/summary&gt;
 </summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>逆透视</title>
    <link href="http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/"/>
    <id>http://tumytime.github.io/2024/04/27/%E9%80%86%E9%80%8F%E8%A7%86/</id>
    <published>2024-04-26T17:14:17.000Z</published>
    <updated>2024-04-26T17:17:07.839Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief IPM初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param origSize 输入原始图像Size</span></span><br><span class="line"><span class="comment">     * @param dstSize 输出图像Size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> cv::Size &amp;origSize, <span class="type">const</span> cv::Size &amp;dstSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原始域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points at the input image</span></span><br><span class="line">        m_origPoints.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// [第二版无带畸变镜头参数]</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">0</span>, <span class="number">214</span>));   <span class="comment">// 左下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">319</span>, <span class="number">214</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">192</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_origPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">128</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矫正域：分辨率320x240</span></span><br><span class="line">        <span class="comment">// The 4-points correspondences in the destination image</span></span><br><span class="line">        m_dstPoints.<span class="built_in">clear</span>();</span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">400</span>)); <span class="comment">// 左下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">400</span>)); <span class="comment">// 右下</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">220</span>, <span class="number">0</span>));   <span class="comment">// 右上</span></span><br><span class="line">        m_dstPoints.<span class="built_in">push_back</span>(<span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">0</span>));   <span class="comment">// 左上</span></span><br><span class="line"></span><br><span class="line">        m_origSize = origSize;</span><br><span class="line">        m_dstSize = dstSize;</span><br><span class="line">        <span class="built_in">assert</span>(m_origPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; m_dstPoints.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; <span class="string">&quot;Orig. points and Dst. points must vectors of 4 points&quot;</span>);</span><br><span class="line">        m_H = <span class="built_in">getPerspectiveTransform</span>(m_origPoints, m_dstPoints); <span class="comment">// 计算变换矩阵 [3x3]</span></span><br><span class="line">        m_H_inv = m_H.<span class="built_in">inv</span>();                                      <span class="comment">// 求解逆转换矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">createMaps</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>void init(const cv::Size &amp;origSize, const cv::Size &amp;dstSize)</code>: 这是一个名为<code>init</code>的函数，它接受两个参数<code>origSize</code>和<code>dstSize</code>，这两个参数是OpenCV库中的<code>cv::Size</code>类型，用来表示图像的尺寸。</p></li><li><p><code>m_origPoints.clear();</code>: 清空存储原始域点坐标的容器<code>m_origPoints</code>。</p></li><li><p><code>m_origPoints.push_back(Point2f(0, 214));</code>: 将<code>(0, 214)</code>点坐标添加到原始域的点坐标集合中，代表原始图像的左下角。</p></li><li><p>依次类推，将原始域的四个角的点坐标添加到<code>m_origPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_dstPoints.clear();</code>: 清空存储矫正域点坐标的容器<code>m_dstPoints</code>。</p></li><li><p><code>m_dstPoints.push_back(Point2f(100, 400));</code>: 将<code>(100, 400)</code>点坐标添加到矫正域的点坐标集合中，代表矫正图像的左下角。</p></li><li><p>依次类推，将矫正域的四个角的点坐标添加到<code>m_dstPoints</code>中，依次是左下、右下、右上和左上。</p></li><li><p><code>m_origSize = origSize;</code>和<code>m_dstSize = dstSize;</code>: 将原始图像尺寸和目标图像尺寸保存下来。</p></li><li><p><code>assert(m_origPoints.size() == 4 &amp;&amp; m_dstPoints.size() == 4 &amp;&amp; &quot;Orig. points and Dst. points must vectors of 4 points&quot;);</code>: 使用<code>assert</code>断言来确保原始域和矫正域的点坐标集合都包含四个点。</p></li><li><p><code>m_H = getPerspectiveTransform(m_origPoints, m_dstPoints);</code>: 通过原始域和矫正域的点坐标计算透视变换矩阵<code>m_H</code>。</p></li><li><p><code>m_H_inv = m_H.inv();</code>: 求解透视变换矩阵<code>m_H</code>的逆矩阵，存储在<code>m_H_inv</code>中。</p></li><li><p><code>createMaps();</code>: 调用<code>createMaps</code>函数，创建地图。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据集标注json转xml脚本</title>
    <link href="http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/"/>
    <id>http://tumytime.github.io/2024/04/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%87%E6%B3%A8json%E8%BD%ACxml%E8%84%9A%E6%9C%AC/</id>
    <published>2024-04-26T12:43:07.000Z</published>
    <updated>2024-04-26T12:47:40.715Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_json_to_xml</span>(<span class="params">json_data</span>):</span><br><span class="line">    root = ET.Element(<span class="string">&quot;annotation&quot;</span>)</span><br><span class="line">    filename = ET.SubElement(root, <span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    filename.text = json_data[<span class="string">&quot;imagePath&quot;</span>]</span><br><span class="line">    object_num = ET.SubElement(root, <span class="string">&quot;object_num&quot;</span>)</span><br><span class="line">    object_num.text = <span class="built_in">str</span>(<span class="built_in">len</span>(json_data[<span class="string">&quot;shapes&quot;</span>]))</span><br><span class="line">    size = ET.SubElement(root, <span class="string">&quot;size&quot;</span>)</span><br><span class="line">    width = ET.SubElement(size, <span class="string">&quot;width&quot;</span>)</span><br><span class="line">    width.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageWidth&quot;</span>])</span><br><span class="line">    height = ET.SubElement(size, <span class="string">&quot;height&quot;</span>)</span><br><span class="line">    height.text = <span class="built_in">str</span>(json_data[<span class="string">&quot;imageHeight&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> json_data[<span class="string">&quot;shapes&quot;</span>]:</span><br><span class="line">        object_element = ET.SubElement(root, <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        name = ET.SubElement(object_element, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">        name.text = shape[<span class="string">&quot;label&quot;</span>]</span><br><span class="line">        difficult = ET.SubElement(object_element, <span class="string">&quot;difficult&quot;</span>)</span><br><span class="line">        difficult.text = <span class="string">&quot;0&quot;</span></span><br><span class="line">        bndbox = ET.SubElement(object_element, <span class="string">&quot;bndbox&quot;</span>)</span><br><span class="line">        xmin = ET.SubElement(bndbox, <span class="string">&quot;xmin&quot;</span>)</span><br><span class="line">        xmin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">        ymin = ET.SubElement(bndbox, <span class="string">&quot;ymin&quot;</span>)</span><br><span class="line">        ymin.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line">        xmax = ET.SubElement(bndbox, <span class="string">&quot;xmax&quot;</span>)</span><br><span class="line">        xmax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">        ymax = ET.SubElement(bndbox, <span class="string">&quot;ymax&quot;</span>)</span><br><span class="line">        ymax.text = <span class="built_in">str</span>(<span class="built_in">int</span>(shape[<span class="string">&quot;points&quot;</span>][<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ET.tostring(root, encoding=<span class="string">&quot;unicode&quot;</span>)</span><br><span class="line">current_dir = os.getcwd()</span><br><span class="line">parent_dir = os.path.abspath(os.path.join(current_dir, os.pardir))</span><br><span class="line">output_dir = os.path.join(parent_dir, <span class="string">&quot;xml_output&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(current_dir):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&quot;.json&quot;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(current_dir, file), <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json_data = json.load(json_file)</span><br><span class="line">            xml_data = convert_json_to_xml(json_data)</span><br><span class="line">            xml_filename = file.replace(<span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">            output_path = os.path.join(output_dir, xml_filename)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> xml_file:</span><br><span class="line">                xml_file.write(xml_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有JSON文件已经转换为XML并保存在文件夹 xml_output 中&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="AI" scheme="http://tumytime.github.io/tags/AI/"/>
    
    <category term="python" scheme="http://tumytime.github.io/tags/python/"/>
    
    <category term="数据集" scheme="http://tumytime.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>无人驾驶汽车系统入门（一）卡尔曼滤波与目标追踪</title>
    <link href="http://tumytime.github.io/2024/04/25/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    <id>http://tumytime.github.io/2024/04/25/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/</id>
    <published>2024-04-25T10:40:25.000Z</published>
    <updated>2024-04-26T07:50:11.547Z</updated>
    
    <content type="html"><![CDATA[<div class="tagLink"><a class="link-card" title="卡尔曼滤波教程" href="https://www.kalmanfilter.net/CN/background_cn.html"><span class="link-card-backdrop" style="background-image: url(https://www.kalmanfilter.net/img/profile.png)"></span><div class="left"><img src="https://www.kalmanfilter.net/img/profile.png" class="lazyload placeholder" data-srcset="https://www.kalmanfilter.net/img/profile.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">卡尔曼滤波教程</p><p class="url">https://www.kalmanfilter.net/CN/background_cn.html</p></div></a></div><div class="tagLink"><a class="link-card" title="一个例子搞清楚（先验分布/后验分布/似然估计）" href="https://blog.csdn.net/qq_23947237/article/details/78265026"><span class="link-card-backdrop" style="background-image: url(https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)"></span><div class="left"><img src="https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20171021161006627?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjM5NDcyMzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">一个例子搞清楚（先验分布/后验分布/似然估计）</p><p class="url">https://blog.csdn.net/qq_23947237/article/details/78265026</p></div></a></div><p>在贝叶斯推断中，后验分布与先验分布和似然之间存在一种重要的关系，即后验分布正比于先验分布乘以似然。这种关系可以通过贝叶斯定理来进行推导和解释。</p><h3 id="贝叶斯定理："><a href="#贝叶斯定理：" class="headerlink" title="贝叶斯定理："></a>贝叶斯定理：</h3><p>贝叶斯定理描述了在观测到数据 $( D ) $后，参数 $( \theta )$ 的后验概率如何根据先验概率 $( P(\theta) )$ 和似然性函数 $( P(D|\theta) )$ 来更新。表达式如下：<br>$[ P(\theta|D) &#x3D; \frac{P(D|\theta) \times P(\theta)}{P(D)} ]$</p><p>其中：</p><ul><li>$( P(\theta|D) )$ 是在给定观测数据 $( D )$ 后参数$ ( \theta )$ 的后验概率；</li><li>$( P(D|\theta) )$ 是在给定参数 $( \theta ) $的条件下观测数据 $( D )$ 的似然性；</li><li>$( P(\theta) )$ 是参数 $( \theta )$ 的先验概率；</li><li>$( P(D) )$ 是数据 $( D )$ 的边际概率。</li></ul><h3 id="后验分布正比于先验分布乘以似然："><a href="#后验分布正比于先验分布乘以似然：" class="headerlink" title="后验分布正比于先验分布乘以似然："></a>后验分布正比于先验分布乘以似然：</h3><p>从贝叶斯定理中可以得出后验分布正比于先验分布乘以似然的结论，表达式如下：<br>$[ P(\theta|D) \propto P(D|\theta) \times P(\theta) ]$</p><p>这意味着后验分布与先验分布乘以似然性函数之间存在比例关系。具体解释如下：</p><ul><li>先验分布 $( P(\theta) )$ 描述了在观测数据之前对参数 $( \theta )$ 的不确定性的初始估计；</li><li>似然性函数 $( P(D|\theta) ) $描述了在给定参数 $( \theta )$ 的情况下观测到数据 $( D )$ 的概率；</li><li>后验分布 $( P(\theta|D) )$ 结合了先验信息和新数据的信息，提供了在给定数据 $( D )$ 后对参数 $( \theta )$ 的更准确估计。</li></ul><p>通过这种关系，我们可以利用先验知识和观测到的数据来更新对参数的估计，从而更好地理解数据和进行推断。这种贝叶斯方法在处理不确定性和小样本数据时非常有用。</p><iframe src="//player.bilibili.com/player.html?aid=399758288&bvid=BV1zo4y1J76H&cid=1164008541&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>卡尔曼滤波（Kalman Filter）是一种用于估计系统状态的数学算法，通过融合系统模型的预测信息和实际观测的测量信息，以优化对系统当前状态的估计。卡尔曼滤波算法的核心思想就是通过对系统状态的动态建模和不确定性的估计，来获得系统状态的最优估计。</p><p>具体来说，卡尔曼滤波通过以下步骤实现对当前状态的估计：</p><ol><li><p><strong>预测状态</strong>：首先根据系统的动态模型，利用系统的上一个状态值和系统的状态转移方程，预测系统的当前状态值。这一步是基于系统的内在规律进行的状态预测，不考虑观测值。</p></li><li><p><strong>更新状态</strong>：接着，卡尔曼滤波考虑到当前的测量值，即观测到的系统状态值。通过比较实际观测值和预测状态值之间的差异，结合系统的测量方程和协方差矩阵，更新对系统当前状态的估计。这一步可以理解为根据测量结果对系统状态进行修正和优化，同时考虑到测量误差和系统动态的不确定性。</p></li><li><p><strong>状态更新</strong>：经过预测和更新之后，卡尔曼滤波会根据预测和更新的结果来更新系统的状态估计和状态的不确定性，然后循环迭代这些步骤以获得对系统状态的连续估计。</p></li></ol><p>总的来说，卡尔曼滤波算法充分利用了系统动态模型和传感器测量信息，通过预测和更新的步骤来获得对系统状态的最优估计。通过同时考虑上一个状态值和当前的测量值，卡尔曼滤波能够有效地处理系统动态、测量误差和不确定性，从而提高对系统状态的估计精度。</p><h2 id="贝塞尔校正"><a href="#贝塞尔校正" class="headerlink" title="贝塞尔校正"></a>贝塞尔校正</h2><p>在高斯分布（正态分布）中，如果我们从总体分布中抽取一小部分样本来估计总体的方差，通常情况下样本方差会低估总体方差。这种现象的原因主要是由于样本抽取的局限性和高斯分布概率密度函数的形状所导致的。</p><p>当我们从高斯分布中抽取样本时，由于高斯分布的中心值（均值）具有更高的概率密度，大部分样本会集中在均值附近，而在分布的尾部（边沿）位置上，样本数量相对较少。因此，如果我们只从高斯分布的中心值附近抽取样本来估计总体方差，由于未能很好地覆盖整个分布，很可能会导致总体方差的低估。</p><p>样本方差的计算是基于样本数据与样本均值之间的差异来衡量的。当样本主要集中在总体分布的中心值附近时，部分样本与样本均值之间的差异相对较小，导致样本方差的计算结果较小。而总体的方差是考虑了整个分布范围内数据点与总体均值之间的差异（包括边缘值），因此总体方差通常会大于样本方差。</p><p>因此，由于样本主要集中在高斯分布的中心值附近且样本数量有限，使用这部分样本来估计总体的方差往往会低估总体方差。为了更准确地估计总体方差，可以考虑增加样本数量、在整个分布范围内均匀抽样或者使用更复杂的统计方法来处理这种情况。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2obbpl0e33.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2obbpl0e33.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;卡尔曼滤波器教程&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><h2 id="k阶原点矩和k阶中心矩"><a href="#k阶原点矩和k阶中心矩" class="headerlink" title="k阶原点矩和k阶中心矩"></a>k阶原点矩和k阶中心矩</h2><p>在统计学中，k阶原点矩和k阶中心矩是用于描述概率分布特性的概念。</p><ol><li><p>k阶原点矩：<br>对于一个随机变量X，它的k阶原点矩表示为μ_k &#x3D; E(X^k)，即该随机变量的k次幂的期望值。换句话说，k阶原点矩描述了随机变量X在k次幂上的平均值。</p></li><li><p>k阶中心矩：<br>对于一个随机变量X，它的k阶中心矩表示为μ’_k &#x3D; E[(X - μ)^k]，其中μ为随机变量X的期望值（均值）。k阶中心矩是指将随机变量X减去其均值后再取k次幂的期望。换句话说，k阶中心矩描述了随机变量X关于均值的k次幂的期望值。</p></li></ol><p>关于k阶原点矩和k阶中心矩的一些关键点：</p><ul><li>k阶原点矩包含数据的绝对信息，而k阶中心矩包含数据的相对信息。</li><li>一阶中心矩始终为0，因为它表示随机变量减去自身的均值，结果必然为0。</li><li>二阶中心矩是方差的平方根，用于衡量数据的离散程度。</li><li>三阶中心矩是偏度，用于衡量分布的对称性。</li><li>四阶中心矩是峰度，用于衡量分布的尖峭程度或平坦度。</li></ul><p>总的来说，k阶原点矩和k阶中心矩是用于深入了解随机变量数据分布特性的重要统计量。它们提供了关于数据的高阶统计信息，能够帮助我们更全面地理解随机变量的性质和行为。</p><h2 id="准度和精度"><a href="#准度和精度" class="headerlink" title="准度和精度"></a>准度和精度</h2><p>准度和精度是两个经常在科学与工程领域中使用的概念，它们表示了测量结果或数据的质量，但在含义上有所不同。</p><ol><li><p>准度（Accuracy）：<br>准度指的是测量结果或数据与真实数值之间的偏差程度，即测量结果的接近程度。如果测量结果与真实数值非常接近，则认为该测量是准确的，具有高准度。准度通常用误差或偏差来表示，可以是系统性的（偏差恒定）或随机性的（随机误差）。在实际应用中，准度的提高意味着更接近真实值的测量结果，即更少的误差。</p></li><li><p>精度（Precision）：<br>精度指的是多次测量所得结果之间的一致性或重复性，即测量结果的稳定程度。如果多次测量所得结果非常接近，可以认为该测量是精确的，具有高精度。精度通常用标准偏差或方差来描述，用来衡量测量数据的离散程度。在实际应用中，精度的提高意味着测量结果之间的一致性更高，即数据更加稳定。</p></li></ol><p>区别总结：</p><ul><li>准度强调测量结果与真实值之间的接近程度，而精度强调多次测量结果之间的一致性。</li><li>准度涉及测量结果的准确程度，精度涉及测量结果的稳定程度。</li><li>提高准度意味着减少与真实值的差距，而提高精度意味着增加测量结果之间的一致性。</li></ul><p>在实际应用中，准确度和精度通常需要平衡考虑。一个测量既要准确地表达真实值，又要具有重复性和一致性，这样才能提供可靠的数据支持科学研究、工程设计等领域的决策和判断。</p><h2 id="α−β−γ滤波器和卡尔曼滤波器的联系和区别"><a href="#α−β−γ滤波器和卡尔曼滤波器的联系和区别" class="headerlink" title="α−β−γ滤波器和卡尔曼滤波器的联系和区别"></a>α−β−γ滤波器和卡尔曼滤波器的联系和区别</h2><p>α-β-γ滤波器和卡尔曼滤波器都是用于估计系统状态的滤波器，它们有一些联系和区别：</p><ol><li><p>联系：</p><ul><li>两者都是常用的滤波器算法，用于估计系统的状态，并对传感器数据进行平滑处理。</li><li>在一定程度上，α-β-γ滤波器可以看作是卡尔曼滤波器的一种简化版本，适用于一些简单的系统。</li></ul></li><li><p>区别：</p><ul><li>卡尔曼滤波器是一种基于状态空间模型的递归滤波器，可以处理具有高斯噪声的动态系统。它通过状态估计和误差协方差估计来最优地结合先验信息和测量数据。相比之下，α-β-γ滤波器是一种更简单的滤波器，通常用于低成本的应用和对计算资源要求较低的场景。</li><li>在单个维度上，α-β-γ滤波器可用于对加速度数据进行滤波和平滑处理，而卡尔曼滤波器更常用于多维度状态估计，例如跟踪移动目标。</li><li>卡尔曼滤波器在处理非线性系统和非高斯噪声时效果更好，因为它能够自适应地调整协方差矩阵。而α-β-γ滤波器则更适用于线性系统或高斯噪声的情况。</li></ul></li></ol><p>总的来说，卡尔曼滤波器是一种更加通用和灵活的滤波器算法，适用于较为复杂的系统状态估计问题，而α-β-γ滤波器则是一种简单的滤波器算法，适用于一些简单的系统平滑处理任务。选择哪种滤波器取决于具体的应用场景和系统要求。</p><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p><strong>Q:</strong><br>卡尔曼滤波是根据上一次的值得出的这一次的预测值和这一次的测量值这两个值加权求得的值吗<br><strong>A:</strong><br>卡尔曼滤波是一种用于估计系统状态的强大技术，确实涉及到对上一次状态的估计值、当前时刻的测量值和预测值进行加权平均。在卡尔曼滤波中，系统状态被表示为一个含有状态变量的向量，而系统的动态行为通常由一组线性动态方程和一组线性测量方程描述。</p><p>在每个时间步，卡尔曼滤波器执行以下两个主要步骤：</p><ol><li><p><strong>预测步骤（Predict）</strong>：基于上一次的状态估计以及系统动态方程，预测系统的当前状态。这一预测考虑了上一次的状态估计和系统行为模型，产生一个预测的状态和协方差估计。</p></li><li><p><strong>更新步骤（Update）</strong>：将预测的状态与当前的测量值进行比较，根据二者的关系来修正预测状态，得到更准确的状态估计。这一步骤涉及卡尔曼增益的计算，以确保预测状态和测量状态之间的加权平均。</p></li></ol><p>因此，在卡尔曼滤波中，通过将上一次的状态估计、当前时刻的预测值和测量值进行合理的加权组合，可以更好地估计系统的真实状态，并对噪声进行有效抑制。整个过程通过不断迭代预测和更新步骤，逐渐提高状态估计的准确性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;卡尔曼滤波教程&quot; href=&quot;https://www.kalmanfilter.net/CN/background_cn.html&quot;&gt;&lt;span class=&quot;link-card-b</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="无人驾驶" scheme="http://tumytime.github.io/tags/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6/"/>
    
    <category term="概率论" scheme="http://tumytime.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯嵌入式客观题笔记</title>
    <link href="http://tumytime.github.io/2024/03/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%A2%E8%A7%82%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://tumytime.github.io/2024/03/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%A2%E8%A7%82%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-30T08:23:34.000Z</published>
    <updated>2024-03-31T08:04:37.417Z</updated>
    
    <content type="html"><![CDATA[<details open><summary pointer> 时序逻辑电路 </summary>              <div class='content'>              <div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8hg8xhmilq.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8hg8xhmilq.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>时序逻辑电路:</strong><br>计数器<br>分频器<br>触发器<br>积分器<br>移位寄存器<br>时序比较器<br><strong>组合逻辑电路:</strong><br>逻辑门<br>译码器<br>编码器<br>多路选择器<br>加法器<br>比较器<br>数字比例调节器</p>              </div>            </details><details open><summary pointer> 减法计数器 </summary>              <div class='content'>              <p>一个 8位二进制减法计数器， 初始状态为 00000000， 问经过 268个输入脉冲后， 此计数器的状态为 ______。<br>A.11001111<br>B.11110100<br>C.11110010<br>D.11110011<br>答案：B<br>解析：8位二进制数计数2^8 &#x3D; 256次后回到00000000，还剩268-256&#x3D;12次计数，计数1次后从“00000000”减为“11111111”，此后再减11（00001011），得到11110100，选B。<br>1111 1111<br>– 0000 1011<br>1111 0100</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;details open&gt;&lt;summary pointer&gt; 时序逻辑电路 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;img-wrap&quot;&gt;&lt;div class=&quot;img-bg</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://tumytime.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="stm32" scheme="http://tumytime.github.io/tags/stm32/"/>
    
    <category term="蓝桥杯" scheme="http://tumytime.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>摄像头考核</title>
    <link href="http://tumytime.github.io/2024/03/25/%E6%91%84%E5%83%8F%E5%A4%B4%E8%80%83%E6%A0%B8/"/>
    <id>http://tumytime.github.io/2024/03/25/%E6%91%84%E5%83%8F%E5%A4%B4%E8%80%83%E6%A0%B8/</id>
    <published>2024-03-25T13:50:31.000Z</published>
    <updated>2024-03-25T13:50:49.176Z</updated>
    
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像处理笔记（二）灰度变换和空间滤波基础</title>
    <link href="http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%92%8C%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%9F%BA%E7%A1%80/"/>
    <id>http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%92%8C%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-25T13:04:31.000Z</published>
    <updated>2024-03-25T13:50:12.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灰度变换和空间滤波基础"><a href="#灰度变换和空间滤波基础" class="headerlink" title="灰度变换和空间滤波基础"></a>灰度变换和空间滤波基础</h2><h3 id="灰度变换（灰度反转，对数变换，幂律变换）"><a href="#灰度变换（灰度反转，对数变换，幂律变换）" class="headerlink" title="灰度变换（灰度反转，对数变换，幂律变换）"></a>灰度变换（灰度反转，对数变换，幂律变换）</h3><h4 id="灰度变换原理"><a href="#灰度变换原理" class="headerlink" title="灰度变换原理"></a>灰度变换原理</h4><p>变换原理：通过变换函数T将原图像像素灰度值r映射为灰度值s：</p><p>$s&#x3D;T(r)$</p><h4 id="灰度反转"><a href="#灰度反转" class="headerlink" title="灰度反转"></a>灰度反转</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h5><p>灰度反转：将图像亮暗对调，可以增强图像中暗色区域细节<br>$s&#x3D;T(r)&#x3D;L-1-r$<br>其中L为图像灰度级，0~255灰度图像的灰度级为256.</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="comment">//遍历像素点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) = <span class="number">255</span> - image1_gray.at&lt;uchar&gt;(i, j);  <span class="comment">//灰度反转</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);  <span class="comment">//显示反转图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.lvht9o5v6.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.lvht9o5v6.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>对数变换：扩展图像中的暗像素值，压缩高灰度值。<br>$s&#x3D;T(r)&#x3D;c*log(1+r)$<br>$log(1+r)$斜率逐渐降低，上升趋势逐渐放缓</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) = <span class="number">6</span> * <span class="built_in">log</span>((<span class="type">double</span>)(image1_gray.at&lt;uchar&gt;(i, j)) + <span class="number">1</span>);  <span class="comment">//对数变换 s=6*log(r+1)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">normalize(output_image, output_image, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);  <span class="comment">//图像归一化，转到0~255范围内</span></span><br><span class="line">convertScaleAbs(output_image, output_image);  <span class="comment">//数据类型转换到CV_8U</span></span><br><span class="line">imshow(<span class="string">&quot; output_image&quot;</span>, output_image);  <span class="comment">//显示变换图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.3uulpxj04i.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.3uulpxj04i.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="幂律（伽马变换）"><a href="#幂律（伽马变换）" class="headerlink" title="幂律（伽马变换）"></a>幂律（伽马变换）</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>幂律变换与对数变换类似：<br>$s&#x3D;T(r)&#x3D;c*r^γ$</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image, image1_gray;   <span class="comment">//定义输入图像，输出图像，灰度图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image1, image1_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image1_gray&quot;</span>, image1_gray);   <span class="comment">//显示灰度图像</span></span><br><span class="line"></span><br><span class="line">output_image = image1_gray.clone();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image1_gray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image1_gray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">output_image.at&lt;uchar&gt;(i, j) =<span class="number">6</span>*<span class="built_in">pow</span>((<span class="type">double</span>)image1_gray.at&lt;uchar&gt;(i, j),<span class="number">0.5</span>);  <span class="comment">//幂律变换 s=6*r^0.5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">normalize(output_image, output_image, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);  <span class="comment">//图像归一化，转到0~255范围内</span></span><br><span class="line">convertScaleAbs(output_image, output_image);  <span class="comment">//数据类型转换到CV_8U</span></span><br><span class="line">imshow(<span class="string">&quot; output_image&quot;</span>, output_image);  <span class="comment">//显示变换图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2obahbyue1.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2obahbyue1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="直方图处理（直方图均衡化，直方图匹配（规定化））"><a href="#直方图处理（直方图均衡化，直方图匹配（规定化））" class="headerlink" title="直方图处理（直方图均衡化，直方图匹配（规定化））"></a>直方图处理（直方图均衡化，直方图匹配（规定化））</h3><p>直方图显示了每个像素值在整幅图像中出现的频率或数量，从而帮助我们理解图像的亮度分布情况。</p><h4 id="图像直方图"><a href="#图像直方图" class="headerlink" title="图像直方图"></a>图像直方图</h4><p>非归一化直方图:<br>$h(r_k)&#x3D;n_k$<br>归一化直方图:<br>$p(r_k)&#x3D;{n_k \over MN}$<br>其中MN为图像行数和列数，常说的图像直方图就是归一化直方图。</p><p>获取图像直方图示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image, image_gray, hist;   <span class="comment">//定义输入图像，灰度图像, 直方图</span></span><br><span class="line">image = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(image, image_gray, COLOR_BGR2GRAY);  <span class="comment">//灰度化</span></span><br><span class="line">imshow(<span class="string">&quot; image_gray&quot;</span>, image_gray);   <span class="comment">//显示灰度图像</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取图像直方图</span></span><br><span class="line"><span class="type">int</span> histsize = <span class="number">256</span>;</span><br><span class="line"><span class="type">float</span> ranges[] = &#123; <span class="number">0</span>,<span class="number">256</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* histRanges = &#123; ranges &#125;;</span><br><span class="line">calcHist(&amp;image_gray, <span class="number">1</span>, <span class="number">0</span>, Mat(), hist, <span class="number">1</span>, &amp;histsize, &amp;histRanges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这段代码用于计算图像的直方图，下面是对这段代码的详细解释：</p><ol><li><p><strong>histsize &#x3D; 256：</strong> 这里定义了直方图的大小为256，表示直方图的横轴范围，通常对应着图像可能的像素值范围（0到255）。</p></li><li><p><strong>ranges[] &#x3D; {0, 256}：</strong> 这里定义了直方图可能的像素值范围为0到256，用于指定直方图中每个像素值的范围。</p></li><li><p><em><em>const float</em> histRanges &#x3D; {ranges};</em>* 这一行用于将ranges数组转换为指向常量浮点数的指针，供calcHist函数使用。</p></li><li><p><strong>calcHist(&amp;image_gray, 1, 0, Mat(), hist, 1, &amp;histsize, &amp;histRanges, true, false)：</strong></p><ul><li><strong>&amp;image_gray：</strong> 这是输入的灰度图像，表示要计算直方图的原始图像。</li><li><strong>1：</strong> 表示要计算的图像数量。</li><li><strong>0：</strong> 表示直方图要计算的通道索引，0表示灰度图像。</li><li><strong>Mat()：</strong> 这里是一个掩码图像，用于指定要计算直方图的区域；在这里没有使用，因此为空。</li><li><strong>hist：</strong> 这是用于存储计算后直方图的Mat对象。</li><li><strong>1：</strong> 直方图的维数，对于灰度图像是1维。</li><li><strong>&amp;histsize：</strong> 这是包含直方图大小（256）的指针。</li><li><strong>&amp;histRanges：</strong> 指向直方图范围的指针。</li><li><strong>true：</strong> 指示直方图是否均一化，即在范围0到255内对直方图进行归一化处理。</li><li><strong>false：</strong> 指示直方图是否累积，即表示直方图是否累积计算。</li></ul></li></ol><p>通过这段代码，可以通过calcHist函数计算图像image_gray的直方图，并将结果存储在hist对象中。直方图的范围是0到255之间，且进行了归一化处理。这能够帮助我们了解图像的像素值分布情况，为后续的图像处理和分析提供数据支持。希望这个解释对您有帮助，如果您有任何其他问题，请随时告诉我！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建直方图显示图像</span></span><br><span class="line"><span class="type">int</span> hist_h = <span class="number">300</span>;<span class="comment">//直方图的图像的高</span></span><br><span class="line"><span class="type">int</span> hist_w = <span class="number">512</span>; <span class="comment">//直方图的图像的宽</span></span><br><span class="line"><span class="type">int</span> bin_w = hist_w / histsize;<span class="comment">//直方图的等级</span></span><br><span class="line">Mat <span class="title function_">histImage</span><span class="params">(hist_h, hist_w, CV_8UC3, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span>;<span class="comment">//绘制直方图显示的图像</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制并显示直方图</span></span><br><span class="line">normalize(hist, hist, <span class="number">0</span>, hist_h, NORM_MINMAX, <span class="number">-1</span>, Mat());<span class="comment">//归一化直方图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; histsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">line(histImage, Point((i - <span class="number">1</span>) * bin_w, hist_h - cvRound(hist.at&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line">Point((i)*bin_w, hist_h - cvRound(hist.at&lt;<span class="type">float</span>&gt;(i))), Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;histImage&quot;</span>, histImage);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于将归一化后的直方图数据绘制成直方图图像的过程。下面是对代码的详细解释：</p><ol><li><p><strong><code>for</code>循环：</strong></p><ul><li>这段代码使用<code>for</code>循环遍历直方图的每个条，从第2个条开始到最后一个条。</li><li><code>i</code>从1开始，因为第0个条通常代表背景，可以跳过不绘制。</li></ul></li><li><p><strong><code>line()</code>函数：</strong></p><ul><li><code>line()</code>函数用于在<code>histImage</code>上绘制直方图的条。</li><li><code>Point((i - 1) * bin_w, hist_h - cvRound(hist.at&lt;float&gt;(i - 1)))</code>表示当前条的起始点位置，前一个条的结束点位置。</li><li><code>Point((i)*bin_w, hist_h - cvRound(hist.at&lt;float&gt;(i)))</code> 表示当前条的终点位置。</li><li><code>Scalar(255, 0, 0)</code>指定绘制直线的颜色为蓝色。</li><li><code>2</code>表示线的粗细为2个像素。</li><li><code>8</code>表示线的类型为8-connected。</li><li><code>0</code>表示线的偏移值为0。</li></ul></li><li><p><strong>绘制直方图条：</strong></p><ul><li>通过计算每个直方图条的起始和终止点，使用<code>line()</code>函数在<code>histImage</code>上绘制直方图条。</li><li><code>cvRound()</code>用于将浮点值四舍五入为最接近的整数，确保直方图能够正确映射到图像上。</li></ul></li></ol><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>(我感觉差不多了，我去做考核咯~)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;灰度变换和空间滤波基础&quot;&gt;&lt;a href=&quot;#灰度变换和空间滤波基础&quot; class=&quot;headerlink&quot; title=&quot;灰度变换和空间滤波基础&quot;&gt;&lt;/a&gt;灰度变换和空间滤波基础&lt;/h2&gt;&lt;h3 id=&quot;灰度变换（灰度反转，对数变换，幂律变换）&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像处理笔记（一）基础操作</title>
    <link href="http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://tumytime.github.io/2024/03/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-1/</id>
    <published>2024-03-25T03:51:05.000Z</published>
    <updated>2024-03-25T13:05:31.723Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面一部分笔记都是学习一个大佬的教程做的，但是大佬用的python，我在笔记里都转换成了c++</p></blockquote><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2kroj52zde.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2kroj52zde.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.pf3qismjr.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.pf3qismjr.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.4g49bri91j.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.4g49bri91j.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1set1eq2uf.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1set1eq2uf.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.58h4ti0gy2.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.58h4ti0gy2.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.1hrz89c5f9.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.1hrz89c5f9.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h2 id="图片基本读取操作"><a href="#图片基本读取操作" class="headerlink" title="图片基本读取操作"></a>图片基本读取操作</h2><p>电脑上的彩色图是以 RGB(红 - 绿-蓝，Red-Green-Blue) 颜色模式显示的，但 OpenCV 中彩色图是以 B-G-R 通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是 y，列对应的是 x：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.54xivstf47.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.54xivstf47.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><blockquote><span class='pbg info'>imread()</span><blockquote><p><strong>两个参数:</strong></p><ul><li>参数 1：图片的文件名<br> 如果图片放在当前文件夹下，直接写文件名就行，如”lena.jpg”<br> 否则需要给出绝对路径，如”C:&#x2F;Users&#x2F;lxcqm&#x2F;Desktop&#x2F;图片和视频&#x2F;11111.png”</li><li>参数 2：读入方式，省略即采用默认值<br> cv2.IMREAD_COLOR：彩色图，默认值(1)or(IMREAD_COLOR)<br> cv2.IMREAD_GRAYSCALE：灰度图(0)or(IMREAD_GRAYSCALE)<br> cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)or(IMREAD_UNCHANGED)</li></ul></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载灰度图</span></span><br><span class="line">Mat  img = imread(<span class="string">&quot;C:/Users/lxcqm/Desktop/images/11111.png&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，print(img)的结果为 None，后面处理才会报错，算是个小坑。</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>使用<code>imshow()</code>显示图片，窗口会自适应图片的大小：</p><blockquote><p><code>imshow()</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载灰度图</span></span><br><span class="line">Mat  img = imread(<span class="string">&quot;C:/Users/lxcqm/Desktop/images/11111.png&quot;</span>,<span class="number">0</span>);</span><br><span class="line">imshow(<span class="string">&quot;pic&quot;</span>, img);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数 1 是窗口的名字，参数 2 是要显示的图片。不同窗口之间用窗口名区分，所以窗口名相同就表示是同一个窗口，显示结果如下：<br><strong>效果:</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.32hq7r8seh.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.32hq7r8seh.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p><code>waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒 ms）。<br>时间一到，会继续执行接下来的程序，传入 0 的话表示一直等待。等待期间也可以获取用户的按键输入：k &#x3D; waitKey(0)</p></blockquote><p>我们也可以先用<code>namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namedWindow(<span class="string">&quot;pic2&quot;</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">&quot;pic2&quot;</span>, img);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数 1 依旧是窗口的名字，参数 2 默认是<code>WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><blockquote><p><code>imwrite()</code></p></blockquote><p>使用<code>imwrite()</code>保存图片，参数 1 是包含后缀名的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imwrite(<span class="string">&quot;pictest.jpg&quot;</span>, img);</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.sypoa1fpo.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.sypoa1fpo.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p>会保存在目录文件夹里</p><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><h3 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h3><p>要使用摄像头，需要使用<code>VideoCapture capture(0);</code>参数 <code>0</code> 指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第 2 个摄像头就可以传入 <code>1</code>，依此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        <span class="comment">//&gt;&gt; 是输入流提取运算符</span></span><br><span class="line">        <span class="comment">// 它通常用于从输入流中提取数据并将其存储在相应的变量中</span></span><br><span class="line">        <span class="comment">// 表示从 capture 输入流中读取数据，并将其存储在 frame 变量中</span></span><br><span class="line">        capture &gt;&gt; frame;</span><br><span class="line"></span><br><span class="line">        Mat gray;</span><br><span class="line">        cvtColor(frame, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        imshow(<span class="string">&quot;frame&quot;</span>, gray);</span><br><span class="line">        <span class="keyword">if</span> (waitKey(<span class="number">1</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。<br>通过cap.get(propId)可以获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等。propId 是从 0~18 的数字，代表不同的属性，完整的属性列表可以参考：VideoCaptureProperties(<a href="https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d">https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d</a>)<br>也可以使用cap.set(propId,value)来修改属性值。比如说，我们在 while 之前添加下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> width = capture.get(CAP_PROP_FRAME_WIDTH);</span><br><span class="line"><span class="type">double</span> height = capture.get(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">capture.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>);</span><br><span class="line">capture.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><details open><summary pointer> std::cout << Original width: << width << </summary>              <div class='content'>              <p>这行代码使用了C++中的流输出操作符”&lt;&lt;”，它用于将数据插入到输出流中。在这个语句中：</p><ul><li><code>std::cout</code>: 是C++标准库中的标准输出流对象，用于将数据输出到控制台。</li><li><code>&quot;Original width: &quot;</code>、<code>width</code>、<code>&quot;, height: &quot;</code>、<code>height</code>、<code>std::endl</code> 都是要输出的具体内容。</li><li><code>&lt;&lt;</code>：是流输出操作符，用于将后面的内容插入到输出流中。</li></ul><p>所以，<code>std::cout &lt;&lt; &quot;Original width: &quot; &lt;&lt; width &lt;&lt; &quot;, height: &quot; &lt;&lt; height &lt;&lt; std::endl;</code> 这行代码的作用是将描述原始宽度和高度的字符串以及相应的变量值输出到控制台，并在最后换行。</p>              </div>            </details><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.86texdkg7l.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.86texdkg7l.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h3 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h3><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为 <code>25</code> 或 <code>30</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="string">&quot;C:/Users/lxcqm/Desktop/WeChat_20240325194731.mp4&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error opening video file&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     Mat frame, gray;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!capture.read(frame)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cvtColor(frame, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        imshow(<span class="string">&quot;frame&quot;</span>, gray);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitKey(<span class="number">30</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    capture.release();</span><br><span class="line">    destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    VideoCapture <span class="title function_">capture</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义编码方式并创建 VideoWriter 对象</span></span><br><span class="line">    VideoWriter <span class="title function_">outfile</span><span class="params">(<span class="string">&quot;output.avi&quot;</span>, VideoWriter::fourcc(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>), <span class="number">25.</span>, Size(<span class="number">640</span>, <span class="number">480</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (capture.isOpened()) &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture.read(frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!frame.empty()) &#123;</span><br><span class="line">            outfile.write(frame); <span class="comment">// 写入文件</span></span><br><span class="line">            imshow(<span class="string">&quot;frame&quot;</span>, frame);</span><br><span class="line">            <span class="keyword">if</span> (waitKey(<span class="number">1</span>) == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Mat创建图像（矩阵）"><a href="#Mat创建图像（矩阵）" class="headerlink" title="Mat创建图像（矩阵）"></a>Mat创建图像（矩阵）</h3><h4 id="创建图像（矩阵）：Mat"><a href="#创建图像（矩阵）：Mat" class="headerlink" title="创建图像（矩阵）：Mat"></a>创建图像（矩阵）：Mat</h4><p>使用Mat创建图像（矩阵）的常用形式有：</p><ol><li><p>创建一个空图像，大小为0</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat image1;</span><br></pre></td></tr></table></figure></li><li><p>指定矩阵大小，指定数据类型：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U)</span>;</span><br></pre></td></tr></table></figure><p> 参数:矩阵行数，矩阵列数，数据类型</p><p> 其中数据类型有很多种，常用的应该有：</p><p> CV_8U：8位无符号型（0~255），即灰度图像；</p><p> CV_8UC3：三通道8位无符号型，这里三通道指B（蓝）G（绿）R（红），与matlab中的RGB正好相反。</p><p> 这里创建矩阵时未指定矩阵的值，发现默认值的大小为205.</p></li><li><p>指定矩阵大小，指定数据类型，设置初始值：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, <span class="number">100</span>)</span>;</span><br></pre></td></tr></table></figure><p> 这里包含四个参数：矩阵行数，矩阵列数，数据类型，初始值；<br> 对于灰度图像：可以直接给出初始值，也可以使用Scalar（）；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, <span class="number">100</span>)</span>;</span><br><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8U, Scalar(<span class="number">100</span>))</span>;<span class="comment">//Scalar:标量</span></span><br></pre></td></tr></table></figure><p> 对于三通道图像：使用Scalar（）；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="title function_">image1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,CV_8UC3, Scalar(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>))</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取图像信息"><a href="#获取图像信息" class="headerlink" title="获取图像信息"></a>获取图像信息</h3><p>获取图像的宽度（列数），高度（行数），尺寸和通道数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的行数为： &quot;</span> &lt;&lt; image1.rows &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的高度，行数；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的列数为： &quot;</span> &lt;&lt; image1.cols &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的宽度，列数；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的通道数为： &quot;</span> &lt;&lt; image1.channels() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的通道数，彩色图=3，灰度图=1；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像的尺寸为： &quot;</span> &lt;&lt; image1.size &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//获取图像的尺寸，行*列；</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.64dm9cq5y1.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.64dm9cq5y1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="感兴趣区域"><a href="#感兴趣区域" class="headerlink" title="感兴趣区域"></a>感兴趣区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line">Mat <span class="title function_">imageROI</span><span class="params">(image1, Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>))</span>;  <span class="comment">//定义感兴趣区域</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Rect（）有四个参数，Rect（a,b,c,d）:</p><ul><li>a：感兴趣区域列(cols)的起点；</li><li>b：感兴趣区域行(rows)的起点；</li><li>c：感兴趣区域的列数(cols)；</li><li>d：感兴趣区域的行数(rows)；</li></ul><h3 id="通过鼠标点击操作获取图像的像素坐标和像素值"><a href="#通过鼠标点击操作获取图像的像素坐标和像素值" class="headerlink" title="通过鼠标点击操作获取图像的像素坐标和像素值"></a>通过鼠标点击操作获取图像的像素坐标和像素值</h3><h4 id="创建鼠标操作函数的头文件"><a href="#创建鼠标操作函数的头文件" class="headerlink" title="创建鼠标操作函数的头文件"></a>创建鼠标操作函数的头文件</h4><details open><summary pointer> onMouse.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span>;  <span class="comment">//evnet:鼠标事件类型 x,y:鼠标坐标 flags：鼠标哪个键</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span>  <span class="comment">//evnet:鼠标事件类型 x,y:鼠标坐标 flags：鼠标哪个键</span></span><br><span class="line">&#123;</span><br><span class="line">Mat* im = reinterpret_cast&lt;Mat*&gt;(param);</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVENT_LBUTTONDOWN:</span><br><span class="line"><span class="comment">//显示图像像素值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (static_cast&lt;<span class="type">int</span>&gt;(im-&gt;channels()) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若图像为单通道图像，则显示鼠标点击的坐标以及灰度值</span></span><br><span class="line"><span class="keyword">switch</span> (im-&gt;type())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;uchar&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">char</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;ushort&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">short</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">int</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">float</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; ) value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;<span class="type">double</span>&gt;(Point(x, y))) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若图像为彩色图像，则显示鼠标点击坐标以及对应的B, G, R值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;  B value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">0</span>])</span><br><span class="line">&lt;&lt; <span class="string">&quot;  G value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">1</span>])</span><br><span class="line">&lt;&lt; <span class="string">&quot;  R value is: &quot;</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(im-&gt;at&lt;Vec3b&gt;(Point(x, y))[<span class="number">2</span>])</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setMouseCallback(&quot;image1&quot;, onMouse, reinterpret_cast&lt;void*&gt;(&amp;image1)); //关联图像显示窗口和onMouse函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat每个格子内的数据格式---------- - Mat定义</span></span><br><span class="line"><span class="comment">//Mat_&lt;uchar&gt;-------- - CV_8U（0-255）</span></span><br><span class="line"><span class="comment">//Mat&lt;char&gt;---------- - CV_8S（-128-127）</span></span><br><span class="line"><span class="comment">//Nat_&lt;short&gt;-------- - CV_16S（-32768-32767）</span></span><br><span class="line"><span class="comment">//Mat_&lt;ushort&gt;--------CV_16U（0-65535）</span></span><br><span class="line"><span class="comment">//Mat_&lt;int&gt;---------- - CV_32S（-2147483648-2147483647）</span></span><br><span class="line"><span class="comment">//Mat_&lt;float&gt;----------CV_32F（-FLT_MAX…FLT_MAX，INF，NAN）</span></span><br><span class="line"><span class="comment">//Mat_&lt;double&gt;--------CV_64F（-DBL_MAX…DBL_MAX，INF，NAN）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat数据类型和通道对应的type()</span></span><br><span class="line"><span class="comment">//              C1          C2          C3          C4</span></span><br><span class="line"><span class="comment">//CV_8U         0           8           16          24</span></span><br><span class="line"><span class="comment">//CV_8S         1           9           17          25</span></span><br><span class="line"><span class="comment">//CV_16U        2          10           18          26</span></span><br><span class="line"><span class="comment">//CV_16S        3          11           19          27</span></span><br><span class="line"><span class="comment">//CV_32S        4          12           20          28</span></span><br><span class="line"><span class="comment">//CV_32F        5          13           21          29</span></span><br><span class="line"><span class="comment">//CV_64F        6          14           22          30</span></span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><details open><summary pointer>  </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onMouse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setMouseCallback(<span class="string">&quot;image1&quot;</span>, onMouse, reinterpret_cast&lt;<span class="type">void</span>*&gt;(&amp;image1)); <span class="comment">//关联图像显示窗口和onMouse函数</span></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.6f0g2iecfm.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.6f0g2iecfm.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="访问图像像素"><a href="#访问图像像素" class="headerlink" title="访问图像像素"></a>访问图像像素</h3><h4 id="访问（j-i）处像素"><a href="#访问（j-i）处像素" class="headerlink" title="访问（j,i）处像素"></a>访问（j,i）处像素</h4><p>以8位（0~255）灰度图像和BGR彩色图像为例，用at可以访问图像像素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灰度图像：</span></span><br><span class="line">image.at&lt;uchar&gt;(j, i) <span class="comment">//j为行数，i为列数</span></span><br><span class="line"><span class="comment">//BGR彩色图像</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>] <span class="comment">//B分量</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>] <span class="comment">//G分量</span></span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>] <span class="comment">//R分量</span></span><br></pre></td></tr></table></figure><p><strong>例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;fire.jpg&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示图像；</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">50</span>, j = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> b = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> g = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> r = image1.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;图像该点的像素(BGR):&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">waitKey(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.7p22d7s7r.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.7p22d7s7r.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="在图像中加入白色椒盐噪声"><a href="#在图像中加入白色椒盐噪声" class="headerlink" title="在图像中加入白色椒盐噪声"></a>在图像中加入白色椒盐噪声</h4><h5 id="创建Salt头文件"><a href="#创建Salt头文件" class="headerlink" title="创建Salt头文件"></a>创建Salt头文件</h5><details open><summary pointer> Salt.h </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span>  <span class="comment">//随机数头文件</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Salt</span><span class="params">(Mat image, <span class="type">int</span> n)</span>; <span class="comment">//n：加入噪声点数</span></span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="创建Salt源文件"><a href="#创建Salt源文件" class="headerlink" title="创建Salt源文件"></a>创建Salt源文件</h5><details open><summary pointer> Salt.cpp </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Salt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Salt</span><span class="params">(Mat image, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//随机数生成器</span></span><br><span class="line">default_random_engine generater;</span><br><span class="line">uniform_int_distribution&lt;<span class="type">int</span>&gt;randomRow(<span class="number">0</span>, image.rows - <span class="number">1</span>);</span><br><span class="line">uniform_int_distribution&lt;<span class="type">int</span>&gt;randomCol(<span class="number">0</span>, image.cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">i = randomCol(generater);</span><br><span class="line">j = randomRow(generater);</span><br><span class="line"><span class="keyword">if</span> (image.channels() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.channels() == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><details open><summary pointer> main.cpp </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Salt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">Mat image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);  <span class="comment">//显示原图像；</span></span><br><span class="line"></span><br><span class="line">Salt(image1, <span class="number">5000</span>); <span class="comment">//加入5000个噪声点</span></span><br><span class="line">imshow(<span class="string">&quot;image2&quot;</span>, image1);  <span class="comment">//显示噪声图像；</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><strong>效果</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.231muzt7o0.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.231muzt7o0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h3 id="遍历图像像素"><a href="#遍历图像像素" class="headerlink" title="遍历图像像素"></a>遍历图像像素</h3><h4 id="指针扫描"><a href="#指针扫描" class="headerlink" title="指针扫描"></a>指针扫描</h4><p>以下面模板对图像进行扫描运算为例：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2h82lv6z7m.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2h82lv6z7m.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image;   <span class="comment">//定义输入图像和输出图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">output_image = Mat(image1.size(), image1.type());  <span class="comment">//定义输出图像大小</span></span><br><span class="line">output_image = image1.clone();   <span class="comment">//克隆原图像素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rows = image1.rows;    <span class="comment">//原图行数</span></span><br><span class="line"><span class="type">int</span> stepx = image1.channels();   <span class="comment">//原图通道数</span></span><br><span class="line"><span class="type">int</span> cols = (image1.cols) * image1.channels();  <span class="comment">//矩阵总列数，在BGR彩色图像中，每个像素的BGR通道按顺序排列，因此总列数=像素宽度*通道数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row =<span class="number">1</span> ; row &lt; (rows - <span class="number">1</span>); row++)   <span class="comment">//对行遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> uchar* previous = image1.ptr&lt;uchar&gt;(row - <span class="number">1</span>);  <span class="comment">//原图上一行指针</span></span><br><span class="line"><span class="type">const</span> uchar* current = image1.ptr&lt;uchar&gt;(row);       <span class="comment">//原图当前行指针</span></span><br><span class="line"><span class="type">const</span> uchar* next = image1.ptr&lt;uchar&gt;(row + <span class="number">1</span>);      <span class="comment">//原图下一行指针</span></span><br><span class="line">uchar* output = output_image.ptr&lt;uchar&gt;(row);        <span class="comment">//输出图像当前行指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = stepx; col &lt; (cols- stepx); col++)  <span class="comment">//对列遍历</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//卷积计算</span></span><br><span class="line">output[col] = saturate_cast&lt;uchar&gt;(<span class="number">5</span>*current[col] - (previous[col]+ current[col- stepx]+ current[col + stepx]+ next[col]));</span><br><span class="line"><span class="comment">//saturate_cast&lt;uchar&gt;(a)，当a在0—255时输出a，当a小于0输出0，当a大于255输出255，保证a的值在0~255之间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2a4uqfua0g.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2a4uqfua0g.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><p><strong>把卷积核中间改成4：</strong><br><strong>输出</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.8hg8qlrb43.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.8hg8qlrb43.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div><h4 id="opencv自带的卷积运算：filter2D"><a href="#opencv自带的卷积运算：filter2D" class="headerlink" title="opencv自带的卷积运算：filter2D"></a>opencv自带的卷积运算：filter2D</h4><p>上面的方法可以简化为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">Mat image1, output_image;   <span class="comment">//定义输入图像和输出图像</span></span><br><span class="line">image1 = imread(<span class="string">&quot;lena.png&quot;</span>);  <span class="comment">//读取图像；</span></span><br><span class="line"><span class="keyword">if</span> (image1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读取错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat kernel = (Mat_&lt;<span class="type">char</span>&gt;(<span class="number">3</span>,<span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);  <span class="comment">//创建滤波器</span></span><br><span class="line">filter2D(image1, output_image, image1.depth(), kernel);  <span class="comment">//卷积</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;image1&quot;</span>, image1);</span><br><span class="line">imshow(<span class="string">&quot;output_image&quot;</span>, output_image);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter2D函数中，image1.depth()是用来获取图像image1的深度（depth）信息的函数调用。</p><p>图像的深度表示图像中每个像素值的数据类型。在OpenCV中，常见的图像深度包括：</p><ul><li>CV_8U：8位无符号整数（即Unsigned char），对应于灰度图像的深度</li><li>CV_16U：16位无符号整数</li><li>CV_16S：16位有符号整数</li><li>CV_32S：32位有符号整数</li><li>CV_32F：32位浮点数</li><li>CV_64F：64位浮点数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前面一部分笔记都是学习一个大佬的教程做的，但是大佬用的python，我在笔记里都转换成了c++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础配置&quot;&gt;&lt;a href=&quot;#基础配置&quot; class=&quot;headerlink&quot; title=&quot;基础</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="图像处理" scheme="http://tumytime.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="OpenCV" scheme="http://tumytime.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>c语言计算机二级笔记</title>
    <link href="http://tumytime.github.io/2024/03/23/c%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://tumytime.github.io/2024/03/23/c%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-23T08:39:11.000Z</published>
    <updated>2024-03-25T03:50:05.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><h3 id="E-R实体联系"><a href="#E-R实体联系" class="headerlink" title="E-R实体联系"></a>E-R实体联系</h3><ol><li><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.2krogi3z4f.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.2krogi3z4f.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div> 矩形表示实体，菱形表示实体之间的联系</li><li>在关系数据库中，用于表示实体间联系的是<strong>二维表</strong></li><li>将E-R图转换为关系模式时，实体和联系都可以表示为<strong>关系</strong>(关系就是二维表)</li><li><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="https://tumytime.github.io/picx-images-hosting/image.969i7jl0dn.webp" class="lazyload placeholder" data-srcset="https://tumytime.github.io/picx-images-hosting/image.969i7jl0dn.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div></div></li><li></li></ol><p>已经考完了。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统&quot;&gt;&lt;a href=&quot;#计算机系统&quot; class=&quot;headerlink&quot; title=&quot;计算机系统&quot;&gt;&lt;/a&gt;计算机系统&lt;/h2&gt;&lt;h3 id=&quot;E-R实体联系&quot;&gt;&lt;a href=&quot;#E-R实体联系&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="c语言" scheme="http://tumytime.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c语言" scheme="http://tumytime.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="计算机二级" scheme="http://tumytime.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>收藏夹</title>
    <link href="http://tumytime.github.io/2024/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    <id>http://tumytime.github.io/2024/03/22/%E6%94%B6%E8%97%8F%E5%A4%B9/</id>
    <published>2024-03-22T11:54:52.000Z</published>
    <updated>2024-03-25T05:21:58.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><div class="tagLink"><a class="link-card" title="从头开始实现一个神经网络" href="https://mp.weixin.qq.com/s/lk12kP2fbuSBSV5lSFKTlA"><span class="link-card-backdrop" style="background-image: url(https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567)"></span><div class="left"><img src="https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-0b63b54fc59d235ad97530a98bc0e014_1440w.webp?source=2c26e567" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">从头开始实现一个神经网络</p><p class="url">https://mp.weixin.qq.com/s/lk12kP2fbuSBSV5lSFKTlA</p></div></a></div><div class="tagLink"><a class="link-card" title="数据处理之归一化、标准化、正则化" href="https://job.yanxishe.com/blogDetail/27604"><span class="link-card-backdrop" style="background-image: url(https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png)"></span><div class="left"><img src="https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png" class="lazyload placeholder" data-srcset="https://static.leiphone.com/uploads/new/sns/blogSpe/article/202110/616c488c9c69f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">数据处理之归一化、标准化、正则化</p><p class="url">https://job.yanxishe.com/blogDetail/27604</p></div></a></div><iframe src="//player.bilibili.com/player.html?aid=770444004&bvid=BV18r4y1M71J&cid=760424160&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=541842600&bvid=BV1yi4y1g7ro&cid=227677652&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><details ><summary pointer> 存一下包版本 </summary>              <div class='content'>              <p>(Paddle_Py3.12) C:\Users\lxcqm&gt;pip list<br>Package                 Version</p><hr><p>absl-py                 2.1.0<br>anyio                   4.3.0<br>archspec                0.2.3<br>astor                   0.8.1<br>astunparse              1.6.3<br>boltons                 23.1.1<br>Brotli                  1.0.9<br>certifi                 2024.2.2<br>cffi                    1.16.0<br>charset-normalizer      3.3.2<br>cloudpickle             3.0.0<br>cmake                   3.28.3<br>colorama                0.4.6<br>conda                   24.1.2<br>conda-libmamba-solver   24.1.0<br>conda-package-handling  2.2.0<br>conda_package_streaming 0.9.0<br>contourpy               1.2.0<br>cycler                  0.11.0<br>Cython                  3.0.9<br>decorator               5.1.1<br>distro                  1.9.0<br>filelock                3.13.1<br>flatbuffers             24.3.7<br>fonttools               4.25.0<br>gast                    0.5.4<br>google-pasta            0.2.0<br>grpcio                  1.62.1<br>gym                     0.26.2<br>gym-notices             0.0.8<br>h11                     0.14.0<br>h5py                    3.10.0<br>httpcore                1.0.4<br>httpx                   0.27.0<br>idna                    3.6<br>Jinja2                  3.1.3<br>joblib                  1.3.2<br>jsonpatch               1.33<br>jsonpointer             2.4<br>keras                   3.1.1<br>kiwisolver              1.4.4<br>libclang                18.1.1<br>libmambapy              1.5.7<br>mamba                   1.5.7<br>Markdown                3.6<br>markdown-it-py          3.0.0<br>MarkupSafe              2.1.5<br>matplotlib              3.8.0<br>mdurl                   0.1.2<br>menuinst                2.0.2<br>meson                   1.3.2<br>mkl-fft                 1.3.8<br>mkl-random              1.2.4<br>mkl-service             2.4.0<br>ml-dtypes               0.3.2<br>mpmath                  1.3.0<br>munkres                 1.1.4<br>namex                   0.0.7<br>nes_py                  8.2.1<br>networkx                3.2.1<br>numpy                   1.26.4<br>opencv-python           4.9.0.80<br>opt-einsum              3.3.0<br>optree                  0.10.0<br>packaging               23.1<br>paddlepaddle-gpu        2.6.0.post120<br>pandas                  2.2.1<br>pillow                  10.2.0<br>pip                     24.0<br>platformdirs            4.2.0<br>pluggy                  1.4.0<br>ply                     3.11<br>protobuf                4.25.2<br>pycocotools             2.0<br>pycosat                 0.6.6<br>pycparser               2.21<br>pyglet                  1.5.21<br>Pygments                2.17.2<br>pyparsing               3.0.9<br>PyQt5                   5.15.10<br>PyQt5-sip               12.13.0<br>PySocks                 1.7.1<br>python-dateutil         2.8.2<br>pytz                    2024.1<br>PyYAML                  6.0.1<br>requests                2.31.0<br>rich                    13.7.1<br>ruamel.yaml             0.18.6<br>ruamel.yaml.clib        0.2.8<br>scipy                   1.12.0<br>setuptools              69.1.1<br>sip                     6.7.12<br>six                     1.16.0<br>sniffio                 1.3.1<br>sympy                   1.12<br>tensorboard             2.16.2<br>tensorboard-data-server 0.7.2<br>tensorflow              2.16.1<br>tensorflow-intel        2.16.1<br>termcolor               2.4.0<br>threadpoolctl           3.3.0<br>torch                   2.2.1<br>torchaudio              2.2.1<br>torchvision             0.17.1<br>tornado                 6.3.3<br>tqdm                    4.66.2<br>truststore              0.8.0<br>typing_extensions       4.10.0<br>tzdata                  2024.1<br>urllib3                 2.2.1<br>Werkzeug                3.0.1<br>wheel                   0.43.0<br>win-inet-pton           1.1.0<br>wrapt                   1.16.0<br>zstandard               0.22.0</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AI&quot;&gt;&lt;a href=&quot;#AI&quot; class=&quot;headerlink&quot; title=&quot;AI&quot;&gt;&lt;/a&gt;AI&lt;/h2&gt;&lt;div class=&quot;tagLink&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;从头开始实现一个神经网络&quot; href=&quot;http</summary>
      
    
    
    
    <category term="智能车" scheme="http://tumytime.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
    <category term="Python" scheme="http://tumytime.github.io/tags/Python/"/>
    
    <category term="深度学习" scheme="http://tumytime.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="智能车" scheme="http://tumytime.github.io/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    <category term="YoloV3" scheme="http://tumytime.github.io/tags/YoloV3/"/>
    
  </entry>
  
</feed>
